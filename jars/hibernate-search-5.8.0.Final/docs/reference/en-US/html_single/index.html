<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.4">
<title>Hibernate Search 5.8.0.Final: Reference Guide</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
/* Remove comment around @import statement below when using as a custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}
audio,canvas,video{display:inline-block}
audio:not([controls]){display:none;height:0}
[hidden],template{display:none}
script{display:none!important}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
body{margin:0}
a{background:transparent}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
input[type="search"]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}
input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*:before,*:after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
body{-webkit-font-smoothing:antialiased}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.spread{width:100%}
p.lead,.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{font-size:1.21875em;line-height:1.6}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:none}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #ddddd8;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol,ul.no-bullet,ol.no-bullet{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.no-bullet{list-style:none}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite:before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media only screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7;font-weight:bold}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt,table tr:nth-of-type(even){background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
body{tab-size:4}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix:before,.clearfix:after,.float-group:before,.float-group:after{content:" ";display:table}
.clearfix:after,.float-group:after{clear:both}
*:not(pre)>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background-color:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre,pre>code{line-height:1.45;color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;text-rendering:optimizeSpeed}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background-color:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menu{color:rgba(0,0,0,.8)}
b.button:before,b.button:after{position:relative;top:-1px;font-weight:400}
b.button:before{content:"[";padding:0 3px 0 2px}
b.button:after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header:before,#header:after,#content:before,#content:after,#footnotes:before,#footnotes:after,#footer:before,#footer:after{content:" ";display:table}
#header:after,#content:after,#footnotes:after,#footer:after{clear:both}
#content{margin-top:1.25em}
#content:before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #ddddd8}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #ddddd8;padding-bottom:8px}
#header .details{border-bottom:1px solid #ddddd8;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span:before{content:"\00a0\2013\00a0"}
#header .details br+span.author:before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark:before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber:after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #ddddd8;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #efefed;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media only screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #efefed;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #efefed;left:auto;right:0}}
@media only screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background-color:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
.sect1{padding-bottom:.625em}
@media only screen and (min-width:768px){.sect1{padding-bottom:1.25em}}
.sect1+.sect1{border-top:1px solid #efefed}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor:before,h2>a.anchor:before,h3>a.anchor:before,#toctitle>a.anchor:before,.sidebarblock>.content>.title>a.anchor:before,h4>a.anchor:before,h5>a.anchor:before,h6>a.anchor:before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock>caption.title{white-space:nowrap;overflow:visible;max-width:0}
.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>.paragraph:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #ddddd8;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock pre:not(.highlight),.listingblock pre[class="highlight"],.listingblock pre[class^="highlight "],.listingblock pre.CodeRay,.listingblock pre.prettyprint{background:#f7f7f8}
.sidebarblock .literalblock pre,.sidebarblock .listingblock pre:not(.highlight),.sidebarblock .listingblock pre[class="highlight"],.sidebarblock .listingblock pre[class^="highlight "],.sidebarblock .listingblock pre.CodeRay,.sidebarblock .listingblock pre.prettyprint{background:#f2f1f1}
.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;padding:1em;font-size:.8125em}
.literalblock pre.nowrap,.literalblock pre[class].nowrap,.listingblock pre.nowrap,.listingblock pre[class].nowrap{overflow-x:auto;white-space:pre;word-wrap:normal}
@media only screen and (min-width:768px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:.90625em}}
@media only screen and (min-width:1280px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:1em}}
.literalblock.output pre{color:#f7f7f8;background-color:rgba(0,0,0,.9)}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.listingblock>.content{position:relative}
.listingblock code[data-lang]:before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:#999}
.listingblock:hover code[data-lang]:before{display:block}
.listingblock.terminal pre .command:before{content:attr(data-prompt);padding-right:.5em;color:#999}
.listingblock.terminal pre .command:not([data-prompt]):before{content:"$"}
table.pyhltable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.pyhltable td{vertical-align:top;padding-top:0;padding-bottom:0;line-height:1.45}
table.pyhltable td.code{padding-left:.75em;padding-right:0}
pre.pygments .lineno,table.pyhltable td:not(.code){color:#999;padding-left:0;padding-right:.5em;border-right:1px solid #ddddd8}
pre.pygments .lineno{display:inline-block;margin-right:.25em}
table.pyhltable .linenodiv{background:none!important;padding-right:0!important}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock blockquote p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote:before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.5em;margin-right:.5ex;text-align:right}
.quoteblock .quoteblock{margin-left:0;margin-right:0;padding:.5em 0;border-left:3px solid rgba(0,0,0,.6)}
.quoteblock .quoteblock blockquote{padding:0 0 0 .75em}
.quoteblock .quoteblock blockquote:before{display:none}
.verseblock{margin:0 1em 1.25em 1em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract{margin:0 0 1.25em 0;display:block}
.quoteblock.abstract blockquote,.quoteblock.abstract blockquote p{text-align:left;word-spacing:0}
.quoteblock.abstract blockquote:before,.quoteblock.abstract blockquote p:first-of-type:before{display:none}
table.tableblock{max-width:100%;border-collapse:separate}
table.tableblock td>.paragraph:last-child p>p:last-child,table.tableblock th>p:last-child,table.tableblock td>p:last-child{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all th.tableblock,table.grid-all td.tableblock{border-width:0 1px 1px 0}
table.grid-all tfoot>tr>th.tableblock,table.grid-all tfoot>tr>td.tableblock{border-width:1px 1px 0 0}
table.grid-cols th.tableblock,table.grid-cols td.tableblock{border-width:0 1px 0 0}
table.grid-all *>tr>.tableblock:last-child,table.grid-cols *>tr>.tableblock:last-child{border-right-width:0}
table.grid-rows th.tableblock,table.grid-rows td.tableblock{border-width:0 0 1px 0}
table.grid-all tbody>tr:last-child>th.tableblock,table.grid-all tbody>tr:last-child>td.tableblock,table.grid-all thead:last-child>tr>th.tableblock,table.grid-rows tbody>tr:last-child>th.tableblock,table.grid-rows tbody>tr:last-child>td.tableblock,table.grid-rows thead:last-child>tr>th.tableblock{border-bottom-width:0}
table.grid-rows tfoot>tr>th.tableblock,table.grid-rows tfoot>tr>td.tableblock{border-width:1px 0 0 0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot{border-width:1px 0}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
td>div.verse{white-space:pre}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.unstyled,ol.unnumbered,ul.checklist,ul.none{list-style-type:none}
ul.unstyled,ol.unnumbered,ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1em;font-size:.85em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{width:1em;position:relative;top:1px}
ul.inline{margin:0 auto .625em auto;margin-left:-1.375em;margin-right:0;padding:0;list-style:none;overflow:hidden}
ul.inline>li{list-style:none;float:left;margin-left:1.375em;display:block}
ul.inline>li>*{display:block}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist>table tr>td:first-of-type{padding:0 .75em;line-height:1}
.colist>table tr>td:last-of-type{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left,.imageblock[style*="float: left"]{margin:.25em .625em 1.25em 0}
.imageblock.right,.imageblock[style*="float: right"]{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em 0;border-width:1px 0 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;text-indent:-1.05em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background-color:#00fafa}
.black{color:#000}
.black-background{background-color:#000}
.blue{color:#0000bf}
.blue-background{background-color:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background-color:#fa00fa}
.gray{color:#606060}
.gray-background{background-color:#7d7d7d}
.green{color:#006000}
.green-background{background-color:#007d00}
.lime{color:#00bf00}
.lime-background{background-color:#00fa00}
.maroon{color:#600000}
.maroon-background{background-color:#7d0000}
.navy{color:#000060}
.navy-background{background-color:#00007d}
.olive{color:#606000}
.olive-background{background-color:#7d7d00}
.purple{color:#600060}
.purple-background{background-color:#7d007d}
.red{color:#bf0000}
.red-background{background-color:#fa0000}
.silver{color:#909090}
.silver-background{background-color:#bcbcbc}
.teal{color:#006060}
.teal-background{background-color:#007d7d}
.white{color:#bfbfbf}
.white-background{background-color:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background-color:#fafa00}
span.icon>.fa{cursor:default}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note:before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip:before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning:before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution:before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important:before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background-color:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]:after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background-color:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@media print{@page{margin:1.25cm .75cm}
*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare):after,a[href^="https:"]:not(.bare):after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]:after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #ddddd8!important;padding-bottom:0!important}
.sect1{padding-bottom:0!important}
.sect1+.sect1{border:0!important}
#header>h1:first-child{margin-top:1.25rem}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em 0}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span:before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]:before{display:block}
#footer{background:none!important;padding:0 .9375em}
#footer-text{color:rgba(0,0,0,.6)!important;font-size:.9em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
</style>
<link rel="stylesheet" href="css/font-awesome/css/font-awesome.min.css">
<!-- HibernateDoc.Meta -->
<meta name="description" content="Hibernate Search, full text search for your entities - Reference Documentation" />
<meta name="keywords" content="hibernate, search, hibernate search, full text, lucene, elasticsearch" />
<link rel="canonical" href="https://docs.jboss.org/hibernate/stable/search/reference/en-US/html_single/" />
<!-- /HibernateDoc.Meta -->

<link rel="stylesheet" href="css/hibernate.css" type="text/css" />
</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>Hibernate Search 5.8.0.Final: Reference Guide</h1>
<div class="details">
<span id="revdate">2017-09-13</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#preface">Preface</a></li>
<li><a href="#getting-started">1. Getting started</a>
<ul class="sectlevel2">
<li><a href="#_system_requirements">1.1. System Requirements</a></li>
<li><a href="#_migration_notes">1.2. Migration notes</a></li>
<li><a href="#_required_libraries">1.3. Required libraries</a></li>
<li><a href="#_deploying_on_wildfly">1.4. Deploying on WildFly</a></li>
<li><a href="#_configuration">1.5. Configuration</a></li>
<li><a href="#_indexing">1.6. Indexing</a></li>
<li><a href="#_searching">1.7. Searching</a></li>
<li><a href="#_analyzer">1.8. Analyzer</a></li>
<li><a href="#_what_s_next">1.9. What&#8217;s next</a></li>
</ul>
</li>
<li><a href="#search-architecture">2. Architecture</a>
<ul class="sectlevel2">
<li><a href="#_overview">2.1. Overview</a></li>
<li><a href="#_backend">2.2. Backend</a></li>
<li><a href="#search-architecture-readerstrategy">2.3. Reader strategy</a></li>
</ul>
</li>
<li><a href="#search-configuration">3. Configuration</a>
<ul class="sectlevel2">
<li><a href="#search-configuration-event">3.1. Enabling Hibernate Search and automatic indexing</a></li>
<li><a href="#configuration-indexmanager">3.2. Configuring the IndexManager</a></li>
<li><a href="#search-configuration-directory">3.3. Directory configuration</a></li>
<li><a href="#configuration-worker">3.4. Worker configuration</a></li>
<li><a href="#configuration-reader-strategy">3.5. Reader strategy configuration</a></li>
<li><a href="#_serialization">3.6. Serialization</a></li>
<li><a href="#exception-handling">3.7. Exception handling</a></li>
<li><a href="#_lucene_configuration">3.8. Lucene configuration</a></li>
<li><a href="#_metadata_api">3.9. Metadata API</a></li>
<li><a href="#search-configuration-deploy-on-wildfly">3.10. Hibernate Search as a WildFly module</a></li>
</ul>
</li>
<li><a href="#search-mapping">4. Mapping entities to the index structure</a>
<ul class="sectlevel2">
<li><a href="#search-mapping-entity">4.1. Mapping an entity</a></li>
<li><a href="#section-boosting">4.2. Boosting</a></li>
<li><a href="#_analysis">4.3. Analysis</a></li>
<li><a href="#search-mapping-bridge">4.4. Bridges</a></li>
<li><a href="#search-mapping-indexinginterceptor">4.5. Conditional indexing</a></li>
<li><a href="#provided-id">4.6. Providing your own id</a></li>
<li><a href="#hsearch-mapping-programmaticapi">4.7. Programmatic API</a></li>
</ul>
</li>
<li><a href="#search-query">5. Querying</a>
<ul class="sectlevel2">
<li><a href="#section-building-lucene-queries">5.1. Building queries</a></li>
<li><a href="#_retrieving_the_results">5.2. Retrieving the results</a></li>
<li><a href="#query-filter">5.3. Filters</a></li>
<li><a href="#query-faceting">5.4. Faceting</a></li>
<li><a href="#_optimizing_the_query_process">5.5. Optimizing the query process</a></li>
</ul>
</li>
<li><a href="#manual-index-changes">6. Manual index changes</a>
<ul class="sectlevel2">
<li><a href="#_adding_instances_to_the_index">6.1. Adding instances to the index</a></li>
<li><a href="#_deleting_instances_from_the_index">6.2. Deleting instances from the index</a></li>
<li><a href="#search-batchindex">6.3. Rebuilding the whole index</a></li>
</ul>
</li>
<li><a href="#search-optimize">7. Index Optimization</a>
<ul class="sectlevel2">
<li><a href="#_automatic_optimization">7.1. Automatic optimization</a></li>
<li><a href="#_manual_optimization">7.2. Manual optimization</a></li>
<li><a href="#_adjusting_optimization">7.3. Adjusting optimization</a></li>
</ul>
</li>
<li><a href="#search-monitoring">8. Monitoring</a>
<ul class="sectlevel2">
<li><a href="#_jmx">8.1. JMX</a></li>
</ul>
</li>
<li><a href="#spatial">9. Spatial</a>
<ul class="sectlevel2">
<li><a href="#spatial-indexing">9.1. Enable indexing of Spatial Coordinates</a></li>
<li><a href="#spatial-queries">9.2. Performing Spatial Queries</a></li>
<li><a href="#spatial-multiplecoordinates">9.3. Multiple Coordinate pairs</a></li>
<li><a href="#spatial-behind-curtain">9.4. Insight: implementation details of spatial hashes indexing</a></li>
</ul>
</li>
<li><a href="#search-lucene-native">10. Advanced features</a>
<ul class="sectlevel2">
<li><a href="#AccessingSearchFactory">10.1. Accessing the <code>SearchFactory</code></a></li>
<li><a href="#AccessingSearchIntegrator">10.2. Accessing the <code>SearchIntegrator</code></a></li>
<li><a href="#IndexReaders">10.3. Using an <code>IndexReader</code></a></li>
<li><a href="#_accessing_a_lucene_directory">10.4. Accessing a Lucene Directory</a></li>
<li><a href="#advanced-features-sharding">10.5. Sharding indexes</a></li>
<li><a href="#section-sharing-indexes">10.6. Sharing indexes</a></li>
<li><a href="#section-services">10.7. Using external services</a></li>
<li><a href="#_customizing_lucene_s_scoring_formula">10.8. Customizing Lucene&#8217;s scoring formula</a></li>
<li><a href="#section-multi-tenancy">10.9. Multi-tenancy</a></li>
</ul>
</li>
<li><a href="#elasticsearch-integration">11. Integration with Elasticsearch</a>
<ul class="sectlevel2">
<li><a href="#_status">11.1. Status</a></li>
<li><a href="#_goal_of_the_elasticsearch_integration">11.2. Goal of the Elasticsearch integration</a></li>
<li><a href="#_getting_started_and_configuration">11.3. Getting started and configuration</a></li>
<li><a href="#_mapping_and_indexing">11.4. Mapping and indexing</a></li>
<li><a href="#_queries">11.5. Queries</a></li>
<li><a href="#_index_optimization">11.6. Index optimization</a></li>
<li><a href="#elasticsearch-limitations">11.7. Limitations</a></li>
<li><a href="#_specific_versions_of_elasticsearch_to_avoid">11.8. Specific versions of Elasticsearch to avoid</a></li>
<li><a href="#_acknowledgment">11.9. Acknowledgment</a></li>
</ul>
</li>
<li><a href="#_further_reading">12. Further reading</a></li>
<li><a href="#credits">13. Credits</a></li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="preface"><a class="anchor" href="#preface"></a>Preface</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Full text search engines like Apache Lucene are very powerful technologies to add efficient free
text search capabilities to applications. However, Lucene suffers several mismatches when dealing
with object domain models. Amongst other things indexes have to be kept up to date and mismatches
between index structure and domain model as well as query mismatches have to be avoided.</p>
</div>
<div class="paragraph">
<p>Hibernate Search addresses these shortcomings - it indexes your domain model with the help of a few
annotations, takes care of database/index synchronization and brings back regular managed objects
from free text queries. To achieve this Hibernate Search is combining the power of
<a href="http://www.hibernate.org">Hibernate</a> and <a href="http://lucene.apache.org">Apache Lucene</a>.</p>
</div>
<div class="paragraph">
<p>Since version <code>5.6</code> Hibernate Search sports an experimental integration with <a href="https://www.elastic.co/products/elasticsearch">Elasticsearch</a>.
Elasticsearch is built on Apache Lucene so we can now expose very similar features, making most
of this reference documentation a valid guide to both approaches.
For details specific to Elasticsearch, jump to <a href="#elasticsearch-integration">Integration with Elasticsearch</a>.
The other sections of this guide will assume you&#8217;re using Lucene without the Elasticsearch indirection.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="getting-started"><a class="anchor" href="#getting-started"></a>1. Getting started</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Welcome to Hibernate Search. The following chapter will guide you through the initial steps required
to integrate Hibernate Search into an existing Hibernate ORM enabled application. In case you are a
Hibernate new timer we recommend you start <a href="http://hibernate.org/quick-start.html">here</a>.</p>
</div>
<div class="sect2">
<h3 id="_system_requirements"><a class="anchor" href="#_system_requirements"></a>1.1. System Requirements</h3>
<table class="tableblock frame-all grid-all spread">
<caption class="title">Table 1. System requirements</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Java Runtime</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Requires Java version <em>8</em> or greater. You
            can download a Java Runtime for Windows/Linux/Solaris <a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">here</a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Hibernate Search</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hibernate-search-5.8.0.Final.jar</code> and all
            runtime dependencies. You can get the jar artifacts either from
            the <code>dist/lib</code> directory of the <a href="http://sourceforge.net/projects/hibernate/files/hibernate-search/">Hibernate Search distribution</a> or you can download them from the
            Maven Central repository.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Hibernate ORM</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">You will need
            <code>hibernate-core-5.2.11.Final.jar</code> and its
            dependencies (either from the <a href="http://sourceforge.net/projects/hibernate/files/hibernate-orm/">distribution bundle</a> or the maven repository).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">JPA 2.1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Hibernate Search can be used without JPA but the following instructions will use JPA annotations for basic
            entity configuration (<code>@Entity</code>, <code>@Id</code>, <code>@OneToMany</code>,&#8230;&#8203;).</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_migration_notes"><a class="anchor" href="#_migration_notes"></a>1.2. Migration notes</h3>
<div class="paragraph">
<p>If you are upgrading an existing application from an earlier version of Hibernate Search to the latest release,
make sure to check the out the <a href="http://hibernate.org/search/documentation/migrate/">migration guide</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_required_libraries"><a class="anchor" href="#_required_libraries"></a>1.3. Required libraries</h3>
<div class="paragraph">
<p>The Hibernate Search library is split in several modules to allow you to pick the minimal set of
dependencies you need.
It requires Apache Lucene, Hibernate ORM and some standard APIs such as the Java Persistence API
and the Java Transactions API. Other dependencies are optional, providing additional integration
points.
To get the correct jar files on your classpath we highly recommend to use a dependency manager such
as <a href="http://maven.apache.org/">Maven</a>, or similar tools such as <a href="http://www.gradle.org/">Gradle</a> or
<a href="http://ant.apache.org/ivy/">Ivy</a>.
These alternatives are also able to consume the artifacts from the <a href="#search-download-via-maven">Using Maven</a> section.</p>
</div>
<div class="sect3">
<h4 id="search-download-via-maven"><a class="anchor" href="#search-download-via-maven"></a>1.3.1. Using Maven</h4>
<div class="paragraph">
<p>The Hibernate Search artifacts can be found in Maven&#8217;s <a href="http://central.sonatype.org/">Central Repository</a>
but are released first in the <a href="http://repository.jboss.org/nexus/content/groups/public-jboss/">JBoss Maven Repository</a>.
See also the <a href="https://community.jboss.org/wiki/MavenGettingStarted-Users">Maven Getting Started wiki page</a> to use
the JBoss repository.</p>
</div>
<div class="paragraph">
<p>All you have to add to your pom.xml is:</p>
</div>
<div class="exampleblock">
<div class="title">Example 1. Maven artifact identifier for Hibernate Search</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-XML" data-lang="XML">&lt;dependency&gt;
   &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
   &lt;artifactId&gt;hibernate-search-orm&lt;/artifactId&gt;
   &lt;version&gt;5.8.0.Final&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 2. Optional Maven dependencies for Hibernate Search</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-XML" data-lang="XML">&lt;!-- Infinispan integration: --&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.infinispan&lt;/groupId&gt;
   &lt;artifactId&gt;infinispan-directory-provider&lt;/artifactId&gt;
   &lt;version&gt;9.0.1.Final&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Only the <em>hibernate-search-orm</em> dependency is mandatory. <em>infinispan-directory-provider</em> is only required
if you want to use Infinispan to store the Lucene indexes.</p>
</div>
</div>
<div class="sect3">
<h4 id="_manual_library_management"><a class="anchor" href="#_manual_library_management"></a>1.3.2. Manual library management</h4>
<div class="paragraph">
<p>You can download zip bundles from Sourceforge containing all needed
<a href="http://sourceforge.net/projects/hibernate/files/hibernate-search/5.8.0.Final/">Hibernate Search</a>
dependencies. This includes - among others - the latest compatible version of Hibernate ORM. However,
only the essential parts you need to start experimenting with are included. You will probably need
to combine this with downloads from the other projects, for example the
<a href="http://sourceforge.net/projects/hibernate/files/hibernate-orm/5.2.11.Final/">Hibernate ORM distribution on Sourceforge</a>
also provides the modules to enable caching or use a connection pool.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_deploying_on_wildfly"><a class="anchor" href="#_deploying_on_wildfly"></a>1.4. Deploying on WildFly</h3>
<div class="paragraph">
<p>If you are creating an application to be deployed on WildFly you&#8217;re lucky:
Hibernate Search is included in the application server.
This means that you don&#8217;t need to package it along with your application, unless you want to use a different version
than the one included.
Since WildFly version 10 the embedded version of Hibernate Search is automatically activated when your application uses it. See <a href="#search-configuration-deploy-on-wildfly">Hibernate Search as a WildFly module</a> for details.</p>
</div>
<div class="paragraph">
<p>Since this version of Hibernate Search requires Hibernate ORM version <code>5.2.3+</code> - which is more recent than the Hibernate ORM
version included in WildFly - you will also need to follow the instructions in the <a href="http://docs.jboss.org/hibernate/orm/5.2/topical/html_single/wildfly/Wildfly.html">Hibernate ORM WildFly upgrade guide</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_configuration"><a class="anchor" href="#_configuration"></a>1.5. Configuration</h3>
<div class="paragraph">
<p>Once you have added all required dependencies to your application you have to add a couple of
properties to your Hibernate configuration file.
If you are using Hibernate directly this can be done in <code>hibernate.properties</code> or <code>hibernate.cfg.xml</code>.
If you are using Hibernate via JPA you can also add the properties to <code>persistence.xml</code>.
The good news is that for standard use most properties offer a sensible default.
An example <code>persistence.xml</code> configuration could look like this:</p>
</div>
<div class="exampleblock">
<div class="title">Example 3. Basic configuration options to be added to <code>hibernate.properties</code>, <code>hibernate.cfg.xml</code> or <code>persistence.xml</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-XML" data-lang="XML">...
&lt;property name="hibernate.search.default.directory_provider"
          value="filesystem"/&gt;

&lt;property name="hibernate.search.default.indexBase"
          value="/var/lucene/indexes"/&gt;
...</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>First you have to tell Hibernate Search which <code>DirectoryProvider</code> to use. This can be achieved by
setting the <code>hibernate.search.default.directory_provider</code> property. Apache Lucene has the notion
of a <code>Directory</code> to store the index files. Hibernate Search handles the initialization and
configuration of a Lucene <code>Directory</code> instance via a <code>DirectoryProvider</code>. In this tutorial we will
use a a directory provider which stores the index on the file system. This will give us the ability to
inspect the Lucene indexes created by Hibernate Search (eg via
<a href="https://github.com/DmitryKey/luke/">Luke</a>). Once you have a working configuration you can start
experimenting with other directory providers (see <a href="#search-configuration-directory">Directory configuration</a>).
You also have to specify the default base directory for all indexes via
<code>hibernate.search.default.indexBase</code>. This defines the path where indexes are stored.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s assume that your application contains the Hibernate managed classes <code>example.Book</code> and
<code>example.Author</code> and you want to add free text search capabilities to your application in order to
search the books contained in your database.</p>
</div>
<div class="exampleblock">
<div class="title">Example 4. Example entities Book and Author before adding Hibernate Search specific annotations</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">package example;
...
@Entity
public class Book {

  @Id
  @GeneratedValue
  private Integer id;

  private String title;

  private String subtitle;

  @ManyToMany
  private Set&lt;Author&gt; authors = new HashSet&lt;Author&gt;();

  private Date publicationDate;

  public Book() {}

  // standard getters/setters follow
  ...
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">package example;
...
@Entity
public class Author {

  @Id
  @GeneratedValue
  private Integer id;

  private String name;

  public Author() {}

  // standard getters/setters follow
  ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>To achieve this you have to add a few annotations to the <code>Book</code> and <code>Author</code> class. The first annotation
<code>@Indexed</code> marks <code>Book</code> as indexable. By design Hibernate Search needs to store an <em>untokenized</em> id in
the index to ensure index uniqueness for a given entity (for now don&#8217;t worry if you don&#8217;t know what
<em>untokenized</em> means, it will soon be clear).</p>
</div>
<div class="paragraph">
<p>Next you have to mark the fields you want to make searchable. Let&#8217;s start with <code>title</code> and
<code>subtitle</code> and annotate both with <code>@Field</code>. The parameter <code>index=Index.YES</code> will ensure that the
text will be indexed, while <code>analyze=Analyze.YES</code> ensures that the text will be analyzed using the
default Lucene analyzer. Usually, analyzing or tokenizing means chunking a sentence into individual
words and potentially excluding common words like "a" or "the". We will talk more about analyzers a
little later on.
The third parameter we specify is <code>store=Store.NO</code>, which ensures that the actual data
will not be stored in the index.
Whether data is stored in the index or not has nothing to do with the ability to search for it.
It is not necessary to store fields in the index to allow Lucene to search for them: the benefit of
storing them is the ability to retrieve them via projections (see <a href="#projections">Projection</a>).</p>
</div>
<div class="paragraph">
<p>Without projections, Hibernate Search will per default execute a Lucene query in order to find the
database identifiers of the entities matching the query criteria and use these identifiers to
retrieve managed objects from the database. The decision for or against projection has to be made on
a case by case basis.</p>
</div>
<div class="paragraph">
<p>Note that <code>index=Index.YES</code>, <code>analyze=Analyze.YES</code> and <code>store=Store.NO</code> are the default values for
these parameters and could be omitted.</p>
</div>
<div class="paragraph">
<p>After this short look under the hood let&#8217;s go back to annotating the <code>Book</code> class. Another annotation
we have not yet discussed is <code>@DateBridge</code>. This annotation is one of the built-in field bridges in
Hibernate Search. The Lucene index is mostly string based, with special support for encoding numbers.
Hibernate Search must convert the data types of the indexed fields to their respective Lucene
encoding and vice versa. A range of predefined bridges is provided for this purpose, including the
<code>DateBridge</code> which will convert a <code>java.util.Date</code> into a numeric value (a <code>long</code>) with the
specified resolution. For more details see <a href="#section-built-in-bridges">Built-in bridges</a>.</p>
</div>
<div class="paragraph">
<p>This leaves us with <code>@IndexedEmbedded</code>. This annotation is used to index associated entities
(<code>@ManyToMany</code>, <code>@*ToOne</code>, <code>@Embedded</code> and <code>@ElementCollection</code>) as part of the owning entity.
This is needed since a Lucene index document is a flat data structure which does not know anything
about object relations.
To ensure that the author names will be searchable you have to make sure that the names are indexed
as part of the book itself. On top of <code>@IndexedEmbedded</code> you will also have to mark the fields of
the associated entity you want to have included in the index with <code>@Field</code>.
For more details see <a href="#search-mapping-associated">Embedded and associated objects</a>.</p>
</div>
<div class="paragraph">
<p>These settings should be sufficient for now. For more details on entity mapping refer to
<a href="#search-mapping-entity">Mapping an entity</a>.</p>
</div>
<div class="exampleblock">
<div class="title">Example 5. Example entities after adding Hibernate Search annotations</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">package example;
...
@Entity
@Indexed
public class Book {

  @Id
  @GeneratedValue
  private Integer id;

  @Field(index=Index.YES, analyze=Analyze.YES, store=Store.NO)
  private String title;

  @Field(index=Index.YES, analyze=Analyze.YES, store=Store.NO)
  private String subtitle;

  @Field(index = Index.YES, analyze=Analyze.NO, store = Store.YES)
  @DateBridge(resolution = Resolution.DAY)
  private Date publicationDate;

  @IndexedEmbedded
  @ManyToMany
  private Set&lt;Author&gt; authors = new HashSet&lt;Author&gt;();
  public Book() {
  }

  // standard getters/setters follow here
  ...
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
public class Author {

  @Id
  @GeneratedValue
  private Integer id;

  @Field
  private String name;

  public Author() {
  }

  // standard getters/setters follow here
  ...
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_indexing"><a class="anchor" href="#_indexing"></a>1.6. Indexing</h3>
<div class="paragraph">
<p>Hibernate Search will transparently index every entity persisted, updated or removed through
Hibernate ORM. However, you have to create an initial Lucene index for the data already present in
your database. Once you have added the above properties and annotations it is time to trigger an
initial batch index of your books. You can achieve this by using one of the following code snippets
(see also <a href="#search-batchindex">Rebuilding the whole index</a>):</p>
</div>
<div class="exampleblock">
<div class="title">Example 6. Using Hibernate Session to index data</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">FullTextSession fullTextSession = Search.getFullTextSession(session);
fullTextSession.createIndexer().startAndWait();</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 7. Using JPA to index data</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">EntityManager em = entityManagerFactory.createEntityManager();
FullTextEntityManager fullTextEntityManager = Search.getFullTextEntityManager(em);
fullTextEntityManager.createIndexer().startAndWait();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>After executing the above code, you should be able to see a Lucene index under <code>/var/lucene/indexes/example.Book</code>
(or based on a different path depending how you configured the property <code>hibernate.search.default.directory_provider</code>).</p>
</div>
<div class="paragraph">
<p>Go ahead an inspect this index with <a href="https://github.com/DmitryKey/luke/">Luke</a>:
it will help you to understand how Hibernate Search works.</p>
</div>
</div>
<div class="sect2">
<h3 id="_searching"><a class="anchor" href="#_searching"></a>1.7. Searching</h3>
<div class="paragraph">
<p>Now it is time to execute a first search. The general approach is to create a Lucene query, either
via the Lucene API (<a href="#search-query-lucene-api">Building a Lucene query using the Lucene API</a>) or via the Hibernate Search query DSL
(<a href="#search-query-querydsl">Building a Lucene query with the Hibernate Search query DSL</a>), and then wrap this query into a <code>org.hibernate.Query</code> in order to get all the
functionality one is used to from the Hibernate API. The following code will prepare a query against
the indexed fields, execute it and return a list of <code>Book</code> instances.</p>
</div>
<div class="exampleblock">
<div class="title">Example 8. Using Hibernate Session to create and execute a search</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">FullTextSession fullTextSession = Search.getFullTextSession(session);
Transaction tx = fullTextSession.beginTransaction();

// create native Lucene query using the query DSL
// alternatively you can write the Lucene query using the Lucene query parser
// or the Lucene programmatic API. The Hibernate Search DSL is recommended though
QueryBuilder qb = fullTextSession.getSearchFactory()
  .buildQueryBuilder().forEntity(Book.class).get();
org.apache.lucene.search.Query query = qb
  .keyword()
  .onFields("title", "subtitle", "authors.name")
  .matching("Java rocks!")
  .createQuery();

// wrap Lucene query in a org.hibernate.Query
org.hibernate.Query hibQuery =
    fullTextSession.createFullTextQuery(query, Book.class);

// execute search
List result = hibQuery.list();

tx.commit();
session.close();</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 9. Using JPA to create and execute a search</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">EntityManager em = entityManagerFactory.createEntityManager();
FullTextEntityManager fullTextEntityManager =
    org.hibernate.search.jpa.Search.getFullTextEntityManager(em);
em.getTransaction().begin();

// create native Lucene query using the query DSL
// alternatively you can write the Lucene query using the Lucene query parser
// or the Lucene programmatic API. The Hibernate Search DSL is recommended though
QueryBuilder qb = fullTextEntityManager.getSearchFactory()
    .buildQueryBuilder().forEntity(Book.class).get();
org.apache.lucene.search.Query query = qb
  .keyword()
  .onFields("title", "subtitle", "authors.name")
  .matching("Java rocks!")
  .createQuery();

// wrap Lucene query in a javax.persistence.Query
javax.persistence.Query persistenceQuery =
    fullTextEntityManager.createFullTextQuery(query, Book.class);

// execute search
List result = persistenceQuery.getResultList();

em.getTransaction().commit();
em.close();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_analyzer"><a class="anchor" href="#_analyzer"></a>1.8. Analyzer</h3>
<div class="paragraph">
<p>Let&#8217;s make things a little more interesting now. Assume that one of your indexed book entities has
the title "Refactoring: Improving the Design of Existing Code" and you want to get hits for all of
the following queries: "refactor", "refactors", "refactored" and "refactoring". In Lucene this can
be achieved by choosing an analyzer class which applies word stemming during the indexing <strong>as well
as</strong> the search process. Hibernate Search offers several ways to configure the analyzer to be used
(see <a href="#analyzer">Default analyzer and analyzer by class</a>):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Setting the <code>hibernate.search.analyzer</code> property in the configuration file.
The specified class will then be the default analyzer.</p>
</li>
<li>
<p>Setting the <code>@Analyzer</code> annotation at the entity level.</p>
</li>
<li>
<p>Setting the <code>@Analyzer</code> annotation at the field level.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When using the <code>@Analyzer</code> annotation one can either specify the fully qualified classname of the
analyzer to use or one can refer to an analyzer definition defined by the <code>@AnalyzerDef</code> annotation.
In the latter case the analyzer framework with its factories approach is utilized.</p>
</div>
<div class="paragraph">
<p>To find out more about the factory classes available
you can either browse the Lucene JavaDoc or read the corresponding section on the
<a href="http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters">Solr Wiki</a>.</p>
</div>
<div class="paragraph">
<p>You can use <code>@AnalyzerDef</code> on any:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>@Indexed</code> entity regardless of where the analyzer is applied to;</p>
</li>
<li>
<p>parent class of an <code>@Indexed</code> entity;</p>
</li>
<li>
<p>package-info.java of a package containing an <code>@Indexed</code> entity.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This implies that analyzer definitions are global and their names must be unique.
The <code>@AnalyzerDef</code> is a repeatable annotation, so you can declare multiple analyzer
definitions on each of these types.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Why the reference to the Apache Solr wiki?</p>
</div>
<div class="paragraph">
<p>The analyzer factory framework was originally created in the Apache Solr project.
Most of these implementations have been moved to Apache Lucene, but the
documentation for these additional analyzers can still be found in the Solr Wiki. You might find
other documentation referring to the "Solr Analyzer Framework"; just remember you don&#8217;t need to
depend on Apache Solr anymore: the required classes are part of the core Lucene distribution.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In the example below a <code>StandardTokenizerFactory</code> is used followed by two filter factories,
<code>LowerCaseFilterFactory</code> and <code>SnowballPorterFilterFactory</code>. The standard tokenizer splits words at
punctuation characters and hyphens.
It is a good general purpose tokenizer.
For indexing email addresses or internet hostnames it is not the best fit as it would split them up.
You may either make use of Lucene&#8217;s <code>ClassicTokenizerFactory</code> in such cases or implement a custom tokenizer and factory.
The lowercase filter converts to lowercase the letters in each token
whereas the snowball filter finally applies language specific stemming.</p>
</div>
<div class="paragraph">
<p>Generally, when using the Analyzer Framework you have to start with a tokenizer followed by an
arbitrary number of filters.</p>
</div>
<div class="exampleblock">
<div class="title">Example 10. Using <code>@AnalyzerDef</code> and the Analyzer Framework to define and use an analyzer</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed
@AnalyzerDef(name = "customanalyzer",
  tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
  filters = {
    @TokenFilterDef(factory = LowerCaseFilterFactory.class),
    @TokenFilterDef(factory = SnowballPorterFilterFactory.class, params = {
      @Parameter(name = "language", value = "English")
    })
  })
public class Book {

  @Id
  @GeneratedValue
  @DocumentId
  private Integer id;

  @Field
  @Analyzer(definition = "customanalyzer")
  private String title;

  @Field
  @Analyzer(definition = "customanalyzer")
  private String subtitle;

  @IndexedEmbedded
  @ManyToMany
  private Set&lt;Author&gt; authors = new HashSet&lt;Author&gt;();

  @Field(index = Index.YES, analyze = Analyze.NO, store = Store.YES)
  @DateBridge(resolution = Resolution.DAY)
  private Date publicationDate;

  public Book() {
  }

  // standard getters/setters follow here
  ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Using <code>@AnalyzerDef</code> only defines an Analyzer, you still have to apply it to entities and or
properties using <code>@Analyzer</code>. Like in the above example the <code>customanalyzer</code> is defined but not
applied on the entity: it&#8217;s applied on the <code>title</code> and <code>subtitle</code> properties only. An analyzer
definition is global, so you can define it on any entity and reuse the definition on other entities.</p>
</div>
</div>
<div class="sect2">
<h3 id="_what_s_next"><a class="anchor" href="#_what_s_next"></a>1.9. What&#8217;s next</h3>
<div class="paragraph">
<p>The above paragraphs helped you getting an overview of Hibernate Search. The next step after this
tutorial is to get more familiar with the overall architecture of Hibernate Search
(<a href="#search-architecture">Architecture</a>) and explore the basic features in more detail. Two topics which were only briefly
touched in this tutorial were analyzer configuration (<a href="#analyzer">Default analyzer and analyzer by class</a>) and field bridges
(<a href="#search-mapping-bridge">Bridges</a>). Both are important features required for more fine-grained indexing. More
advanced topics cover clustering (<a href="#jms-backend">JMS Master/Slave back end</a>, <a href="#infinispan-directories">Infinispan Directory configuration</a>) and large index
handling (<a href="#advanced-features-sharding">Sharding indexes</a>).</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="search-architecture"><a class="anchor" href="#search-architecture"></a>2. Architecture</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_overview"><a class="anchor" href="#_overview"></a>2.1. Overview</h3>
<div class="paragraph">
<p>Hibernate Search consists of an indexing component as well as an index search component. Both are
backed by Apache Lucene.</p>
</div>
<div class="paragraph">
<p>Each time an entity is inserted, updated or removed in/from the database, Hibernate Search keeps
track of this event (through the Hibernate event system) and schedules an index update. All these
updates are handled without you having to interact with the Apache Lucene APIs directly (see
<a href="#search-configuration-event">Enabling Hibernate Search and automatic indexing</a>). Instead, the interaction with the underlying Lucene indexes is
handled via so called IndexManagers.</p>
</div>
<div class="paragraph">
<p>Each Lucene index is managed by one index manager which is uniquely identified by name. In most
cases there is also a one to one relationship between an indexed entity and a single IndexManager.
The exceptions are the use cases of index sharding and index sharing. The former can be applied when
the index for a single entity becomes too big and indexing operations are slowing down the
application. In this case a single entity is indexed into multiple indexes each with its own index
manager (see <a href="#advanced-features-sharding">Sharding indexes</a>). The latter, index sharing, is the ability to index
multiple entities into the same Lucene index (see <a href="#section-sharing-indexes">Sharing indexes</a>).</p>
</div>
<div class="paragraph">
<p>The index manager abstracts from the specific index configuration. In the case of the default index
manager this includes details about the selected backend, the configured reader strategy and the
chosen DirectoryProvider. These components will be discussed in greater detail later on. It is
recommended that you start with the default index manager which uses different Lucene Directory
types to manage the indexes (see <a href="#search-configuration-directory">Directory configuration</a>). You can, however, also provide
your own IndexManager implementation (see <a href="#configuration-indexmanager">Configuring the IndexManager</a>).</p>
</div>
<div class="paragraph">
<p>Once the index is created, you can search for entities and return lists of managed entities saving
you the tedious object to Lucene Document mapping. The same persistence context is shared between
Hibernate and Hibernate Search. As a matter of fact, the <code>FullTextSession</code> is built on top of the
Hibernate Session so that the application code can use the unified org.hibernate.Query or
javax.persistence.Query APIs exactly the same way a HQL, JPA-QL or native query would do.</p>
</div>
<div class="paragraph">
<p>To be more efficient Hibernate Search batches the write interactions with the Lucene index. This
batching is the responsibility of the Worker. There are currently two types of batching. Outside a
transaction, the index update operation is executed right after the actual database operation. This
is really a no batching setup. In the case of an ongoing transaction, the index update operation is
scheduled for the transaction commit phase and discarded in case of transaction rollback. The
batching scope is the transaction. There are two immediate benefits:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Performance: Lucene indexing works better when operation are executed in batch.</p>
</li>
<li>
<p>ACIDity: The work executed has the same scoping as the one executed by the database transaction and
is executed if and only if the transaction is committed. This is not ACID in the strict sense of it,
but ACID behavior is rarely useful for full text search indexes since they can be rebuilt from the
source at any time.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can think of those two batch modes (no scope vs transactional) as the equivalent of the
(infamous) autocommit vs transactional behavior. From a performance perspective, the <em>in
transaction</em> mode is recommended. The scoping choice is made transparently. Hibernate Search detects
the presence of a transaction and adjust the scoping (see <a href="#configuration-worker">Worker configuration</a>).</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>It is recommended - for both your database and Hibernate Search - to execute your operations in a transaction, be it JDBC or JTA.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Hibernate Search works perfectly fine in the Hibernate / EntityManager long conversation
pattern aka. atomic conversation.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_backend"><a class="anchor" href="#_backend"></a>2.2. Backend</h3>
<div class="paragraph">
<p>Hibernate Search offers the ability to let the batched work be processed by different backends.
Several backends are provided out of the box and you have the option to plug in your own. It is
important to understand that in this context backend encompasses more than just the configuration
option <code>hibernate.search.default.worker.backend</code>. This property just specifies an implementation of
the <code>BackendQueueProcessor</code> interface (or the <code>Backend</code> interface, see <a href="#table-backend-configuration">the configuration options</a>)
which is a part of a backend configuration. In most cases,
however, additional configuration settings are needed to successfully configure a specific backend
setup, like for example the JMS backend.</p>
</div>
<div class="sect3">
<h4 id="_lucene"><a class="anchor" href="#_lucene"></a>2.2.1. Lucene</h4>
<div class="paragraph">
<p>In this mode, all index update operations applied on a given node (JVM) will be executed to the
Lucene directories (through the directory providers) by the same node. This mode is typically used
in non clustered environment or in clustered environments where the directory store is shared.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/lucene-backend.png" alt="Lucene backend configuration">
</div>
</div>
<div class="paragraph">
<p>This mode targets non clustered applications, or clustered applications where the Directory is
taking care of the locking strategy.</p>
</div>
<div class="paragraph">
<p>The main advantage is simplicity and immediate visibility of the changes in Lucene queries (a
requirement in some applications).</p>
</div>
<div class="paragraph">
<p>An alternative backend viable for non-clustered and non-shared index configurations is the near-
real-time backend.</p>
</div>
</div>
<div class="sect3">
<h4 id="search-architecture-jms"><a class="anchor" href="#search-architecture-jms"></a>2.2.2. JMS</h4>
<div class="paragraph">
<p>All index update operations applied on a given node are sent to a JMS queue. A unique reader will
then process the queue and update the master index. The master index is then replicated on a regular
basis to the slave copies. This is known as the master/slaves pattern. The master is the sole
responsible for updating the Lucene index. The slaves can accept read as well as write operations.
However, while they process the read operations on their local index copy, they will delegate the
update operations to the master.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/jms-backend.png" alt="JMS backend configuration">
</div>
</div>
<div class="paragraph">
<p>This mode targets clustered environments where throughput is critical, and index update delays are
affordable. Reliability is ensured by the JMS provider and by having the slaves working on a local
copy of the index.</p>
</div>
<div class="paragraph">
<p>The JMS integration can be transactional. With this backend (and currently only this backend) you
can have Hibernate Search send the indexing work into the queue within the same transaction
applying changes to the relational database. This option requires you to use an XA transaction.</p>
</div>
<div class="paragraph">
<p>By default this backend&#8217;s transactional capabilities are disabled: messages will be
enqueued as a post-transaction event, consistently with other backends.
To change this configuration see also <a href="#configuration-worker">Worker configuration</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_jgroups"><a class="anchor" href="#_jgroups"></a>2.2.3. JGroups</h4>
<div class="paragraph">
<p>The JGroups based backend works similar to the JMS one and is designed after the same master/slaves
pattern. However, instead of JMS, the JGroups toolkit is used as a replication mechanism. This backend
can be used as an alternative to JMS when response time is critical, but i.e. JNDI service is
not available.</p>
</div>
<div class="paragraph">
<p>Note that while JMS can usually be configured to use persistent queues, JGroups talks directly to
other nodes over network. Message delivery to other reachable nodes is guaranteed, but if no master
node is available, index operations are silently discarded. This backend can be configured to use
asynchronous messages, or to wait for each indexing operation to be completed on the remote node
before returning.</p>
</div>
<div class="paragraph">
<p>The JGroups backend can be configured with static master or slave roles, or can be setup to perform
an auto-election of the master. This mode is particularly useful to have the system automatically
pick a new master in case of failure, but during a reelection process some indexing operations might
be lost. For this reason this mode is not suited for use cases requiring strong consistency
guarantees. When configured to perform an automatic election, the master node is defined as an hash
on the index name: the role is therefore possibly different for each index or shard.</p>
</div>
</div>
<div class="sect3">
<h4 id="_elasticsearch"><a class="anchor" href="#_elasticsearch"></a>2.2.4. Elasticsearch</h4>
<div class="paragraph">
<p>In this mode, the index is not on the application server, but in an Elasticsearch cluster.
Update operations are sent to the cluster and executed remotely,
and so are search queries.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/elasticsearch-backend.png" alt="Elasticsearch backend configuration">
</div>
</div>
<div class="paragraph">
<p>This mode allows to easily set up a clustered application,
without the advanced configuration required by the JMS and JGroups modes.</p>
</div>
<div class="paragraph">
<p>More information can be found in the <a href="#elasticsearch-integration">Elasticsearch integration section</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="search-architecture-readerstrategy"><a class="anchor" href="#search-architecture-readerstrategy"></a>2.3. Reader strategy</h3>
<div class="paragraph">
<p>When executing a query, Hibernate Search interacts with the Apache Lucene indexes through a reader
strategy. Choosing a reader strategy will depend on the profile of the application (frequent
updates, read mostly, asynchronous index update etc). See also <a href="#configuration-reader-strategy">Reader strategy configuration</a></p>
</div>
<div class="sect3">
<h4 id="_shared"><a class="anchor" href="#_shared"></a>2.3.1. shared</h4>
<div class="paragraph">
<p>With this strategy, Hibernate Search will share the same IndexReader, for a given Lucene index,
across multiple queries and threads provided that the IndexReader is still up-to-date. If the
IndexReader is not up-to-date, a new one is opened and provided. Each IndexReader is made of several
SegmentReaders. This strategy only reopens segments that have been modified or created after last
opening and shares the already loaded segments from the previous instance.
This approach is quite efficient and guarantees that each query is run on the most recent index snapshot; the drawback is that for every query the strategy will have to verify if the IndexReader is still fresh, and if not perform a refresh; such a refresh is typically a cheap operation but if you have a significant amount of writes and queries happening concurrently then one of the other strategies might be preferred.
This strategy is the default.</p>
</div>
<div class="paragraph">
<p>The name of this strategy is <code>shared</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_not_shared"><a class="anchor" href="#_not_shared"></a>2.3.2. not-shared</h4>
<div class="paragraph">
<p>Every time a query is executed, a Lucene IndexReader is opened. This strategy is not efficient since opening and warming up an IndexReader can be a relatively expensive operation, but is very simple code.
Use it as an example implementation if you&#8217;re interested to learn about
Hibernate Search internals or want to extend it.</p>
</div>
<div class="paragraph">
<p>The name of this strategy is <code>not-shared</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_async"><a class="anchor" href="#_async"></a>2.3.3. async</h4>
<div class="paragraph">
<p>This implementation keeps an IndexReader open and ready to be used by all
queries, while a background thread periodically verifies if there is need
to open a fresh one, replaces the active one and disposes the outdated one.
The frequency of checks - and refreshing - of this background thread is configurable, but defaults to 5000 milliseconds.
The drawback of this design is that queries are effectively run on an
index snapshot which might be approximately 5 seconds out of date (assuming the refresh period is not reconfigured);
the benefit is that if your application writes frequently to the index,
the query performance will be more consistent.</p>
</div>
<div class="paragraph">
<p>The name of this strategy is <code>async</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_custom"><a class="anchor" href="#_custom"></a>2.3.4. Custom</h4>
<div class="paragraph">
<p>You can write your own reader strategy that suits your application needs by implementing
org.hibernate.search.reader.ReaderProvider. The implementation must be thread safe.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="search-configuration"><a class="anchor" href="#search-configuration"></a>3. Configuration</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="search-configuration-event"><a class="anchor" href="#search-configuration-event"></a>3.1. Enabling Hibernate Search and automatic indexing</h3>
<div class="paragraph">
<p>Let&#8217;s start with the most basic configuration question - how do I enable Hibernate Search?</p>
</div>
<div class="sect3">
<h4 id="_enabling_hibernate_search"><a class="anchor" href="#_enabling_hibernate_search"></a>3.1.1. Enabling Hibernate Search</h4>
<div class="paragraph">
<p>The good news is that Hibernate Search is enabled out of the box when detected on the classpath by
Hibernate ORM. If, for some reason you need to disable it, set
<code>hibernate.search.autoregister_listeners</code> to false. Note that there is no performance penalty
when the listeners are enabled but no entities are annotated as indexed.</p>
</div>
</div>
<div class="sect3">
<h4 id="_automatic_indexing"><a class="anchor" href="#_automatic_indexing"></a>3.1.2. Automatic indexing</h4>
<div class="paragraph">
<p>By default, every time an object is inserted, updated or deleted through Hibernate, Hibernate Search
updates the according Lucene index. It is sometimes desirable to disable that features if either
your index is read-only or if index updates are done in a batch way (see <a href="#search-batchindex">Rebuilding the whole index</a>).</p>
</div>
<div class="paragraph">
<p>To disable event based indexing, set</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>hibernate.search.indexing_strategy = manual</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>In most case, the JMS backend provides the best of both world, a lightweight event based system
keeps track of all changes in the system, and the heavyweight indexing process is done by a separate
process or machine.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="configuration-indexmanager"><a class="anchor" href="#configuration-indexmanager"></a>3.2. Configuring the IndexManager</h3>
<div class="paragraph">
<p>The role of the index manager component is described in <a href="#search-architecture">Architecture</a>. Hibernate Search
provides two possible implementations for this interface to choose from.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>directory-based</code>: the default implementation which uses the Lucene Directory abstraction to
manage index files.</p>
</li>
<li>
<p><code>near-real-time</code>: avoid flushing writes to disk at each commit. This index manager is also
Directory based, but also makes uses of Lucene&#8217;s NRT functionality.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To select an alternative you specify the property:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>hibernate.search.[default|&lt;indexname&gt;].indexmanager = near-real-time</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_directory_based"><a class="anchor" href="#_directory_based"></a>3.2.1. directory-based</h4>
<div class="paragraph">
<p>The default IndexManager implementation. This is the one mostly referred to in this documentation.
It is highly configurable and allows you to select different settings for the reader strategy, back
ends and directory providers. Refer to <a href="#search-configuration-directory">Directory configuration</a>, <a href="#configuration-worker">Worker configuration</a>
and <a href="#configuration-reader-strategy">Reader strategy configuration</a> for more details.</p>
</div>
</div>
<div class="sect3">
<h4 id="_near_real_time"><a class="anchor" href="#_near_real_time"></a>3.2.2. near-real-time</h4>
<div class="paragraph">
<p>The NRTIndexManager is an extension of the default IndexManager, leveraging the Lucene NRT (Near
Real Time) features for extreme low latency index writes. As a trade-off it requires a non-clustered
and non-shared index. In other words, it will ignore configuration settings for alternative back
ends other than <code>lucene</code> and will acquire exclusive write locks on the Directory.</p>
</div>
<div class="paragraph">
<p>To achieve this low latency writes, the IndexWriter will not flush every change to disk. Queries
will be allowed to read updated state from the unflushed index writer buffers; the downside of this
strategy is that if the application crashes or the IndexWriter is otherwise killed you&#8217;ll have to
rebuild the indexes as some updates might be lost.</p>
</div>
<div class="paragraph">
<p>Because of these downsides, and because a master node in cluster can be configured for good
performance as well, the NRT configuration is only recommended for non clustered websites with a
limited amount of data.</p>
</div>
</div>
<div class="sect3">
<h4 id="_custom_2"><a class="anchor" href="#_custom_2"></a>3.2.3. Custom</h4>
<div class="paragraph">
<p>It is also possible to configure a custom IndexManager implementation by specifying the fully
qualified class name of your custom implementation. This implementation must have a no-argument
constructor:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>hibernate.search.[default|&lt;indexname&gt;].indexmanager = my.corp.myapp.CustomIndexManager</pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Your custom index manager implementation doesn&#8217;t need to use the same components as the default
implementations. For example, you can delegate to a remote indexing service which doesn&#8217;t expose a
Directory interface.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="search-configuration-directory"><a class="anchor" href="#search-configuration-directory"></a>3.3. Directory configuration</h3>
<div class="paragraph">
<p>As we have seen in <a href="#configuration-indexmanager">Configuring the IndexManager</a> the default index manager uses Lucene&#8217;s notion of
a Directory to store the index files. The Directory implementation can be customized and Lucene
comes bundled with a file system and an in-memory implementation. DirectoryProvider is the Hibernate
Search abstraction around a Lucene Directory and handles the configuration and the initialization of
the underlying Lucene resources. <a href="#directory-provider-table">List of built-in DirectoryProvider</a> shows the list of the directory
providers available in Hibernate Search together with their corresponding options.</p>
</div>
<div class="paragraph">
<p>To configure your DirectoryProvider you have to understand that each indexed entity is associated to
a Lucene index (except of the case where multiple entities share the same index -
<a href="#section-sharing-indexes">Sharing indexes</a>). The name of the index is given by the index property of the @Indexed
annotation. If the index property is not specified the fully qualified name of the indexed class
will be used as name (recommended).</p>
</div>
<div class="paragraph">
<p>Knowing the index name, you can configure the directory provider and any additional options by using
the prefix <code>hibernate.search.&lt;indexname&gt;</code>. The name default (<code>hibernate.search.default</code>) is
reserved and can be used to define properties which apply to all indexes.
<a href="#example-configuring-directory-providers">Configuring directory providers</a> shows how <code>hibernate.search.default.directory_provider</code>
is used to set the default directory provider to be the filesystem one. <code>hibernate.search.default.indexBase</code>
sets then the default base directory for the indexes. As a result the index for the entity Status is
created in <code>/usr/lucene/indexes/org.hibernate.example.Status</code>.</p>
</div>
<div class="paragraph">
<p>The index for the Rule entity, however, is using an in-memory directory, because the default
directory provider for this entity is overridden by the property
<code>hibernate.search.Rules.directory_provider</code>.</p>
</div>
<div class="paragraph">
<p>Finally the Action entity uses a custom directory provider <code>CustomDirectoryProvider</code> specified via
<code>hibernate.search.Actions.directory_provider</code>.</p>
</div>
<div class="exampleblock">
<div class="title">Example 11. Specifying the index name</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">package org.hibernate.example;

@Indexed
public class Status { ... }

@Indexed(index="Rules")
public class Rule { ... }

@Indexed(index="Actions")
public class Action { ... }</code></pre>
</div>
</div>
</div>
</div>
<div id="example-configuring-directory-providers" class="exampleblock">
<div class="title">Example 12. Configuring directory providers</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre>hibernate.search.default.directory_provider = filesystem
hibernate.search.default.indexBase = /usr/lucene/indexes
hibernate.search.Rules.directory_provider = local-heap
hibernate.search.Actions.directory_provider = com.acme.hibernate.CustomDirectoryProvider</pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Using the described configuration scheme you can easily define common rules like the directory
provider and base directory, and override those defaults later on on a per index basis.</p>
</div>
</td>
</tr>
</table>
</div>
<table id="directory-provider-table" class="tableblock frame-all grid-all spread">
<caption class="title">Table 2. List of built-in DirectoryProvider</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Name and description</th>
<th class="tableblock halign-left valign-top">Properties</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">local-heap: Directory using the local JVM heap.
</p><p class="tableblock"><strong>Local heap directories and all contained indexes are lost when the JVM shuts down.</strong>
</p><p class="tableblock">This option is only provided for use in <strong>testing configurations</strong> with <strong>small (trivial) indexes</strong> and <strong>low concurrency</strong>,
where it could slightly improve performance.
In setups requiring larger indexes and/or high concurrency,
a file system based directory (see below) will achieve better performance.
</p><p class="tableblock">The directory will be uniquely identified (in the same deployment unit) by the <code>@Indexed.index</code> element</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">none</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">filesystem: File system based directory.
</p><p class="tableblock">The directory used will be &lt;indexBase&gt;/&lt;indexName&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>indexBase</code> : base directory
<code>indexName</code>: override @Indexed.index (useful for sharded indexes)
<code>locking_strategy</code> : optional, see <a href="#search-configuration-directory-lockfactories">LockFactory configuration</a>
<code>filesystem_access_type</code>: allows to determine the exact type of FSDirectory implementation used
by this DirectoryProvider. Allowed values are <code>auto</code> (the default value, selects NIOFSDirectory on
non Windows systems, SimpleFSDirectory on Windows), <code>simple</code> (SimpleFSDirectory),
<code>nio</code> (NIOFSDirectory), <code>mmap</code> (MMapDirectory). Make sure to refer to Javadocs of these Directory
implementations before changing this setting. Even though NIOFSDirectory or MMapDirectory can bring
substantial performance boosts they also have their issues.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">filesystem-master: File system based directory.
</p><p class="tableblock">Like <code>filesystem</code>. It also copies the index to a source directory (aka copy directory) on a regular
basis.
</p><p class="tableblock">The recommended value for the refresh period is (at least) 50% higher that the time to copy the
information (default 3600 seconds - 60 minutes).
</p><p class="tableblock">Note that the copy is based on an incremental copy mechanism reducing the average copy time.
</p><p class="tableblock">DirectoryProvider typically used on the master node in a JMS back end cluster.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>indexBase</code>: base directory
<code>indexName</code>: override @Indexed.index (useful for sharded indexes)
<code>sourceBase</code>: source (copy) base directory.
<code>source</code>: source directory suffix (default to <code>@Indexed.index</code>). The actual source directory name
being <em>&lt;sourceBase&gt;/&lt;source&gt;</em>
<code>refresh</code>: refresh period in seconds (the copy will take place every refresh seconds). If a copy
is still in progress when the following refresh period elapses, the second copy operation will be
skipped.
<code>locking_strategy</code> : optional, see <a href="#search-configuration-directory-lockfactories">LockFactory configuration</a>
<code>filesystem_access_type</code>: allows to determine the exact type of FSDirectory implementation used by
this DirectoryProvider. Allowed values are <code>auto</code> (the default value, selects NIOFSDirectory on non
Windows systems, SimpleFSDirectory on Windows), <code>simple</code> (SimpleFSDirectory),
<code>nio</code> (NIOFSDirectory), <code>mmap</code> (MMapDirectory). Make sure to refer to Javadocs of these
Directory implementations before changing this setting. Even though NIOFSDirectory or MMapDirectory
can bring substantial performance boosts they also have their issues.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">filesystem-slave: File system based directory.
</p><p class="tableblock">Like <code>filesystem</code>, but retrieves a master version
(source) on a regular basis. To avoid locking and inconsistent search results, 2 local copies are kept.
</p><p class="tableblock">The recommended value for the refresh period is (at least) 50% higher that the time to copy the
information (default 3600 seconds - 60 minutes).
</p><p class="tableblock">Note that the copy is based on an incremental copy mechanism reducing the average copy time.
If a copy is still in progress when refresh period elapses, the second copy operation will be skipped.
</p><p class="tableblock">DirectoryProvider typically used on slave nodes using a JMS back end.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>indexBase</code>: Base directory
<code>indexName</code>: override @Indexed.index (useful for sharded indexes)
<code>sourceBase</code>: Source (copy) base directory.
<code>source</code>: Source directory suffix (default to <code>@Indexed.index</code>). The actual source directory
name being <em>&lt;sourceBase&gt;/&lt;source&gt;</em>
<code>refresh</code>: refresh period in second (the copy will take place every refresh seconds).
<code>locking_strategy</code> : optional, see <a href="#search-configuration-directory-lockfactories">LockFactory configuration</a>
<code>retry_marker_lookup</code> : optional, default to 0. Defines how many times we look for the marker files
in the source directory before failing. Waiting 5 seconds between each try.
<code>retry_initialize_period</code> : optional, set an integer value in seconds to enable the retry initialize
feature: if the slave can&#8217;t find the master index it will try again until it&#8217;s found in background,
without preventing the application to start: full-text queries performed before the index is
initialized are not blocked but will return empty results. When not enabling the option or
explicitly setting it to zero it will fail with an exception instead of scheduling a retry timer.
To prevent the application from starting without an invalid index but still control an
initialization timeout, see <code>retry_marker_lookup</code> instead.
<code>filesystem_access_type</code>: allows to determine the exact type of FSDirectory implementation
used by this DirectoryProvider. Allowed values are <code>auto</code> (the default value, selects NIOFSDirectory
on non Windows systems, SimpleFSDirectory on Windows), <code>simple</code> (SimpleFSDirectory), <code>nio</code>
(NIOFSDirectory), <code>mmap</code> (MMapDirectory). Make sure to refer to Javadocs of these Directory
implementations before changing this setting. Even though NIOFSDirectory or MMapDirectory can bring
substantial performance boosts they also have their issues.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">infinispan: Infinispan based directory.
</p><p class="tableblock">Use it to store the index in a distributed grid, making
index changes visible to all elements of the cluster very quickly. Also see
<a href="#infinispan-directories">Infinispan Directory configuration</a> for additional requirements and configuration settings.
Infinispan needs a global configuration and additional dependencies; the
settings defined here apply to each different index.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>locking_cachename</code>: name of the Infinispan cache to use to store locks.
<code>data_cachename</code> : name of the Infinispan cache to use to store the largest data chunks; this area
will contain the largest objects, use replication if you have enough memory or switch to
distribution.
<code>metadata_cachename</code>: name of the Infinispan cache to use to store the metadata relating to the
index; this data is rather small and read very often, it&#8217;s recommended to have this cache setup
using replication.
<code>chunk_size</code>: large files of the index are split in smaller chunks, you might want to set the
highest value efficiently handled by your network. Networking tuning might be useful.</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If the built-in directory providers do not fit your needs, you can write your own directory provider
by implementing the <code>org.hibernate.store.DirectoryProvider</code> interface. In this case, pass the fully
qualified class name of your provider into the <code>directory_provider</code> property. You can pass any
additional properties to configure your custom implementation using the prefix <code>hibernate.search.&lt;indexname&gt;</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="infinispan-directories"><a class="anchor" href="#infinispan-directories"></a>3.3.1. Infinispan Directory configuration</h4>
<div class="paragraph">
<p>Infinispan is a distributed, scalable, cloud friendly data grid platform, which
Hibernate Search can use to store the Lucene index. Your application can benefits in this case
from Infinispan&#8217;s distribution capabilities making index updates available on all nodes with short
latency.</p>
</div>
<div class="paragraph">
<p>This section describes how to configure Hibernate Search to use an Infinispan Lucene Directory.</p>
</div>
<div class="paragraph">
<p>When using an Infinispan Directory the index is stored in memory and shared across multiple nodes.
It is considered a single directory distributed across all participating nodes: if a node updates
the index, all other nodes are updated as well. Updates on one node can be immediately searched
for in the whole cluster.</p>
</div>
<div class="paragraph">
<p>The default configuration replicates all data which defines the index across all nodes, thus
consuming a significant amount of memory but providing the best query performance.
For large indexes it&#8217;s suggested to enable data distribution, so that each piece of information is
replicated to a subset of all cluster members. The distribution option will reduce the amount of memory
required for each node but is less efficient as it will cause high network usage among the nodes.</p>
</div>
<div class="paragraph">
<p>It is also possible to offload part or most information to a <code>CacheStore</code>, such as plain filesystem,
Amazon S3, Cassandra, MongoDB or standard relational databases. You can configure it to have a
<code>CacheStore</code> on each node or have a single centralized one shared by each node.</p>
</div>
<div class="paragraph">
<p>A popular choice is to use a replicated index aiming to keep the whole index in memory, combined with
a <code>CacheStore</code> as safety valve in case the index gets larger than expected.</p>
</div>
<div class="paragraph">
<p>See the <a href="http://infinispan.org/documentation/">Infinispan documentation</a> for all Infinispan
configuration options.</p>
</div>
<div class="sect4">
<h5 id="_requirements"><a class="anchor" href="#_requirements"></a>Requirements</h5>
<div class="paragraph">
<p>To use the Infinispan directory via Maven, add the following dependencies:</p>
</div>
<div class="exampleblock">
<div class="title">Example 13. Maven dependencies for Hibernate Search using Infinispan</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-XML" data-lang="XML">&lt;dependency&gt;
   &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
   &lt;artifactId&gt;hibernate-search-orm&lt;/artifactId&gt;
   &lt;version&gt;5.8.0.Final&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.infinispan&lt;/groupId&gt;
   &lt;artifactId&gt;infinispan-directory-provider&lt;/artifactId&gt;
   &lt;version&gt;9.0.1.Final&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>This dependency changed in Hibernate Search version 5.2.</p>
</div>
<div class="paragraph">
<p>Previously the DirectoryProvider was provided by the Hibernate Search project and had Maven coordinates
'org.hibernate:hibernate-search-infinispan', but the Infinispan team is now maintaining this extension point
so since this version please use the Maven definition as in the previous example.</p>
</div>
<div class="paragraph">
<p>The version printed above was the latest known compatible at the time of publishing this Hibernate Search version:
it&#8217;s possible that more recently improved versions of Infinispan have been published which
are compatible with this same Hibernate Search version.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_architecture"><a class="anchor" href="#_architecture"></a>Architecture</h5>
<div class="paragraph">
<p>Even when using an Infinispan directory it&#8217;s still recommended to use the JMS Master/Slave or
JGroups backend, because in Infinispan all nodes will share the same index and it is likely that
<code>IndexWriter</code> instances being active on different nodes will try to acquire the lock on the same
index. So instead of sending updates directly to the index, send it to a JMS queue or JGroups
channel and have a single node apply all changes on behalf of all other nodes.</p>
</div>
<div class="paragraph">
<p>Configuring a non-default backend is not a requirement but a performance optimization as locks are
enabled to have a single node writing.</p>
</div>
<div class="paragraph">
<p>To configure a JMS slave only the backend must be replaced, the directory provider must be set to
<code>infinispan</code>; set the same directory provider on the master, they will connect without the need to
setup the copy job across nodes. Using the JGroups backend is very similar - just combine the
backend configuration with the <code>infinispan</code> directory provider.</p>
</div>
</div>
<div class="sect4">
<h5 id="_infinispan_configuration"><a class="anchor" href="#_infinispan_configuration"></a>Infinispan Configuration</h5>
<div class="paragraph">
<p>The most simple configuration only requires to enable the backend:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>hibernate.search.[default|&lt;indexname&gt;].directory_provider = infinispan</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>That&#8217;s all what is needed to get a cluster-replicated index, but the default configuration does not
enable any form of permanent persistence for the index; to enable such a feature an Infinispan
configuration file should be provided.</p>
</div>
<div class="paragraph">
<p>To use Infinispan, Hibernate Search requires a CacheManager; it can lookup and reuse an existing
CacheManager, via JNDI, or start and manage a new one. In the latter case Hibernate Search will
start and stop it ( closing occurs when the Hibernate SessionFactory is closed).</p>
</div>
<div class="paragraph">
<p>To use and existing CacheManager via JNDI (optional parameter):</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>hibernate.search.infinispan.cachemanager_jndiname = [jndiname]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>To start a new CacheManager from a configuration file (optional parameter):</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>hibernate.search.infinispan.configuration_resourcename = [infinispan configuration filename]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If both parameters are defined, JNDI will have priority. If none of these is defined, Hibernate
Search will use the default Infinispan configuration included in <code>infinispan-directory-provider.jar</code>.
This configuration should work fine in most cases but does not store the index in a persistent cache
store.</p>
</div>
<div class="paragraph">
<p>As mentioned in <a href="#directory-provider-table">List of built-in DirectoryProvider</a>, each index makes use of three caches, so three
different caches should be configured as shown in the <code>default-hibernatesearch-infinispan.xml</code>
provided in the <code>infinispan-directory-provider.jar</code>. Several indexes can share the same caches.</p>
</div>
<div class="paragraph">
<p>Infinispan relies on JGroups for its networking functionality, so unless you are using Infinispan on
a single node, an Infinispan configuration file will refer to a JGroups configuration file. This
coupling is not always practical and we provide a property to override the used JGroups
configuration file:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>hibernate.search.infinispan.configuration.transport_override_resourcename = jgroups-ec2.xml</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This allows to just switch the JGroups configuration while keeping the rest of the Infinispan
configuration.</p>
</div>
<div class="paragraph">
<p>The file <code>jgroups-ec2.xml</code> used in the example above is one of the several JGroups configurations
included in Infinispan. It is a good starting point to run on Amazon EC2 networks. For more details
and examples see <a href="http://infinispan.org/docs/9.0.x/user_guide/user_guide.html#use_one_of_the_pre_configured_jgroups_files">usage of pre-configured JGroups stacks</a>
in the Infinispan configuration guide.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="configuration-worker"><a class="anchor" href="#configuration-worker"></a>3.4. Worker configuration</h3>
<div class="paragraph">
<p>It is possible to refine how Hibernate Search interacts with Lucene through the worker
configuration. There exist several architectural components and possible extension points. Let&#8217;s
have a closer look.</p>
</div>
<div class="paragraph">
<p>First there is a Worker. An implementation of the Worker interface is responsible for receiving all
entity changes, queuing them by context and applying them once a context ends. The most intuitive
context, especially in connection with ORM, is the transaction. For this reason Hibernate Search
will per default use the TransactionalWorker to scope all changes per transaction. One can, however,
imagine a scenario where the context depends for example on the number of entity changes or some
other application (lifecycle) events. For this reason the Worker implementation is configurable as
shown in <a href="#table-worker-configuration">Scope configuration</a>.</p>
</div>
<table id="table-worker-configuration" class="tableblock frame-all grid-all spread">
<caption class="title">Table 3. Scope configuration</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Property</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Description</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hibernate.search.worker.scope</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The fully qualified class name of the
            Worker implementation to use. If this
            property is not set, empty or <code>transaction</code> the
            default TransactionalWorker is
            used.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hibernate.search.default.worker.*</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">All configuration properties prefixed with
            <code>hibernate.search.default.worker</code> are passed to the
            Worker during initialization. This allows adding custom, worker
            specific parameters.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hibernate.search.worker.enlist_in_transaction</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Defaults to <code>false</code>. Set it to <code>true</code>
            to have all indexing work sent to the queue within the same transaction
            as the Hibernate ORM Session. This options should only be enabled when all
            backends use JMS and the queues are configured to be transactional, XA enabled.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Once a context ends it is time to prepare and apply the index changes. This can be done
synchronously or asynchronously from within a new thread. Synchronous updates have the advantage
that the index is at all times in sync with the databases. Asynchronous updates, on the other hand,
can help to minimize the user response time. The drawback is potential discrepancies between
database and index states. Lets look at the configuration options shown in
<a href="#table-work-execution-configuration">Execution configuration</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The following options can be different on each index; in fact they need the indexName prefix or use
<code>default</code> to set the default value for all indexes.</p>
</div>
</td>
</tr>
</table>
</div>
<table id="table-work-execution-configuration" class="tableblock frame-all grid-all spread">
<caption class="title">Table 4. Execution configuration</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Property</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Description</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hibernate.search.&lt;indexName&gt;.worker.execution</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>sync</code>: synchronous execution (default)
</p><p class="tableblock"><code>async</code>: asynchronous execution</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>So far all work is done within the same Virtual Machine (VM), no matter which execution mode. The
total amount of work has not changed for the single VM. Luckily there is a better approach, namely
delegation. It is possible to send the indexing work to a different server by configuring
hibernate.search.default.worker.backend - see <a href="#table-backend-configuration">Backend configuration</a>. Again this option can be
configured differently for each index.</p>
</div>
<table id="table-backend-configuration" class="tableblock frame-all grid-all spread">
<caption class="title">Table 5. Backend configuration</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Property</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Description</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hibernate.search.&lt;indexName&gt;.worker.backend</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>local</code>: The default backend which runs index updates in the same JVM. Also used when the property is undefined or empty.
</p><p class="tableblock"><code>jms</code>: JMS backend. Index updates are send to a JMS queue to be processed by an indexing master. See <a href="#table-jms-backend-configuration">JMS backend configuration</a> for additional configuration options and <a href="#jms-backend">JMS Master/Slave back end</a> for a more detailed description of this setup.
</p><p class="tableblock"><code>jgroupsMaster</code>, <code>jgroupsSlave</code> or <code>jgroups</code>: Backend using <a href="http://www.jgroups.org/">JGroups</a> as communication layer. See <a href="#jgroups-backend">JGroups Master/Slave back end</a> for a more detailed description of this setup.
</p><p class="tableblock"><code>blackhole</code>: Mainly a test/developer setting which ignores all indexing work
</p><p class="tableblock">You can also specify the fully qualified name of a class implementing <code>BackendQueueProcessor</code>.
This way you can implement your own communication layer: the queue processors will receive all index works
to be sent to index managers.
</p><p class="tableblock">Please note that instances of <code>BackendQueueProcessor</code> will only be created as soon as index managers are created,
and those may be created lazily
(for instance when the indexes are using <a href="#advanced-features-dynamic-sharding">dynamic sharding</a>).
If you want to initialize some resources eagerly,
you can instead specify the fully qualified name of a class implementing <code>Backend</code>.
This class which will be instantiated and initialized on startup,
and will then be asked to produce <code>BackendQueueProcessor</code> instances as needed.</p></td>
</tr>
</tbody>
</table>
<table id="table-jms-backend-configuration" class="tableblock frame-all grid-all spread">
<caption class="title">Table 6. JMS backend configuration</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Property</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Description</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hibernate.search.&lt;indexName&gt;.worker.jms.connection_factory</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Mandatory for the JMS back end. Defines the JNDI name to
            lookup the JMS connection factory from (<code>/ConnectionFactory</code> by default in WildFly)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hibernate.search.&lt;indexName&gt;.worker.jms.queue</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Mandatory for the JMS back end. Defines the JNDI name to
            lookup the JMS queue from. The queue will be used to post work
            messages.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hibernate.search.&lt;indexName&gt;.worker.jms.login</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Optional for the JMS slaves. Use it when your queue
            requires login credentials to define your login.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hibernate.search.&lt;indexName&gt;.worker.jms.login</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Optional for the JMS slaves. Use it when your queue
            requires login credentials to define your password.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Since these components use JNDI, don&#8217;t forget to configure the Hibernate ORM
properties for the initial context lookup.</p>
</div>
<table id="table-enable-jndi" class="tableblock frame-all grid-all spread">
<caption class="title">Table 7. Enable JNDI lookup capabilities of Hibernate ORM</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Property</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Description</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hibernate.jndi.class</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Name of the javax.naming.InitialContext implementation class to use</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hibernate.jndi.url</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Name of the JNDI InitialContext connection url</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>See also the <a href="http://docs.jboss.org/hibernate/orm/5.2/userguide/html_single/Hibernate_User_Guide.html#jndi/">JNDI configuration in Hibernate ORM</a>.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>As you probably noticed, some of the shown properties are correlated which means that not all
combinations of property values make sense. In fact you can end up with a non-functional
configuration. This is especially true for the case that you provide your own implementations of
some of the shown interfaces. Make sure to study the existing code before you write your own Worker
or BackendQueueProcessor implementation.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="jms-backend"><a class="anchor" href="#jms-backend"></a>3.4.1. JMS Master/Slave back end</h4>
<div class="paragraph">
<p>This section describes in greater detail how to configure the Master/Slave Hibernate Search
architecture.</p>
</div>
<div class="paragraph">
<p>JMS back end configuration.</p>
</div>
<div class="sect4">
<h5 id="_slave_nodes"><a class="anchor" href="#_slave_nodes"></a>Slave nodes</h5>
<div class="paragraph">
<p>Every index update operation is sent to a JMS queue. Index querying operations are executed on a
local index copy.</p>
</div>
<div class="exampleblock">
<div class="title">Example 14. JMS Slave configuration</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre>### slave configuration

## DirectoryProvider
# (remote) master location
hibernate.search.default.sourceBase = /mnt/mastervolume/lucenedirs/mastercopy

# local copy location
hibernate.search.default.indexBase = /Users/prod/lucenedirs

# refresh every half hour
hibernate.search.default.refresh = 1800

# appropriate directory provider
hibernate.search.default.directory_provider = filesystem-slave

## Backend configuration
hibernate.search.default.worker.backend = jms
hibernate.search.default.worker.jms.connection_factory = /ConnectionFactory
hibernate.search.default.worker.jms.queue = queue/hibernatesearch
#optionally authentication credentials:
hibernate.search.default.worker.jms.login = myname
hibernate.search.default.worker.jms.password = wonttellyou
#optional jndi configuration (check your JMS provider for more information)

## Enqueue indexing tasks within an XA transaction with the database (optional)
hibernate.search.worker.enlist_in_transaction = true</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>enlist_in_transaction</code> option can be enabled if you need strict guarantees of
indexing work to be stored in the queue within the same transaction of the database
changes, however this will require both the RDBMs datasource and the JMS queue to be XA enabled.</p>
</div>
<div class="paragraph">
<p>Make sure to use a XA JMS queue
and that your database supports XA as we are talking about coordinated transactional systems.</p>
</div>
<div class="paragraph">
<p>The default for <code>enlist_in_transaction</code> is <code>false</code> as often it is desirable to not have
the database transaction fail in case there are issues with indexing.</p>
</div>
<div class="paragraph">
<p>It is possible to apply compensating operations to the index by implementing a custom
<code>ErrorHandler</code> (see <a href="#exception-handling">Exception handling</a>), or simply re-synchronize the whole index
state by starting the MassIndexer (see <a href="#search-batchindex-massindexer">Using a MassIndexer</a>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>A file system local copy is recommended for faster search results.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_master_node"><a class="anchor" href="#_master_node"></a>Master node</h5>
<div class="paragraph">
<p>Every index update operation is taken from a JMS queue and executed. The master index is copied on a
regular basis.</p>
</div>
<div class="exampleblock">
<div class="title">Example 15. JMS Master configuration</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre>### master configuration

## DirectoryProvider
# (remote) master location where information is copied to
hibernate.search.default.sourceBase = /mnt/mastervolume/lucenedirs/mastercopy

# local master location
hibernate.search.default.indexBase = /Users/prod/lucenedirs

# refresh every half hour
hibernate.search.default.refresh = 1800

# appropriate directory provider
hibernate.search.default.directory_provider = filesystem-master

## Backend configuration
#The backend is not set: use the default one which is 'local'</pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>It is recommended that the refresh period be higher than the expected copy time; if a copy operation
is still being performed when the next refresh triggers, the second refresh is skipped: it&#8217;s safe to
set this value low even when the copy time is not known.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In addition to the Hibernate Search framework configuration, a Message Driven Bean has to be written
and set up to process the index works queue through JMS.</p>
</div>
<div class="exampleblock">
<div class="title">Example 16. Message Driven Bean processing the indexing queue</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@MessageDriven(activationConfig = {
      @ActivationConfigProperty(propertyName="destinationType",
                                propertyValue="javax.jms.Queue"),
      @ActivationConfigProperty(propertyName="destination",
                                propertyValue="queue/hibernatesearch")
   } )
public class MDBSearchController extends AbstractJMSHibernateSearchController
                                 implements MessageListener {

    @PersistenceContext EntityManager em;

    @Override
    protected SearchIntegrator getSearchIntegrator() {
        FullTextEntityManager fullTextEntityManager = Search.getFullTextEntityManager(em);
        return fullTextEntityManager.getSearchFactory().unwrap(SearchIntegrator.class);
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This example inherits from the abstract JMS controller class available in the Hibernate Search
source code and implements a JavaEE MDB. This implementation is given as an example and can be
adjusted to make use of non Java EE Message Driven Beans.
Essentially what you need to do is to connect the specific JMS Queue with the <code>SearchFactory</code>
instance of the EntityManager.
As an advanced alternative, you can implement your own logic by not extending <code>AbstractJMSHibernateSearchController</code>
but rather to use it as an implementation example.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jgroups-backend"><a class="anchor" href="#jgroups-backend"></a>3.4.2. JGroups Master/Slave back end</h4>
<div class="paragraph">
<p>This section describes how to configure the JGroups Master/Slave back end. The master and slave
roles are similar to what is illustrated in <a href="#jms-backend">JMS Master/Slave back end</a>, only a different backend
(hibernate.search.default.worker.backend) needs to be set.</p>
</div>
<div class="paragraph">
<p>A specific backend can be configured to act either as a slave using <code>jgroupsSlave</code>, as a master
using <code>jgroupsMaster</code>, or can automatically switch between the roles as needed by using <code>jgroups</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Either you specify a single <code>jgroupsMaster</code> and a set of <code>jgroupsSlave</code> instances, or you specify
all instances as <code>jgroups</code>. Never mix the two approaches!</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>All backends configured to use JGroups share the same channel. The JGroups JChannel is the main
communication link across all nodes participating in the same cluster group; since it is convenient
to have just one channel shared across all backends, the Channel configuration properties are not
defined on a per-worker section but are defined globally. See <a href="#jgroups-channel-configuration">JGroups channel configuration</a>.</p>
</div>
<div class="paragraph">
<p>Table <a href="#table-jgroups-backend-configuration">JGroups backend configuration properties</a> contains all configuration options which can be set
independently on each index backend. These apply to all three variants of the backend:
<code>jgroupsSlave</code>, <code>jgroupsMaster</code>, <code>jgroups</code>. It is very unlikely that you need to change any of these
from their defaults.</p>
</div>
<table id="table-jgroups-backend-configuration" class="tableblock frame-all grid-all spread">
<caption class="title">Table 8. JGroups backend configuration properties</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Property</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Description</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hibernate.search.&lt;indexName&gt;.jgroups.block_waiting_ack</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Set to either <code>true</code> or
              <code>false</code>. False is more efficient but will not
              wait for the operation to be delivered to the peers. Defaults to
              <code>true</code> when the backend is synchronous, to
              <code>false</code> when the backend is
              <code>async</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hibernate.search.&lt;indexName&gt;.jgroups.messages_timeout</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The timeout of waiting for a single command to be
              acknowledged and executed when
              <code>block_waiting_ack</code> is <code>true</code>,
              or just acknowledged otherwise. Value in milliseconds, defaults
              to <code>20000</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hibernate.search.&lt;indexName&gt;.jgroups.delegate_backend</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The master node receiving indexing operations forwards
              them to a standard backend to be performed. Defaults to
              <code>lucene</code>. See also <a href="#table-backend-configuration">Backend configuration</a> for other options, but
              probably the only useful option is <code>blackhole</code>,
              or a custom implementation, to help isolating network latency
              problems.</p></td>
</tr>
</tbody>
</table>
<div class="sect4">
<h5 id="_slave_nodes_2"><a class="anchor" href="#_slave_nodes_2"></a>Slave nodes</h5>
<div class="paragraph">
<p>Every index update operation is sent through a JGroups channel to the master node. Index querying
operations are executed on a local index copy. Enabling the JGroups worker only makes sure the index
operations are sent to the master, you still have to synchronize configuring an appropriate
directory (See <code>filesystem-master</code>, <code>filesystem-slave</code> or <code>infinispan</code> options in <a href="#search-configuration-directory">Directory configuration</a>).</p>
</div>
<div class="exampleblock">
<div class="title">Example 17. JGroups Slave configuration</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre>### slave configuration
hibernate.search.default.worker.backend = jgroupsSlave</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_master_node_2"><a class="anchor" href="#_master_node_2"></a>Master node</h5>
<div class="paragraph">
<p>Every index update operation is taken from a JGroups channel and executed. The master index is
copied on a regular basis.</p>
</div>
<div class="exampleblock">
<div class="title">Example 18. JGroups Master configuration</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre>### master configuration
hibernate.search.default.worker.backend = jgroupsMaster</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_automatic_master_election"><a class="anchor" href="#_automatic_master_election"></a>Automatic master election</h5>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>This feature is considered experimental. In particular during a re-election process there is a small
window of time in which indexing requests could be lost.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In this mode the different nodes will autonomously elect a master node. When a master fails, a new
node is elected automatically.</p>
</div>
<div class="paragraph">
<p>When setting this backend it is expected that all Hibernate Search instances in the same cluster use
the same backend for each specific index: this configuration is an alternative to the static
<code>jgroupsMaster</code> and <code>jgroupsSlave</code> approach so make sure to not mix them.</p>
</div>
<div class="paragraph">
<p>To synchronize the indexes in this configuration avoid <code>filesystem-master</code> and <code>filesystem-slave</code>
directory providers as their behaviour can not be switched dynamically; use the Infinispan
<code>Directory</code> instead, which has no need for different configurations on each instance and allows
dynamic switching of writers; see also <a href="#infinispan-directories">Infinispan Directory configuration</a>.</p>
</div>
<div class="exampleblock">
<div class="title">Example 19. JGroups configuration for automatic master configuration</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre>### automatic configuration
hibernate.search.default.worker.backend = jgroups</pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Should you use <code>jgroups</code> or the couple <code>jgroupsMaster</code>, <code>jgroupsSlave</code>?</p>
</div>
<div class="paragraph">
<p>The dynamic <code>jgroups</code> backend is better suited for environments in which your master is more likely
to need to failover to a different machine, as in clouds. The static configuration has the benefit
of keeping the master at a well known location: your architecture might take advantage of it by
sending most write requests to the known master. Also optimisation and MassIndexer operations need
to be triggered on the master node.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="jgroups-channel-configuration"><a class="anchor" href="#jgroups-channel-configuration"></a>JGroups channel configuration</h5>
<div class="paragraph">
<p>Configuring the JGroups channel essentially entails specifying the transport in terms of a network
protocol stack. To configure the JGroups transport, point the configuration property
hibernate.search.services.jgroups.configurationFile to a JGroups configuration file; this can be
either a file path or a Java resource name.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If no property is explicitly specified it is assumed that the JGroups default configuration file
<code>flush-udp.xml</code> is used. This example configuration is known to work in most scenarios, with the
notable exception of Amazon AWS; refer to the
<a href="http://www.jgroups.org/manual-3.x/html/">JGroups manual</a> for more examples and protocol
configuration details.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The default cluster name is <code>Hibernate Search Cluster</code> which can be configured as seen in <a href="#example-jgroups-cluster-name">JGroups cluster name configuration</a>.</p>
</div>
<div id="example-jgroups-cluster-name" class="exampleblock">
<div class="title">Example 20. JGroups cluster name configuration</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre>hibernate.search.services.jgroups.clusterName = My-Custom-Cluster-Id</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The cluster name is what identifies a group: by changing the name you can run different clusters in
the same network in isolation.</p>
</div>
<div class="sect5">
<h6 id="_jgroups_channel_instance_injection"><a class="anchor" href="#_jgroups_channel_instance_injection"></a>JGroups channel instance injection</h6>
<div class="paragraph">
<p>For programmatic configurations, one additional option is available to configure the JGroups
channel: to pass an existing channel instance to Hibernate Search directly using the property
<code>hibernate.search.services.jgroups.providedChannel</code>, as shown in the following example.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">import org.hibernate.search.backend.impl.jgroups.JGroupsChannelProvider;

org.jgroups.JChannel channel = ...
Map&lt;String,String&gt; properties = new HashMap&lt;String,String)(1);
properties.put( JGroupsChannelProvider.CHANNEL_INJECT, channel );
EntityManagerFactory emf = Persistence.createEntityManagerFactory( "userPU", properties );</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="configuration-reader-strategy"><a class="anchor" href="#configuration-reader-strategy"></a>3.5. Reader strategy configuration</h3>
<div class="paragraph">
<p>The different reader strategies are described in <a href="#search-architecture-readerstrategy">Reader strategy</a>. Out of the
box strategies are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>shared</code>: share index readers across several queries. This strategy is very efficient.</p>
</li>
<li>
<p><code>not-shared</code>: create an index reader for each individual query. Very simple implementation.</p>
</li>
<li>
<p><code>async</code>: only opens a new index reader periodically. This is the most efficient implementation, but queries might return out of date values.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The default reader strategy is <code>shared</code>.</p>
</div>
<div class="paragraph">
<p>You can pick the reader strategy by changing the <code>.reader.strategy</code> configuration property,
scoped to the "default" index or to a specific index.</p>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>hibernate.search.[default|&lt;indexname&gt;].reader.strategy = async
hibernate.search.[default|&lt;indexname&gt;].reader.async_refresh_period_ms = 8000</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Adding the above properties switches to the <code>async</code> strategy, and configures it to refresh
the index reader each 8 seconds.</p>
</div>
<div class="paragraph">
<p>Alternatively you can use a custom implementation of a <code>org.hibernate.search.indexes.spi.ReaderProvider</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>hibernate.search.[default|&lt;indexname&gt;].reader.strategy = my.corp.myapp.CustomReaderProvider</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>where my.corp.myapp.CustomReaderProvider is the custom strategy implementation.</p>
</div>
</div>
<div class="sect2">
<h3 id="_serialization"><a class="anchor" href="#_serialization"></a>3.6. Serialization</h3>
<div class="paragraph">
<p>When using clustering features, Hibernate Search needs to find an implementation of the
<code>SerializationProvider</code> service on the classpath.</p>
</div>
<div class="paragraph">
<p>An implementation of the service based on <a href="https://avro.apache.org">Apache Avro</a> can be found
using the following GAV coordinates:</p>
</div>
<div class="paragraph">
<p><code>org.hibernate:hibernate-search-serialization-avro:5.8.0.Final</code></p>
</div>
<div class="paragraph">
<p>You can add the coordinates to your pom file or download all the required dependecies and add them
to your classpath. Hibernate Search will find the service implementation without any additional
configuration.</p>
</div>
<div class="paragraph">
<p>Alternatively, you can create a custom service implementation:</p>
</div>
<div id="example-serialization-provider" class="exampleblock">
<div class="title">Example 21. Serialization strategy definition</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">package example.provider.serializer

import org.hibernate.search.indexes.serialization.spi.Deserializer;
import org.hibernate.search.indexes.serialization.spi.SerializationProvider;
import org.hibernate.search.indexes.serialization.spi.Serializer;

public class ExampleOfSerializationProvider implements SerializationProvider {

   @Override
    public Serializer getSerializer() {
        Serializer serializer = ...
        return serializer;
    }

    @Override
    public Deserializer getDeserializer() {
        Deserializer deserializer = ...
        return deserializer;
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Hibernate Search uses the Java ServiceLoader mechanism to transparently discover services.
In this case you will add the following file in your classpath:</p>
</div>
<div class="exampleblock">
<div class="title">Example 22. Service file for the SerializationProvider service</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre>/META-INF/services/org.hibernate.search.indexes.serialization.spi.SerializationProvider</pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 23. Content of /META-INF/services/org.hibernate.search.indexes.serialization.spi.SerializationProvider</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre>example.provider.serializer.ExampleOfSerializationProvider</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You will find more details about services in the section <a href="#section-services">Using external services</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="exception-handling"><a class="anchor" href="#exception-handling"></a>3.7. Exception handling</h3>
<div class="paragraph">
<p>Hibernate Search allows you to configure how exceptions are handled during the indexing process. If
no configuration is provided then exceptions are logged to the log output by default. It is possible
to explicitly declare the exception logging mechanism as seen below:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>hibernate.search.error_handler = log</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The default exception handling occurs for both synchronous and asynchronous indexing. Hibernate
Search provides an easy mechanism to override the default error handling implementation.</p>
</div>
<div class="paragraph">
<p>In order to provide your own implementation you must implement the ErrorHandler interface, which
provides the handle(ErrorContext context) method. ErrorContext provides a reference to the primary
LuceneWork instance, the underlying exception and any subsequent LuceneWork instances that could not
be processed due to the primary exception.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public interface ErrorContext {
   List&lt;LuceneWork&gt; getFailingOperations();
   LuceneWork getOperationAtFault();
   Throwable getThrowable();
   boolean hasErrors();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>To register this error handler with Hibernate Search you must declare the fully qualified classname
of your ErrorHandler implementation in the configuration properties:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>hibernate.search.error_handler = CustomerErrorHandler</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Alternatively, an ErrorHandler instance may be passed via the configuration value map used when bootstrapping Hibernate Search programmatically.</p>
</div>
</div>
<div class="sect2">
<h3 id="_lucene_configuration"><a class="anchor" href="#_lucene_configuration"></a>3.8. Lucene configuration</h3>
<div class="paragraph">
<p>Even though Hibernate Search will try to shield you as much as possible from Lucene specifics, there
are several Lucene specifics which can be directly configured, either for performance reasons or for
satisfying a specific use case. The following sections discuss these configuration options.</p>
</div>
<div class="sect3">
<h4 id="lucene-indexing-performance"><a class="anchor" href="#lucene-indexing-performance"></a>3.8.1. Tuning indexing performance</h4>
<div class="paragraph">
<p>Hibernate Search allows you to tune the Lucene indexing performance by specifying a set of
parameters which are passed through to underlying Lucene <code>IndexWriter</code> such as <code>mergeFactor</code>,
<code>maxMergeDocs</code> and <code>maxBufferedDocs</code>. You can specify these parameters either as default values
applying for all indexes, on a per index basis, or even per shard.</p>
</div>
<div class="paragraph">
<p>There are several low level <code>IndexWriter</code> settings which can be tuned for different use cases.
These parameters are grouped by the <code>indexwriter</code> keyword:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>hibernate.search.[default|&lt;indexname&gt;].indexwriter.&lt;parameter_name&gt;</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If no value is set for an <code>indexwriter</code> value in a specific shard configuration, Hibernate Search
will look at the index section, then at the default section.</p>
</div>
<div id="example-performance-option-configuration" class="exampleblock">
<div class="title">Example 24. Example performance option configuration</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre>hibernate.search.Animals.2.indexwriter.max_merge_docs = 10
hibernate.search.Animals.2.indexwriter.merge_factor = 20
hibernate.search.Animals.2.indexwriter.max_buffered_docs = default
hibernate.search.default.indexwriter.max_merge_docs = 100
hibernate.search.default.indexwriter.ram_buffer_size = 64</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The configuration in <a href="#example-performance-option-configuration">Example performance option configuration</a> will result in these settings
applied on the second shard of the Animal index:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>max_merge_docs</code> = 10</p>
</li>
<li>
<p><code>merge_factor</code> = 20</p>
</li>
<li>
<p><code>ram_buffer_size</code> = 64MB</p>
</li>
<li>
<p><code>max_buffered_docs</code> = Lucene default</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All other values will use the defaults defined in Lucene.</p>
</div>
<div class="paragraph">
<p>The default for all values is to leave them at Lucene&#8217;s own default. The values listed in
<a href="#table-performance-parameters">List of indexing performance and behavior properties</a> depend for this reason on the version of Lucene you are using.
The values shown are relative to version <code>2.4</code>. For more information about Lucene indexing performance,
please refer to the Lucene documentation.</p>
</div>
<table id="table-performance-parameters" class="tableblock frame-all grid-all spread">
<caption class="title">Table 9. List of indexing performance and behavior properties</caption>
<colgroup>
<col style="width: 40%;">
<col style="width: 40%;">
<col style="width: 20%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Property</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Default Value</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hibernate.search.[default|&lt;indexname&gt;].exclusive_index_use</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Set to <code>true</code> when no other process will need to write to the same index. This will enable
Hibernate Search to work in exclusive mode on the index and improve performance when writing changes
to the index.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>true</code> (improved performance, releases locks only at shutdown)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hibernate.search.[default|&lt;indexname&gt;].max_queue_length</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Each index has a separate "pipeline" which contains the updates to be applied to the index.
When this queue is full adding more operations to the queue becomes a blocking operation. Configuring
this setting doesn&#8217;t make much sense unless the <code>worker.execution</code> is configured as <code>async</code>.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1000</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hibernate.search.[default|&lt;indexname&gt;].index_flush_interval</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The interval in milliseconds between flushes
of write operations to the index storage. Ignored unless <code>worker.execution</code> is configured as <code>async</code>.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1000</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hibernate.search.[default|&lt;indexname&gt;].indexwriter.max_buffered_delete_terms</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Determines the minimal number of delete terms required before the buffered in-memory delete terms
are applied and flushed. If there are documents buffered in memory at the time, they are merged and
a new segment is created.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Disabled (flushes by RAM usage)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hibernate.search.[default|&lt;indexname&gt;].indexwriter.max_buffered_docs</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Controls the amount of documents buffered in memory during indexing. The bigger the more RAM is
consumed.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Disabled (flushes by RAM usage)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hibernate.search.[default|&lt;indexname&gt;].indexwriter.max_merge_docs</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Defines the largest number of documents allowed in a segment. Smaller values perform better on
frequently changing indexes, larger values provide better search performance if the index does not
change often.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Unlimited (Integer.MAX_VALUE)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hibernate.search.[default|&lt;indexname&gt;].indexwriter.merge_factor</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Controls segment merge frequency and size. Determines how often segment indexes are merged when
insertion occurs. With smaller values, less RAM is used while indexing, and searches on unoptimized
indexes are faster, but indexing speed is slower. With larger values, more RAM is used during
indexing, and while searches on unoptimized indexes are slower, indexing is faster. Thus larger
values (&gt; 10) are best for batch index creation, and smaller values (&lt; 10) for indexes that are
interactively maintained. The value must not be lower than 2.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hibernate.search.[default|&lt;indexname&gt;].indexwriter.merge_min_size</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Controls segment merge frequency and size. Segments smaller than this size (in MB) are always
considered for the next segment merge operation.
Setting this too large might result in expensive merge operations, even tough they are less frequent.
See also <code>org.apache.lucene.index.LogDocMergePolicy.minMergeSize</code>.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0 MB (actually ~1K)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hibernate.search.[default|&lt;indexname&gt;].indexwriter.merge_max_size</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Controls segment merge frequency and size. Segments larger than this size (in MB) are never merged
in bigger segments. This helps reduce memory requirements and avoids some merging operations at the
cost of optimal search speed. When optimizing an index this value is ignored.
See also <code>org.apache.lucene.index.LogDocMergePolicy.maxMergeSize</code>.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Unlimited</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hibernate.search.[default|&lt;indexname&gt;].indexwriter.merge_max_optimize_size</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Controls segment merge frequency and size. Segments larger than this size (in MB) are not merged
in bigger segments even when optimizing the index (see <code>merge_max_size</code> setting as well).
Applied to <code>org.apache.lucene.index.LogDocMergePolicy.maxMergeSizeForOptimize</code>.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Unlimited</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hibernate.search.[default|&lt;indexname&gt;].indexwriter.merge_calibrate_by_deletes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Controls segment merge frequency and size. Set to <code>false</code> to not consider deleted documents when
estimating the merge policy. Applied to <code>org.apache.lucene.index.LogMergePolicy.calibrateSizeByDeletes</code>.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>true</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hibernate.search.[default|&lt;indexname&gt;].indexwriter.ram_buffer_size</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Controls the amount of RAM in MB dedicated to document buffers. When used together max_buffered_docs
a flush occurs for whichever event happens first.
Generally for faster indexing performance it&#8217;s best to flush by RAM usage instead of document count
and use as large a RAM buffer as you can.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">16 MB</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hibernate.search.enable_dirty_check</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Not all entity changes require an update of the Lucene index. If all of the updated entity
properties (dirty properties) are not indexed Hibernate Search will skip the re-indexing work.
Disable this option if you use a custom <code>FieldBridge</code> which need to be invoked at each update
event (even though the property for which the field bridge is configured has not changed).
This optimization will not be applied on classes using a <code>@ClassBridge</code> or a <code>@DynamicBoost</code>.
Boolean parameter, use "true" or "false".</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hibernate.search.[default|&lt;indexname&gt;].indexwriter.infostream</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Enable low level trace information about Lucene&#8217;s internal components.
Will cause significant performance degradation: should only be used for troubleshooting purposes.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When your architecture permits it, always keep
<code>hibernate.search.default.exclusive_index_use=true</code> as it greatly improves efficiency in index
writing. This is the default since Hibernate Search version 4.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>To tune the indexing speed it might be useful to time the object loading from database in isolation
from the writes to the index. To achieve this set the <code>blackhole</code> as worker backend and start your
indexing routines. This backend does not disable Hibernate Search: it will still generate the needed
changesets to the index, but will discard them instead of flushing them to the index. In contrast to
setting the <code>hibernate.search.indexing_strategy</code> to <code>manual</code>, using <code>blackhole</code> will possibly
load more data from the database because associated entities are re-indexed as well.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>hibernate.search.[default|&lt;indexname&gt;].worker.backend blackhole</pre>
</div>
</div>
<div class="paragraph">
<p>The recommended approach is to focus first on optimizing the object loading by enabling the <code>blackhole</code> backend,
and then use the timings you achieve as a baseline to tune the indexing process.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The <code>blackhole</code> backend is not meant to be used in production, only as a tool to identify indexing
bottlenecks.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="lucene-segment-size"><a class="anchor" href="#lucene-segment-size"></a>Control segment size</h5>
<div class="paragraph">
<p>The options <code>merge_max_size</code>, <code>merge_max_optimize_size</code>, <code>merge_calibrate_by_deletes</code>
give you control on the maximum size of the segments being created, but you need to understand how
they affect file sizes. If you need to hard limit the size, consider that merging a segment is about
adding it together with another existing segment to form a larger one, so you might want to set the
<code>max_size</code> for merge operations to less than half of your hard limit. Also segments might
initially be generated larger than your expected size at first creation time: before they are ever
merged. A segment is never created much larger than <code>ram_buffer_size</code>, but the threshold is
checked as an estimate.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>//to be fairly confident no files grow above 15MB, use:
hibernate.search.default.indexwriter.ram_buffer_size = 10
hibernate.search.default.indexwriter.merge_max_optimize_size = 7
hibernate.search.default.indexwriter.merge_max_size = 7</pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When using the Infinispan Directory to cluster indexes make sure that your segments are smaller than
the <code>chunk_size</code> so that you avoid fragmenting segments in the grid. Note that the
<code>chunk_size</code> of the Infinispan Directory is expressed in bytes, while the index tuning options
are in MB.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="lucene-infostream"><a class="anchor" href="#lucene-infostream"></a>Troubleshooting: enable Lucene&#8217;s Infostream</h5>
<div class="paragraph">
<p>Apache Lucene allows to log a very detailed trace log from its internals using a feature called "infostream".
To access these details, Hibernate Search can be configured to capture this internal trace from Apache Lucene and redirect it to your logger.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Enable <code>TRACE</code> level logging for the category <code>org.hibernate.search.backend.lucene.infostream</code></p>
</li>
<li>
<p>Activate the feature on the index you want to inspect: <code>hibernate.search.[default|&lt;indexname&gt;].indexwriter.infostream=true</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Keep in mind that this feature has a performance cost, and although most logger frameworks allow the <code>TRACE</code> level to be reconfigured at runtime,
enabling the <code>infostream</code> property will slow you down even if the logger is disabled.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="search-configuration-directory-lockfactories"><a class="anchor" href="#search-configuration-directory-lockfactories"></a>3.8.2. LockFactory configuration</h4>
<div class="paragraph">
<p>Lucene Directorys have default locking strategies which work generally good enough for most cases,
but it&#8217;s possible to specify for each index managed by Hibernate Search a specific LockingFactory
you want to use. This is generally not needed but could be useful.</p>
</div>
<div class="paragraph">
<p>Some of these locking strategies require a filesystem-level lock.
They may be used with the <code>local-heap</code> directory provider,
but in this case the <code>indexBase</code> configuration option
(usually not needed when using a <code>local-heap</code> directory provider)
must be specified to point to a filesystem location where the lock marker files will be stored.</p>
</div>
<div class="paragraph">
<p>To select a locking factory, set the <code>hibernate.search.&lt;index&gt;.locking_strategy</code> option to
one of <code>simple</code>, <code>native</code>, <code>single</code> or <code>none</code>. Alternatively set it to the fully qualified name of
an implementation of <code>org.hibernate.search.store.LockFactoryProvider</code>.</p>
</div>
<table id="search-configuration-directory-lockfactories-table" class="tableblock frame-all grid-all spread">
<caption class="title">Table 10. List of available LockFactory implementations</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">name</th>
<th class="tableblock halign-left valign-top">Class</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">simple</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">org.apache.lucene.store.SimpleFSLockFactory</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Safe implementation based on Java&#8217;s File API, it marks the usage of the index by creating a marker file.
</p><p class="tableblock">If for some reason you had to kill your application, you will need to remove this file before restarting it.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">native</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">org.apache.lucene.store.NativeFSLockFactory</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">As does <code>simple</code> this also marks the usage of the index by creating a marker file, but this one is using native OS file locks so that even if the JVM is terminated the locks will be cleaned up.
</p><p class="tableblock">This implementation has known problems on NFS, avoid it on network shares.
</p><p class="tableblock"><code>native</code> is the default implementation for the <code>filesystem</code>, <code>filesystem-master</code> and <code>filesystem-slave</code> directory providers.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">single</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">org.apache.lucene.store.SingleInstanceLockFactory</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This LockFactory doesn&#8217;t use a file marker but is a Java object lock held in memory; therefore it&#8217;s possible to use it only when you are sure the index is not going to be shared by any other process.
</p><p class="tableblock">This is the default implementation for the <code>local-heap</code> directory provider.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">none</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">org.apache.lucene.store.NoLockFactory</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">All changes to this index are not coordinated by any lock; test your application carefully and make sure you know what it means.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Configuration example:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>hibernate.search.default.locking_strategy = simple
hibernate.search.Animals.locking_strategy = native
hibernate.search.Books.locking_strategy = org.custom.components.MyLockingFactory</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The Infinispan Directory uses a custom implementation; it&#8217;s still possible to override it but make
sure you understand how that will work, especially with clustered indexes.</p>
</div>
</div>
<div class="sect3">
<h4 id="_index_format_compatibility"><a class="anchor" href="#_index_format_compatibility"></a>3.8.3. Index format compatibility</h4>
<div class="paragraph">
<p>While Hibernate Search strives to offer a backwards compatible API making it easy to port your
application to newer versions, it still delegates to Apache Lucene to handle the index writing and
searching. This creates a dependency to the Lucene index format. The Lucene developers of course
attempt to keep a stable index format, but sometimes a change in the format can not be avoided. In
those cases you either have to re-index all your data or use an index upgrade tool. Sometimes Lucene
is also able to read the old format so you don&#8217;t need to take specific actions (besides making
backup of your index).</p>
</div>
<div class="paragraph">
<p>While an index format incompatibility is a rare event, it can happen more often that Lucene&#8217;s
Analyzer implementations might slightly change its behavior. This can lead to a poor recall score,
possibly missing many hits from the results.</p>
</div>
<div class="paragraph">
<p>Hibernate Search exposes a configuration property <code>hibernate.search.lucene_version</code> which
instructs the analyzers and other Lucene classes to conform to their behavior as defined in an
(older) specific version of Lucene. See also <code>org.apache.lucene.util.Version</code> contained in the
<em>lucene-core.jar</em>. Depending on the specific version of Lucene you&#8217;re using you might have different
options available. When this option is not specified, Hibernate Search will instruct Lucene to use
the default version, which is usually the best option for new projects. Still it&#8217;s recommended to
define the version you&#8217;re using explicitly in the configuration so that when you happen to upgrade
Lucene the analyzers will not change behavior. You can then choose to update this value at a later
time, when you for example have the chance to rebuild the index from scratch.</p>
</div>
<div class="exampleblock">
<div class="title">Example 25. Force Analyzers to be compatible with a Lucene 4.7 created index</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre>hibernate.search.lucene_version = LUCENE_47</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This option is global for the configured SearchFactory and affects all Lucene APIs having such a
parameter, as this should be applied consistently. So if you are also making use of Lucene bypassing
Hibernate Search, make sure to apply the same value too.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_metadata_api"><a class="anchor" href="#_metadata_api"></a>3.9. Metadata API</h3>
<div class="paragraph">
<p>After looking at all these different configuration options, it is time to have a look at an API
which allows you to programmatically access parts of the configuration. Via the metadata API you can
determine the indexed types and also how they are mapped (see <a href="#search-mapping">Mapping entities to the index structure</a>) to the index
structure. The entry point into this API is the SearchFactory. It offers two methods, namely
<code>getIndexedTypes()</code> and <code>getIndexedTypeDescriptor(Class&lt;?&gt;)</code>. The former returns a set of all
indexed type, where as the latter allows to retrieve a so called IndexedTypeDescriptorfor a given
type. This descriptor allows you determine whether the type is indexed at all and, if so, whether
the index is for example sharded or not (see <a href="#advanced-features-sharding">Sharding indexes</a>). It also allows you to
determine the static boost of the type (see <a href="#section-boost-annotation">Static index time boosting</a>) as well as its dynamic
boost strategy (see <a href="#section-dynamic-boost">Dynamic index time boosting</a>). Most importantly, however, you get information about
the indexed properties and generated Lucene Document fields. This is exposed via PropertyDescriptors
respectively FieldDescriptors. The easiest way to get to know the API is to explore it via the IDE
or its javadocs.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>All descriptor instances of the metadata API are read only. They do not allow to change any runtime
configuration.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="search-configuration-deploy-on-wildfly"><a class="anchor" href="#search-configuration-deploy-on-wildfly"></a>3.10. Hibernate Search as a WildFly module</h3>
<div class="paragraph">
<p>Hibernate Search is included in the WildFly application server, and since WildFly 10 the module
is automatically activated (added to the classpath of your deployment) if you are using Hibernate ORM and have any indexed entities.</p>
</div>
<div class="paragraph">
<p>Alternatively you can opt to use a different version of the module by downloading and unzipping a different
moduleset and setting the <code>wildfly.jpa.hibernate.search.module</code> property in your <code>persistence.xml</code>.</p>
</div>
<div class="paragraph">
<p>The modules system in WildFly allows to safely run multiple versions of Hibernate ORM and
Hibernate Search in parallel, but if you download an alternative version make sure the Hibernate Search version you choose
is compatible with the Hibernate ORM version you choose.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>This version of Hibernate Search <code>5.8.0.Final</code> requires an Hibernate ORM version <code>5.2.3.Final</code> or a later version
of the 5.2 branch, such as <code>5.2.8.Final</code>.</p>
</div>
<div class="paragraph">
<p>The modules distributed by Hibernate Search <code>5.8.0.Final</code> are meant for WildFly 11.</p>
</div>
<div class="paragraph">
<p>WildFly includes an older version of Hibernate ORM, so you will need to upgrade this dependency as well.
The Hibernate ORM / WildFly update instructions can be found <a href="http://docs.jboss.org/hibernate/orm/5.2/topical/html_single/wildfly/Wildfly.html">here</a>.</p>
</div>
<div class="paragraph">
<p>Not least, as the same guide explains you might need to exclude the Javassist version.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="using-wildfly-provided-hibernatesearch-versions"><a class="anchor" href="#using-wildfly-provided-hibernatesearch-versions"></a>3.10.1. Use the Hibernate Search version included in WildFly</h4>
<div class="paragraph">
<p>The activation of the Hibernate Search modules in WildFly is automatic, provided you&#8217;re having at least one
entity annotated with <code>org.hibernate.search.annotations.Indexed</code>.</p>
</div>
<div class="paragraph">
<p>You can control this behaviour of the JPA deployer explicitly; for example to make sure Hibernate Search
and Apache Lucene classes are available to your application even though you haven&#8217;t annotated any entity,
set the following property in your <code>persistence.xml</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>wildfly.jpa.hibernate.search.module=org.hibernate.search.orm:main</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_update_and_activate_latest_hibernate_search_version_in_wildfly"><a class="anchor" href="#_update_and_activate_latest_hibernate_search_version_in_wildfly"></a>3.10.2. Update and activate latest Hibernate Search version in WildFly</h4>
<div class="paragraph">
<p>You can download the latest Hibernate Search provided module and install it. This is often the
best approach as you will benefit from all the latest improvements of
Hibernate Search. Because of the modular design in WildFly, these additional modules can
coexist with the embedded modules and won&#8217;t affect any other application, unless you
explicitly reconfigure it to use the newer module.</p>
</div>
<div class="paragraph">
<p>You can download the latest pre-packaged Hibernate Search modules from
<a href="http://sourceforge.net/projects/hibernate/files/hibernate-search/5.8.0.Final/hibernate-search-modules-5.8.0.Final-wildfly-11-dist.zip/download">Sourceforge</a>.
As a convenience these zip files are also distributed as Maven artifacts:
<a href="https://repository.jboss.org/nexus/index.html#nexus-search;gav~org.hibernate~hibernate-search-modules~{hibernateSearchVersion}~~">org.hibernate:hibernate-search-modules-5.8.0.Final-wildfly-11-dist:zip</a>.</p>
</div>
<div class="paragraph">
<p>Unpack the modules in your WildFly <code>modules</code> directory: this will create modules for Hibernate Search and Apache Lucene.
The Hibernate Search modules are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>org.hibernate.search.orm</em>, for users of Hibernate Search with Hibernate; this will transitively include Hibernate ORM.</p>
</li>
<li>
<p><em>org.hibernate.search.engine</em>, for projects depending on the internal indexing engine that don&#8217;t require other dependencies to Hibernate.</p>
</li>
<li>
<p><em>org.hibernate.search.backend-jms</em>, in case you want to use the JMS backend described in <a href="#search-architecture-jms">JMS Architecture</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Next you will need to make sure the JPA deployer of WildFly provides you with the version you have chosen, instead of the default version
bundled with the application server.
Set the following property in your <code>persistence.xml</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>wildfly.jpa.hibernate.search.module=org.hibernate.search.orm:5.8.0.Final</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>See also <a href="https://docs.jboss.org/author/display/WFLY/JPA+Reference+Guide#JPAReferenceGuide-UsingHibernateSearch">the WildFly JPA configuration</a></p>
</div>
</div>
<div class="sect3">
<h4 id="_more_about_modules"><a class="anchor" href="#_more_about_modules"></a>3.10.3. More about modules</h4>
<div class="paragraph">
<p>More information about the modules configuration in WildFly can be found in the
<a href="https://docs.jboss.org/author/display/WFLY/Class+Loading+in+WildFly">Class Loading in WildFly</a> wiki.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Modular classloading is a feature of JBoss EAP 7 as well, but if you are using JBoss EAP, you&#8217;re
reading the wrong version of the user guide! JBoss EAP subscriptions include official support for
Hibernate Search and come with a different edition of this guide specifically tailored for EAP users.</p>
</div>
<div class="paragraph">
<p>See the <a href="https://access.redhat.com/documentation/en-us/red_hat_jboss_enterprise_application_platform/7.0/html/development_guide/hibernate_search">Chapter 13 of the Red Hat JBoss Enterprise Application Platform 7 Development Guide</a>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_using_infinispan_with_hibernate_search_on_wildfly"><a class="anchor" href="#_using_infinispan_with_hibernate_search_on_wildfly"></a>3.10.4. Using Infinispan with Hibernate Search on WildFly</h4>
<div class="paragraph">
<p>If you are updating the version of Hibernate Search in WildFly as described in the previous paragraph,
you might need to update Infinispan as well.
The process is very similar: download the modules from
<a href="http://infinispan.org/download/">Infinispan project downloads</a>, picking a compatible version,
and decompress the modules into the <code>modules</code> directory of your WildFly installation.</p>
</div>
<div class="paragraph">
<p>Hibernate Search version <code>5.8.0.Final</code> was compiled and tested with Infinispan version
<code>9.0.1.Final</code>; generally a more recent version of either project is expected to be backwards
compatible for cross-project integration purposes as long as they have the same "major.minor" family
version.</p>
</div>
<div class="paragraph">
<p>For example for a version of Hibernate Search depending on Infinispan <code>8.2.4.Final</code> it should be
safe to upgrade Infinispan to <code>8.2.6.Final</code>, but an upgrade to <code>8.3.0.Final</code> might not work.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="search-mapping"><a class="anchor" href="#search-mapping"></a>4. Mapping entities to the index structure</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="search-mapping-entity"><a class="anchor" href="#search-mapping-entity"></a>4.1. Mapping an entity</h3>
<div class="paragraph">
<p>In <a href="#getting-started">Getting started</a> you have already seen that all the metadata information needed to index
entities is described through annotations. There is no need for XML mapping files. You can still use
Hibernate mapping files for the basic Hibernate configuration, but the Hibernate Search specific
configuration has to be expressed via annotations.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>There is no XML configuration available for Hibernate Search but we provide a programmatic
mapping API that elegantly replaces this kind of deployment form (see
<a href="#hsearch-mapping-programmaticapi">Programmatic API</a> for more information).</p>
</div>
<div class="paragraph">
<p>If you want to contribute the XML mapping implementation, see
<a href="https://hibernate.atlassian.net/browse/HSEARCH-210">HSEARCH-210</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="basic-mapping"><a class="anchor" href="#basic-mapping"></a>4.1.1. Basic mapping</h4>
<div class="paragraph">
<p>Lets start with the most commonly used annotations when mapping an entity.</p>
</div>
<div class="sect4">
<h5 id="indexed-annotation"><a class="anchor" href="#indexed-annotation"></a>@Indexed</h5>
<div class="paragraph">
<p>Foremost you must declare a persistent class as indexable by annotating the class with <code>@Indexed.</code>
All entities not annotated with <code>@Indexed</code> will be ignored by the indexing process.</p>
</div>
<div class="exampleblock">
<div class="title">Example 26. Making a class indexable with <code>@Indexed</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed
public class Essay {
    ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can optionally specify the <code>Indexed.index</code> attribute to change the default name of the index.
For more information regarding index naming see <a href="#search-configuration-directory">Directory configuration</a>.</p>
</div>
<div class="paragraph">
<p>You can also specify an optional indexing interceptor. For more information see
<a href="#search-mapping-indexinginterceptor">conditional indexing</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="field-annotation"><a class="anchor" href="#field-annotation"></a>@Field</h5>
<div class="paragraph">
<p>For each property of your entity, you have the ability to describe whether and how it
will be indexed. Adding the <code>@Field</code> annotation declares a property as indexed and allows you to
configure various aspects of the indexing process. Without <code>@Field</code> the property is ignored by
the indexing process.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Hibernate Search tries to determine the best way to convert your property to an indexable value automatically.
See <a href="#section-built-in-bridges">Built-in bridges</a> for more information about how property values are converted by default,
and see the <code>bridge</code> attribute of the <code>@Field</code> annotation below
for more information about how to customize conversion.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following attributes of the <code>@Field</code> annotation help you control the indexing outcome:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>name</code>: describes under which name the property should be stored in the Lucene Document. The
default value is the property name (following the JavaBeans convention)</p>
</li>
<li>
<p><a id="field-annotation-store"></a><code>store</code>: describes whether or not the property is stored in the Lucene index. You can store the
value <code>Store.YES</code> (consuming more space in the index but allowing <a href="#projections">projection</a>),
store it in a compressed way <code>Store.COMPRESS</code> (this does consume more CPU), or avoid any storage
<code>Store.NO</code> (this is the default value). When a property is stored, you can retrieve its original
value from the Lucene Document. Storing the property has no impact on whether the value is
searchable or not.</p>
</li>
<li>
<p><code>index</code>: describes whether the property is indexed or not. The different values are <code>Index.NO</code>
(no indexing, meaning the value cannot be found by a query), <code>Index.YES</code> (the element gets indexed
and is searchable). The default value is <code>Index.YES</code>. <code>Index.NO</code> can be useful for cases where a
property is not required to be searchable, but needed for projection.</p>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>Index.NO</code> in combination with <code>Analyze.YES</code> or <code>Norms.YES</code> is not useful, since analyze and norms
require the property to be indexed</p>
</div>
</td>
</tr>
</table>
</div>
</li>
<li>
<p><code>analyze</code>: determines whether the property is analyzed (<code>Analyze.YES</code>) or not (<code>Analyze.NO</code>).
The default value is <code>Analyze.YES</code>.</p>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Whether or not you want to analyze a property depends on whether you wish to search the element as
is, or by the words it contains. It make sense to analyze a text field, but probably not a date
field.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Fields used for faceting <em>must not</em> be analyzed.</p>
</div>
<div class="paragraph">
<p>Fields used for sorting <em>can</em> be analyzed, but <em>must not</em> be tokenized,
so you should rather use <a href="#section-normalizers">normalizers</a> on those fields.</p>
</div>
</td>
</tr>
</table>
</div>
</li>
<li>
<p><a id="field-annotation-norms"></a><code>norms</code>: describes whether index time scoring information should be stored (<code>Norms.YES</code>) or
not (<code>Norms.NO</code>). Not storing the norms can save a considerable amount of memory, but index time
boosting (in particular) will not be available in this case. The default value is <code>Norms.YES</code>.</p>
</li>
<li>
<p><code>termVector</code>: describes collections of term-frequency pairs. This attribute enables the storing
of the term vectors within the documents during indexing. The default value is <code>TermVector.NO</code>.</p>
<div class="paragraph">
<p>The different values of this attribute are:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Value</th>
<th class="tableblock halign-left valign-top">Definition</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TermVector.YES</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Store the term vectors of each document. This
                    produces two synchronized arrays, one contains document
                    terms and the other contains the term&#8217;s frequency.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TermVector.NO</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Do not store term vectors.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TermVector.WITH_OFFSETS</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Store the term vector and token offset information.
                    This is the same as <code>TermVector.YES</code> plus it contains the
                    starting and ending offset position information for the
                    terms.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TermVector.WITH_POSITIONS</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Store the term vector and token position
                    information. This is the same as <code>TermVector.YES</code> plus it
                    contains the ordinal positions of each occurrence of a
                    term in a document.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TermVector.WITH_POSITION_OFFSETS</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Store the term vector, token position and offset
                    information. This is a combination of the <code>YES</code>,
                    <code>WITH_OFFSETS</code> and <code>WITH_POSITIONS</code>.</p></td>
</tr>
</tbody>
</table>
</li>
<li>
<p><a id="field-annotation-indexNullAs"></a><code>indexNullAs</code>: Per default null values are ignored and not indexed. However, using <code>indexNullAs</code>
you can specify a string which will be inserted as token for the null value. Per default this value
is set to <code>org.hibernate.search.annotations.Field.DO_NOT_INDEX_NULL</code> indicating that null values
should not be indexed. You can set this value to <code>DEFAULT_NULL_TOKEN</code> to indicate that a default null
token should be used. This default null token can be specified in the configuration using
<code>hibernate.search.default_null_token</code>. If this property is not set the string <code>_null_</code> will
be used as default.
When the field is of a Numeric Type (see <a href="#numeric-field-annotation">@NumericField</a>), the token will be encoded as the
respective numeric type: the <code>indexNullAs</code> value needs to be set to a value which can be parsed into
a number of the matching type, for example "-1".</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When <code>indexNullAs</code> is used, it is important to use the chosen null token in search queries (see
<a href="#search-query">Querying</a>) in order to find null values. It is also advisable to use this feature only with
un-analyzed fields (<code>analyze=Analyze.NO</code>).</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When implementing a custom <code>FieldBridge</code> or <code>TwoWayFieldBridge</code> it is up to the developer to handle the
indexing of null values (see JavaDocs of <code>LuceneOptions.indexNullAs()</code>).</p>
</div>
</td>
</tr>
</table>
</div>
</li>
<li>
<p><code>boost</code>: Refer to section about <a href="#section-boosting">boosting</a></p>
</li>
<li>
<p><code>bridge</code>: Refer to section about <a href="#section-custom-bridges">field bridges</a></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="numeric-field-annotation"><a class="anchor" href="#numeric-field-annotation"></a>@NumericField</h5>
<div class="paragraph">
<p><code>@NumericField</code> is a companion annotation to <code>@Field</code>. It can be specified in the
same scope as <code>@Field</code>, but only on properties of numeric type like byte, short, int, long, double and float
(and their respective Java wrapper types). It allows to define a custom <code>precisionStep</code> for the
numeric encoding of the property value.</p>
</div>
<div class="paragraph">
<p><code>@NumericField</code> accepts the following parameters:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Value</th>
<th class="tableblock halign-left valign-top">Definition</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>forField</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(Optional) Specify the name of of the related <code>@Field</code>
                  that will be indexed numerically. It&#8217;s only mandatory when
                  the property contains more than a <code>@Field</code> declaration</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>precisionStep</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(Optional) Change the way that the Trie structure is
                  stored in the index. Smaller <code>precisionSteps</code> lead to more
                  disk space usage and faster range and sort queries. Larger
                  values lead to less space used and range query performance
                  more close to the range query using string encoding. Default
                  value is 4.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Lucene supports the numeric types: <code>Double</code>, <code>Long</code>, <code>Integer</code> and <code>Float</code>. For properties of types
<code>Byte</code> and <code>Short</code>, an <code>Integer</code> field will be used in the index. Other numeric types
should use the default string encoding (via <code>@Field</code>), unless the application can deal with a
potential loss in precision, in which case a custom <code>NumericFieldBridge</code> can be used. See
<a href="#example-custom-numericfieldbridge">Defining a custom NumericFieldBridge for <code>BigDecimal</code></a>.</p>
</div>
<div id="example-custom-numericfieldbridge" class="exampleblock">
<div class="title">Example 27. Defining a custom NumericFieldBridge for <code>BigDecimal</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public class BigDecimalNumericFieldBridge extends NumericFieldBridge {
    private static final BigDecimal storeFactor = BigDecimal.valueOf(100);

    @Override
    public void set(String name, Object value, Document document, LuceneOptions luceneOptions) {
        if ( value != null ) {
            BigDecimal decimalValue = (BigDecimal) value;
            long tmpLong = decimalValue.multiply( storeFactor ).longValue();
            Long indexedValue = Long.valueOf( tmpLong );
            luceneOptions.addNumericFieldToDocument( name, indexedValue, document );
        }
    }

    @Override
    public Object get(String name, Document document) {
        String fromLucene = document.get( name );
        BigDecimal storedBigDecimal = new BigDecimal( fromLucene );
        return storedBigDecimal.divide( storeFactor );
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You would use this custom bridge like seen in <a href="#example-useof-custom-numericfieldbridge">Use of <code>BigDecimalNumericFieldBridge</code></a>. In this
case three annotations are used - <code>@Field</code>, <code>@NumericField</code> and <code>@FieldBridge</code>. <code>@Field</code> is required
to mark the property for being indexed (a standalone <code>@NumericField</code> is never allowed).
<code>@NumericField</code> might be omitted in this specific case, because the used <code>@FieldBridge</code> annotation
refers already to a <code>NumericFieldBridge</code> instance. However, the use of <code>@NumericField</code> makes the
use of the property as numeric value explicit.</p>
</div>
<div id="example-useof-custom-numericfieldbridge" class="exampleblock">
<div class="title">Example 28. Use of <code>BigDecimalNumericFieldBridge</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed
public class Item {
    @Id
    @GeneratedValue
    private int id;

    @Field
    @NumericField
    @FieldBridge(impl = BigDecimalNumericFieldBridge.class)
    private BigDecimal price;

    public int getId() {
        return id;
    }

    public BigDecimal getPrice() {
       return price;
    }

    public void setPrice(BigDecimal price) {
        this.price = price;
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="sortablefield-annotation"><a class="anchor" href="#sortablefield-annotation"></a>@SortableField</h5>
<div class="paragraph">
<p>As of Lucene 5 (and thus Hibernate Search 5.5) it is highly recommended to create a so-called "doc value field"
for each field to sort on. Hibernate Search provides the <code>@SortableField</code> annotation for that purpose.
This is an extension annotation to <code>@Field</code> and marks a field as sortable (internally, the required doc value
field will be added to the index).</p>
</div>
<div id="example-useof-sortablefield" class="exampleblock">
<div class="title">Example 29. Use of <code>@SortableField</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed
public class Book {

    @Id
    @GeneratedValue
    private int id;

    @Field(name="Abstract", analyze=Analyze.NO)
    @SortableField
    private String summary;

    // ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If there is a single <code>@Field</code> declared for a given property, <code>@SortableField</code> implicitly applies to this field.
In case several fields exist for a single property, the <code>@Field</code> to be marked as sortable can be specified
via <code>@SortableField#forField()</code>.
Several sortable fields can be defined as the <code>@SortableField</code> annotation is repeatable.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The field to be marked as sortable must not be tokenized, so you should either disable analysis on this field,
or use a <a href="#section-normalizers">normalizer</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Note that sorting also works if a property is not explicitly marked with <code>@SortableField</code>. This has negative runtime
performance and memory consumption implications, though. Therefore it is highly recommended to explicitly mark each
field to be used for sorting.</p>
</div>
<div class="paragraph">
<p>Should you want to make a property sortable but not searchable, still an <code>@Field</code> needs to be declared (so its field
bridge configuration can be inherited). It can be marked with <code>store = Store.NO</code> and <code>index = Index.NO</code>, causing
only the doc value field required for sorting to be added, but not a regular index field.</p>
</div>
<div class="paragraph">
<p><a id="metadata-providing-field-bridge"></a> Fields added through class-level bridges or custom field-level bridges (when not using the default field name) cannot
be marked as sortable by means of the <code>@SortableField</code> annotation. Instead the field bridge itself has to add the
required doc value fields, in addition to the document fields it adds. Furthermore such bridge needs to implement the
<code>MetadataProvidingFieldBridge</code> interface which defines a method <code>configureFieldMetadata()</code> for marking the fields
created by this bridge as sortable:</p>
</div>
<div id="example-adding-docvaluefield" class="exampleblock">
<div class="title">Example 30. Marking fields as sortable via a custom field bridge</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">/***
  * Custom field bridge for a Map property which creates sortable fields
  * with the values of two keys from the map.
  */
public class MyClassBridge implements MetadataProvidingFieldBridge {

  @Override
  public void set(String name, Object value,
          Document document, LuceneOptions luceneOps) {

      Map&lt;String, String&gt; map = (Map&lt;String, String&gt;) value;

      String firstName = map.get( "firstName" );
      String lastName = map.get( "lastName" );

      // add regular document fields
      luceneOps.addFieldToDocument( name + "_firstName", lastName, document );
      luceneOps.addFieldToDocument( name + "_lastName", lastName, document );

      // add doc value fields to allow for sorting
      document.addSortedDocValuesFieldToDocument( name + "_firstName", firstName );
      document.addSortedDocValuesFieldToDocument( name + "_lastName", lastName );
  }

  @Override
  public void configureFieldMetadata(String name, FieldMetadataBuilder builder) {
      builder
          .field( name + "_firstName", FieldType.STRING )
              .sortable( true )
          .field( name + "_lastName", FieldType.STRING )
              .sortable( true );
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The meta-data configured through <code>configureFieldMetadata()</code> will be used for sort validation upon query execution. The
name passed to the method is the default field name also passed to <code>set()</code>. It needs to be used consistently with
<code>set()</code>, e.g. as a prefix for all custom fields added.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The <code>MetadataProvidingFieldBridge</code> contract is under active development and considered experimental at this time. It
may be altered in future revisions, e.g. by adding further methods, thus breaking existing implementations.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect5">
<h6 id="flagging-uncovered-sorts"><a class="anchor" href="#flagging-uncovered-sorts"></a>Flagging uncovered sorts</h6>
<div class="paragraph">
<p>By default Hibernate Search will raise an exception when running a query with sorts not
covered by the sortable fields configured as described above.</p>
</div>
<div class="paragraph">
<p>You thus can optionally advice Hibernate Search to transparently create an uninverting index reader when detecting uncovered sorts.
Note that while this allows to execute the query, relying on index uninverting negatively impacts performance.</p>
</div>
<div class="paragraph">
<p>To do so, specify the following option:</p>
</div>
<div class="exampleblock">
<div class="title">Example 31. Enabling automatic index uninverting for uncovered sorts</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>hibernate.search.index_uninverting_allowed = true</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>For instance you may leave this to the default (<code>false</code>) during testing to identify the sortable fields required for your queries
and set it to <code>true</code> in production environments to fall back to index uninverting for uncovered sorts accidentally left over.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="id-annotation"><a class="anchor" href="#id-annotation"></a>@Id</h5>
<div class="paragraph">
<p>Finally, the id property of an entity is a special property used by Hibernate Search to ensure index
unicity of a given entity. By design, an id has to be stored and must not be tokenized. It is also
always string encoded, even if the id is a number. To mark a property as index id, use the
<code>@DocumentId</code> annotation. If you are using JPA and you are using <code>@Id</code> you can omit <code>@DocumentId</code>.
The chosen entity id will also be used as document id.</p>
</div>
<div id="example-annotated-entity" class="exampleblock">
<div class="title">Example 32. Specifying indexed properties</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed
public class Essay {
    ...

    @Id
    @DocumentId
    public Long getId() { return id; }

    @Field(name="Abstract", store=Store.YES)
    public String getSummary() { return summary; }

    @Lob
    @Field
    public String getText() { return text; }

    @Field
    @NumericField(precisionStep = 6)
    public float getGrade() { return grade; }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><a href="#example-annotated-entity">Specifying indexed properties</a> defines an index with four fields: <code>id</code>, <code>Abstract</code>, <code>text</code> and
<code>grade</code>. Note that by default the field name is de-capitalized, following the JavaBean
specification. The <code>grade</code> field is annotated as numeric with a slightly larger <code>precisionStep</code> than
the default.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>It is not recommended to sort on the id field as it will lead to erratic behaviors. If you want to sort on your
document id, it is recommended to declare another field specifically for sorting using the <code>@Field</code> annotation.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="fields-annotation"><a class="anchor" href="#fields-annotation"></a>4.1.2. Mapping properties multiple times</h4>
<div class="paragraph">
<p>Sometimes one has to map a property multiple times per index, with slightly different indexing
strategies. For example, sorting a query by field requires the field to be un-analyzed. If one wants
to search by words in this property and still sort it, one need to index it twice - once analyzed
and once un-analyzed.
The <code>@Field</code> is repeatable, wich allows to achieve this goal.
Alternatively you can use the legacy, explicit plural form <code>@Fields</code>.</p>
</div>
<div id="example-fields-annotation" class="exampleblock">
<div class="title">Example 33. Using <code>@Field</code> repeatedly to map a property multiple times</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed(index = "Book")
public class Book {

    @Field
    @Field(name = "summary_forSort", analyze = Analyze.NO, store = Store.YES)
    @SortableField(forField = "summary_forSort")
    public String getSummary() {
        return summary;
    }

    // ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In <a href="#example-fields-annotation">Using <code>@Field</code> repeatedly to map a property multiple times</a> the field <code>summary</code> is indexed twice, once as <code>summary</code> in a
tokenized way, and once as <code>summary_forSort</code> in an un-tokenized way.
<code>@Field</code> supports two attributes which are particularly useful when the annotation is repeated:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>analyzer</code>: defines a <code>@Analyzer</code> annotation per field rather than per property</p>
</li>
<li>
<p><code>normalizer</code>: defines a <code>@Normalizer</code> annotation for the given field, instead of an analyzer.
<code>analyzer</code> and <code>normalizer</code> are mutually exclusive: you can only use one of the two.</p>
</li>
<li>
<p><code>bridge</code>: defines a <code>@FieldBridge</code> annotation per field rather than per property</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>See below for more information about analyzers/normalizers and field bridges.</p>
</div>
</div>
<div class="sect3">
<h4 id="search-mapping-associated"><a class="anchor" href="#search-mapping-associated"></a>4.1.3. Embedded and associated objects</h4>
<div class="paragraph">
<p>Associated objects as well as embedded objects can be indexed as part of the root entity index. This
is useful if you expect to search a given entity based on properties of the associated objects.</p>
</div>
<div class="paragraph">
<p>In the example <a href="#example-indexing-associations">Indexing associations</a> the aim is to return places where the associated
city is Atlanta (in Lucene query parser language, it would translate into <code>address.city:Atlanta</code>).
All place fields are added to the <code>Place</code> index, but also the address related fields <code>address.street</code>,
and <code>address.city</code> will be added and made queryable. The embedded object id,
<code>address.id</code>, is not added per default. To include it you need to also set
<code>@IndexedEmbedded(includeEmbeddedObjectId=true, &#8230;&#8203;)</code>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Only actual indexed fields (properties annotated with <code>@Field</code>) are added to the root entity index
when embedded objects are indexed. The embedded object identifiers are treated differently and need to
be included explicitly.</p>
</div>
</td>
</tr>
</table>
</div>
<div id="example-indexing-associations" class="exampleblock">
<div class="title">Example 34. Indexing associations</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed
public class Place {
    @Id
    @GeneratedValue
    private Long id;

    @Field
    private String name;

    @OneToOne(cascade = { CascadeType.PERSIST, CascadeType.REMOVE })
    @IndexedEmbedded
    private Address address;
    ....
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
public class Address {
    @Id
    @GeneratedValue
    private Long id;

    @Field
    private String street;

    @Field
    private String city;

    @ContainedIn
    @OneToMany(mappedBy="address")
    private Set&lt;Place&gt; places;
    ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Be careful. Because the data is de-normalized in the Lucene index when using the <code>@IndexedEmbedded</code>
technique, Hibernate Search needs to be aware of any change in the <code>Place</code> object and any change in
the <code>Address</code> object to keep the index up to date. To make sure the <code>Place</code> Lucene document is updated
when it&#8217;s <code>Address</code> changes, you need to mark the other side of the bidirectional relationship with
<code>@ContainedIn</code>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>@ContainedIn</code> is useful on both associations pointing to entities and on embedded (collection of)
objects.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Let&#8217;s make <a href="#example-indexing-associations">Indexing associations</a> a bit more complex by nesting <code>@IndexedEmbedded</code> as seen
in <a href="#example-nested-index-embedded">Nested usage of <code>@IndexedEmbedded</code> and <code>@ContainedIn</code></a>.</p>
</div>
<div id="example-nested-index-embedded" class="exampleblock">
<div class="title">Example 35. Nested usage of <code>@IndexedEmbedded</code> and <code>@ContainedIn</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed
public class Place {
    @Id
    @GeneratedValue
    private Long id;

    @Field
    private String name;

    @OneToOne(cascade = { CascadeType.PERSIST, CascadeType.REMOVE })
    @IndexedEmbedded
    private Address address;

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
public class Address {
    @Id
    @GeneratedValue
    private Long id;

    @Field
    private String street;

    @Field
    private String city;

    @IndexedEmbedded(depth = 1, prefix = "ownedBy_")
    private Owner ownedBy;

    @ContainedIn
    @OneToMany(mappedBy="address")
    private Set&lt;Place&gt; places;

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Embeddable
public class Owner {
    @Field
    private String name;
    // ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>As you can see, any <code>@*ToMany</code>, <code>@*ToOne</code> or <code>@Embedded</code> attribute can be annotated with
<code>@IndexedEmbedded</code>. The attributes of the associated class will then be added to the main entity
index. In <a href="#example-nested-index-embedded">Nested usage of <code>@IndexedEmbedded</code> and <code>@ContainedIn</code></a> the index will contain the following fields</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>id</code></p>
</li>
<li>
<p><code>name</code></p>
</li>
<li>
<p><code>address.street</code></p>
</li>
<li>
<p><code>address.city</code></p>
</li>
<li>
<p><code>address.ownedBy_name</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The default prefix is <code>propertyName.</code>, following the traditional object navigation convention. You
can override it using the <code>prefix</code> attribute as it is shown on the <code>ownedBy</code> property.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The prefix cannot be set to the empty string.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>depth</code> property is necessary when the object graph contains a cyclic dependency of classes (not
instances). For example, if <code>Owner</code> points to <code>Place</code>. Hibernate Search will stop including indexed
embedded attributes after reaching the expected depth (or the object graph boundaries are reached).
A class having a self reference is an example of cyclic dependency. In our example, because <code>depth</code>
is set to 1, any <code>@IndexedEmbedded</code> attribute in <code>Owner</code> (if any) will be ignored.</p>
</div>
<div class="paragraph">
<p>Using <code>@IndexedEmbedded</code> for object associations allows you to express queries (using Lucene&#8217;s query
syntax) such as:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Return places where name contains JBoss and where address city is Atlanta. In Lucene query this would be</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>+name:jboss +address.city:atlanta</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Return places where name contains JBoss and where owner&#8217;s name contain Joe. In Lucene query this would be</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>+name:jboss +address.ownedBy_name:joe</pre>
</div>
</div>
<div class="paragraph">
<p>In a way it mimics the relational join operation in a more efficient way (at the cost of data
duplication). Remember that, out of the box, Lucene indexes have no notion of association, the join
operation is simply non-existent. It might help to keep the relational model normalized while
benefiting from the full text index speed and feature richness.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>An associated object can itself (but does not have to) be <code>@Indexed</code></p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When <code>@IndexedEmbedded</code> points to an entity, the association has to be directional and the other side
has to be annotated with <code>@ContainedIn</code>. If not, Hibernate Search has
no way to update the root index when the associated entity is updated (in our example, a <code>Place</code>
index document has to be updated when the associated <code>Address</code> instance is updated).</p>
</div>
<div class="paragraph">
<p>Sometimes, the object type annotated by <code>@IndexedEmbedded</code> is not the object type targeted by
Hibernate and Hibernate Search. This is especially the case when interfaces are used in lieu of
their implementation. For this reason you can override the object type targeted by Hibernate Search
using the <code>targetElement</code> parameter.</p>
</div>
<div class="exampleblock">
<div class="title">Example 36. Using the <code>targetElement</code> property of <code>@IndexedEmbedded</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed
public class Address {
    @Id
    @GeneratedValue
    private Long id;

    @Field
    private String street;

    @IndexedEmbedded(depth = 1, prefix = "ownedBy_", targetElement = Owner.class)
    @Target(Owner.class)
    private Person ownedBy;

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Embeddable
public class Owner implements Person { ... }</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="search-mapping-associated-viapaths"><a class="anchor" href="#search-mapping-associated-viapaths"></a>Limiting object embedding to specific paths</h5>
<div class="paragraph">
<p>The <code>@IndexedEmbedded</code> annotation provides also an attribute <code>includePaths</code> which can be used as an
alternative to <code>depth</code>, or in combination with it.</p>
</div>
<div class="paragraph">
<p>When using only <code>depth</code> all indexed fields of the embedded type will be added recursively at the same
depth; this makes it harder to pick only a specific path without adding all other fields as well,
which might not be needed.</p>
</div>
<div class="paragraph">
<p>To avoid unnecessarily loading and indexing entities you can specify exactly which paths are needed.
A typical application might need different depths for different paths, or in other words it might
need to specify paths explicitly, as shown in <a href="#indexedembedded-includePath">Using the <code>includePaths</code> property of <code>@IndexedEmbedded</code></a></p>
</div>
<div id="indexedembedded-includePath" class="exampleblock">
<div class="title">Example 37. Using the <code>includePaths</code> property of <code>@IndexedEmbedded</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed
public class Person {

   @Id
   public int getId() {
      return id;
   }

   @Field
   public String getName() {
      return name;
   }

   @Field
   public String getSurname() {
      return surname;
   }

   @OneToMany
   @IndexedEmbedded(includePaths = { "name" })
   public Set&lt;Person&gt; getParents() {
      return parents;
   }

   @ContainedIn
   @ManyToOne
   public Human getChild() {
      return child;
   }

   // ... other fields omitted</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Using a mapping as in <a href="#indexedembedded-includePath">Using the <code>includePaths</code> property of <code>@IndexedEmbedded</code></a>, you would be able to search on a <code>Person</code> by
<code>name</code> and/or <code>surname</code>, and/or the <code>name</code> of the parent. It will not index the <code>surname</code> of the
parent, so searching on parent&#8217;s surnames will not be possible but speeds up indexing, saves space
and improve overall performance.</p>
</div>
<div class="paragraph">
<p>The <code>@IndexedEmbedded.includePaths</code> will include the specified paths <em>in addition to</em> what you would
index normally specifying a limited value for depth. Using <code>includePaths</code> with a undefined (default)
value for <code>depth</code> is equivalent to setting <code>depth=0</code>: only the included paths are indexed.</p>
</div>
<div id="indexedembedded-includePathsAndDepth" class="exampleblock">
<div class="title">Example 38. Using the <code>includePaths</code> property of <code>@IndexedEmbedded</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed
public class Human {

   @Id
   public int getId() {
      return id;
   }

   @Field
   public String getName() {
      return name;
   }

   @Field
   public String getSurname() {
      return surname;
   }

   @OneToMany
   @IndexedEmbedded(depth = 2, includePaths = { "parents.parents.name" })
   public Set&lt;Human&gt; getParents() {
      return parents;
   }

   @ContainedIn
   @ManyToOne
   public Human getChild() {
      return child;
   }

    // ... other fields omitted</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In <a href="#indexedembedded-includePathsAndDepth">Using the <code>includePaths</code> property of <code>@IndexedEmbedded</code></a>, every human will have it&#8217;s name and surname attributes
indexed. The name and surname of parents will be indexed too, recursively up to second line because
of the <code>depth</code> attribute. It will be possible to search by name or surname, of the person directly,
his parents or of his grand parents. Beyond the second level, we will in addition index one more
level but only the name, not the surname.</p>
</div>
<div class="paragraph">
<p>This results in the following fields in the index:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>id</code> - as primary key</p>
</li>
<li>
<p><code>_hibernate_class</code> - stores entity type</p>
</li>
<li>
<p><code>name</code> - as direct field</p>
</li>
<li>
<p><code>surname</code> - as direct field</p>
</li>
<li>
<p><code>parents.name</code> - as embedded field at depth 1</p>
</li>
<li>
<p><code>parents.surname</code> - as embedded field at depth 1</p>
</li>
<li>
<p><code>parents.parents.name</code> - as embedded field at depth 2</p>
</li>
<li>
<p><code>parents.parents.surname</code> - as embedded field at depth 2</p>
</li>
<li>
<p><code>parents.parents.parents.name</code> - as additional path as specified by includePaths. The first
<code>parents.</code> is inferred from the field name, the remaining path is the attribute of includePaths</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>You can explicitly include the id of the embedded object using <code>includePath</code>, for example
<code>@IndexedEmbedded(includePaths = { "parents.id" })</code>. This will work regardless of the
<code>includeEmbeddedObjectId</code> attribute. However, it is recommended to just set
<code>includeEmbeddedObjectId=true</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Having explicit control of the indexed paths might be easier if you&#8217;re designing your application by
defining the needed queries first, as at that point you might know exactly which fields you need,
and which other fields are unnecessary to implement your use case.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_indexing_null_embeddeds"><a class="anchor" href="#_indexing_null_embeddeds"></a>Indexing null embeddeds</h5>
<div class="paragraph">
<p>Per default null values are ignored and not indexed. However, using <code>indexNullAs</code> you can specify that a field should be added when the embedded is null, with a value of your choice.</p>
</div>
<div class="paragraph">
<p>Per default <code>indexNullAs</code> is set to <code>org.hibernate.search.annotations.IndexedEmbedded.DO_NOT_INDEX_NULL</code>, indicating that null values should not be indexed. You can set this value to <code>IndexedEmbedded.DEFAULT_NULL_TOKEN</code> to indicate that a default null token should be used. This default null token can be specified in the configuration using <code>hibernate.search.default_null_token</code>. If this property is not set the string <code>_null_</code> will be used as default.</p>
</div>
<div class="paragraph">
<p>The field name used when indexing null values depend on the <code>prefix</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>if the <code>prefix</code> is not set, the field name will be the Java property name</p>
</li>
<li>
<p>if the <code>prefix</code> is set, the field name will be the prefix with the trailing dot (if any) removed.
For instance with the prefix <code>my_embedded.</code>, the null field name will be <code>my_embedded</code> (without dot).</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When <code>indexNullAs</code> is used, it is important to use the chosen null token in search queries (see
<a href="#search-query">Querying</a>) in order to find null values.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_associated_objects_building_a_dependency_graph_with_containedin"><a class="anchor" href="#_associated_objects_building_a_dependency_graph_with_containedin"></a>4.1.4. Associated objects: building a dependency graph with @ContainedIn</h4>
<div class="paragraph">
<p>While <code>@ContainedIn</code> is often seen as the counterpart of <code>@IndexedEmbedded</code>, it can also be used
on its own to build an indexing dependency graph.</p>
</div>
<div class="paragraph">
<p>When an entity is reindexed, all the entities pointed by <code>@ContainedIn</code> are also going to be
reindexed.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section-boosting"><a class="anchor" href="#section-boosting"></a>4.2. Boosting</h3>
<div class="paragraph">
<p>Lucene has the notion of <em>boosting</em> which allows you to give certain documents or fields more or
less importance than others. Lucene differentiates between index and search time boosting. The
following sections show you how you can achieve index time boosting using Hibernate Search.</p>
</div>
<div class="sect3">
<h4 id="section-boost-annotation"><a class="anchor" href="#section-boost-annotation"></a>4.2.1. Static index time boosting</h4>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Index-time boosting is deprecated: support for this approach will be removed in Apache Lucene since version 7.</p>
</div>
<div class="paragraph">
<p>We recommend to use query-time boosting instead: see <a href="#search-query">Querying</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To define a static boost value for an indexed class or property you can use the <code>@Boost</code> annotation.
You can use this annotation within <code>@Field</code> or specify it directly on method or class level.</p>
</div>
<div id="example-boost" class="exampleblock">
<div class="title">Example 39. Different ways of using <code>@Boost</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed
@Boost(1.7f)
public class Essay {
    ...

    @Id
    @DocumentId
    public Long getId() { return id; }

    @Field(name="Abstract", store=Store.YES, boost=@Boost(2f))
    @Boost(1.5f)
    public String getSummary() { return summary; }

    @Lob
    @Field(boost=@Boost(1.2f))
    public String getText() { return text; }

    @Field
    public String getISBN() { return isbn; }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In <a href="#example-boost">Different ways of using <code>@Boost</code></a>, Essay&#8217;s probability to reach the top of the search list will be multiplied by
1.7. The summary field will be 3.0 (2 * 1.5, because <code>@Field.boost</code> and <code>@Boost</code> on a property are
cumulative) more important than the <code>isbn</code> field. The text field will be 1.2 times more important than
the <code>isbn</code> field. Note that this explanation is wrong in strictest terms, but it is simple and close
enough to reality for all practical purposes. Please check the Lucene documentation or the excellent
Lucene In Action from Otis Gospodnetic and Erik Hatcher.</p>
</div>
</div>
<div class="sect3">
<h4 id="section-dynamic-boost"><a class="anchor" href="#section-dynamic-boost"></a>4.2.2. Dynamic index time boosting</h4>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Index-time boosting is deprecated: support for this approach will be removed in Apache Lucene since version 7.</p>
</div>
<div class="paragraph">
<p>We recommend to use query-time boosting instead: see <a href="#search-query">Querying</a>.</p>
</div>
<div class="paragraph">
<p>If query-time boosting is not enough for your use case, you can implement dynamic boosting
using a <a href="#section-custom-similarity">custom similarity</a> (advanced use).</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>@Boost</code> annotation used in <a href="#section-boost-annotation">Static index time boosting</a> defines a static boost factor which
is independent of the state of of the indexed entity at runtime. However, there are use cases in
which the boost factor may depend on the actual state of the entity. In this case you can use the
<code>@DynamicBoost</code> annotation together with an accompanying custom <code>BoostStrategy</code>.</p>
</div>
<div id="example-dynamic-boosting" class="exampleblock">
<div class="title">Example 40. Dynamic boost example</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public enum PersonType {
    NORMAL,
    VIP
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed
@DynamicBoost(impl = VIPBoostStrategy.class)
public class Person {
    private PersonType type;

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public class VIPBoostStrategy implements BoostStrategy {
    public float defineBoost(Object value) {
        Person person = ( Person ) value;
        if ( person.getType().equals( PersonType.VIP ) ) {
            return 2.0f;
        }
        else {
            return 1.0f;
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In <a href="#example-dynamic-boosting">Dynamic boost example</a> a dynamic boost is defined on class level specifying
<code>VIPBoostStrategy</code> as implementation of the <code>BoostStrategy</code> interface to be used at indexing time. You
can place the <code>@DynamicBoost</code> either at class or field level. Depending on the placement of the
annotation either the whole entity is passed to the <code>defineBoost</code> method or just the annotated
field/property value. It&#8217;s up to you to cast the passed object to the correct type. In the example
all indexed values of a VIP person would be double as important as the values of a normal person.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The specified <code>BoostStrategy</code> implementation must define a public no-arg constructor.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Of course you can mix and match <code>@Boost</code> and <code>@DynamicBoost</code> annotations in your entity. All
defined boost factors are cumulative.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_analysis"><a class="anchor" href="#_analysis"></a>4.3. Analysis</h3>
<div class="paragraph">
<p>Analysis is the process of converting text into single terms (words) and can be considered as one
of the key features of a fulltext search engine. Lucene uses the concept of Analyzers to control
this process. In the following section we cover the multiple ways Hibernate Search offers to
configure the analyzers.</p>
</div>
<div class="sect3">
<h4 id="analyzer"><a class="anchor" href="#analyzer"></a>4.3.1. Default analyzer and analyzer by class</h4>
<div class="paragraph">
<p>The default analyzer class used to index tokenized fields is configurable through the
<code>hibernate.search.analyzer</code> property. The default value for this property is
<code>org.apache.lucene.analysis.standard.StandardAnalyzer</code>.</p>
</div>
<div class="paragraph">
<p>You can also define the analyzer class per entity, property and even per <code>@Field</code> (useful when
multiple fields are indexed from a single property).</p>
</div>
<div class="exampleblock">
<div class="title">Example 41. Different ways of using @Analyzer</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed
@Analyzer(impl = EntityAnalyzer.class)
public class MyEntity {
    @Id
    @GeneratedValue
    @DocumentId
    private Integer id;

    @Field
    private String name;

    @Field
    @Analyzer(impl = PropertyAnalyzer.class)
    private String summary;

    @Field(analyzer = @Analyzer(impl = FieldAnalyzer.class)
    private String body;

    ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In this example, <code>EntityAnalyzer</code> is used to index all tokenized properties (eg. <code>name</code>), except
<code>summary</code> and <code>body</code> which are indexed with <code>PropertyAnalyzer</code> and <code>FieldAnalyzer</code> respectively.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Mixing different analyzers in the same entity is most of the time a bad practice. It makes query
building more complex and results less predictable (for the novice), especially if you are using a
<code>QueryParser</code> (which uses the same analyzer for the whole query). As a rule of thumb, for any given
field the same analyzer should be used for indexing and querying.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="section-named-analyzers"><a class="anchor" href="#section-named-analyzers"></a>4.3.2. Named analyzers</h4>
<div class="paragraph">
<p>Analyzers can become quite complex to deal with. For this reason Hibernate Search introduces the
notion of analyzer definitions. An analyzer definition can be reused by many <code>@Analyzer</code> declarations
and is composed of:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a name: the unique string used to refer to the definition</p>
</li>
<li>
<p>a list of char filters: each char filter is responsible to pre-process input characters before the
tokenization. Char filters can add, change or remove characters; one common usage is for characters
normalization</p>
</li>
<li>
<p>a tokenizer: responsible for tokenizing the input stream into individual words</p>
</li>
<li>
<p>a list of filters: each filter is responsible to remove, modify or sometimes even add words into
the stream provided by the tokenizer</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This separation of tasks - a list of char filters, and a tokenizer followed by a list of filters -
allows for easy reuse of each individual component and let you build your customized analyzer in a
very flexible way (just like Lego). Generally speaking the char filters do some pre-processing in
the character input, then the Tokenizer starts the tokenizing process by turning the character input
into tokens which are then further processed by the TokenFilters. Hibernate Search supports this
infrastructure by utilizing the advanced analyzers provided by Lucene; this is often referred to as
the Analyzer Framework.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Filters and char filters are applied in the order they are mentioned in the analyzer definition.
Order matters!</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Some of the analyzers and filters will require additional dependencies. For example to use the
snowball stemmer you have to also include the <code>lucene-snowball</code> jar and for the
<code>PhoneticFilterFactory</code> you need the <a href="http://commons.apache.org/codec">commons-codec</a> jar. Your
distribution of Hibernate Search provides these dependencies in its <em>lib/optional</em> directory. Have a
look at <a href="#table-available-tokenizers">Example of available tokenizers</a> and <a href="#table-available-filters">Examples of available filters</a> to see which analyzers and
filters have additional dependencies</p>
</div>
<div class="paragraph">
<p>Prior to Hibernate Search 5 it was required to add the Apache Solr dependency to your project as
well; this is no longer required.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_analyzer_definition_through_annotations"><a class="anchor" href="#_analyzer_definition_through_annotations"></a>Analyzer definition through annotations</h5>
<div class="paragraph">
<p>The first way to define analyzers is by applying <code>@AnalyzerDef</code> annotations to your indexed classes.
Which class you choose to put the annotation on does not matter: the definitions are globally scoped,
so you will be able to reference them from any entity mapping.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s have a look at a concrete example now - <a href="#example-analyzer-def">Analyzer definition using the @AnalyzerDef annotation</a>. First a char filter is
defined by its factory. In our example, a mapping char filter is used, and will replace characters
in the input based on the rules specified in the mapping file. Next a tokenizer is defined. This
example uses the standard tokenizer. Last but not least, a list of filters is defined by their
factories. In our example, the StopFilter filter is built reading the dedicated words property file.
The filter is also expected to ignore case.</p>
</div>
<div id="example-analyzer-def" class="exampleblock">
<div class="title">Example 42. Analyzer definition using the @AnalyzerDef annotation</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@AnalyzerDef(name="customanalyzer",
  charFilters = {
    @CharFilterDef(factory = MappingCharFilterFactory.class, params = {
      @Parameter(name = "mapping",
        value = "org/hibernate/search/test/analyzer/mapping-chars.properties")
    })
  },
  tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
  filters = {
    @TokenFilterDef(factory = ASCIIFoldingFilterFactory.class),
    @TokenFilterDef(factory = LowerCaseFilterFactory.class),
    @TokenFilterDef(factory = StopFilterFactory.class, params = {
      @Parameter(name="words",
        value= "org/hibernate/search/test/analyzer/stoplist.properties" ),
      @Parameter(name="ignoreCase", value="true")
    })
})
public class Team {
    // ...
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="section-programmatic-analyzer-definition"><a class="anchor" href="#section-programmatic-analyzer-definition"></a>Programmatic analyzer definition</h5>
<div class="paragraph">
<p>The other way to define analyzers is programmatically.
You can of course use the <a href="#hsearch-mapping-programmaticapi">programmatic mapping API</a> to do so,
but an easier way may be to use the <code>hibernate.search.lucene.analysis_definition_provider</code>
configuration property.</p>
</div>
<div class="paragraph">
<p>This property can be set to the fully-qualified name of a class with a public, no-arg constructor in your application.
This class must either implement <code>org.hibernate.search.analyzer.definition.LuceneAnalysisDefinitionProvider</code> directly
or expose a <code>@Factory</code>-annotated method that returns such implementation.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>This feature is considered experimental.
The builder in particular could be altered in the future.</p>
</div>
</td>
</tr>
</table>
</div>
<div id="example-programmatic-analyzer-def" class="exampleblock">
<div class="title">Example 43. Analyzer definition using a LuceneAnalysisDefinitionProvider</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public static class CustomAnalyzerProvider implements LuceneAnalysisDefinitionProvider {
    @Override
    public void register(LuceneAnalyzerDefinitionRegistryBuilder builder) {
        builder
                .analyzer( "myAnalyzer" )
                        .tokenizer( StandardTokenizerFactory.class )
                        .charFilter( MappingCharFilterFactory.class )
                                .param( "mapping", "org/hibernate/search/test/analyzer/mapping-chars.properties" )
                        .tokenFilter( ASCIIFoldingFilterFactory.class )
                        .tokenFilter( LowerCaseFilterFactory.class )
                        .tokenFilter( StopFilterFactory.class )
                                .param( "mapping", "org/hibernate/search/test/analyzer/stoplist.properties" )
                                .param( "ignoreCase", "true" );
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_referencing_named_analyzers"><a class="anchor" href="#_referencing_named_analyzers"></a>Referencing named analyzers</h5>
<div class="paragraph">
<p>Once defined, an analyzer definition can be reused by an <code>@Analyzer</code> declaration as seen in
<a href="#example-referencing-analyzer-def">Referencing an analyzer by name</a>.</p>
</div>
<div id="example-referencing-analyzer-def" class="exampleblock">
<div class="title">Example 44. Referencing an analyzer by name</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed
@AnalyzerDef(name="customanalyzer", ... )
public class Team {
    @Id
    @DocumentId
    @GeneratedValue
    private Integer id;

    @Field
    private String name;

    @Field
    private String location;

    @Field
    @Analyzer(definition = "customanalyzer")
    private String description;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Analyzer definitions are also available by their name in the <code>SearchFactory</code>
which is quite useful when building queries.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Analyzer analyzer = fullTextSession.getSearchFactory().getAnalyzer("customanalyzer");</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Fields in queries should be analyzed with the same analyzer used to index the field so that they
speak a common "language": the same tokens are reused between the query and the indexing process.
This rule has some exceptions but is true most of the time. Respect it unless you know what you are
doing.</p>
</div>
</div>
<div class="sect4">
<h5 id="section-normalizers"><a class="anchor" href="#section-normalizers"></a>Normalizers</h5>
<div class="paragraph">
<p>Analyzers are great when you need to search in text documents,
but what if you want to sort the analyzed text?
Then you&#8217;re in for a bit of trouble, because analyzed text is multi-valued:
when indexing a book with the title <code>"Refactoring: Improving the Design of Existing Code"</code>,
the analyzed title is in fact the (unordered) set <code>{"refactoring", "improving", "design", "existing", "code"}</code>.
If you tried to sort on the title after such an analysis, any of those words could be used,
so your book could end up in the D&#8217;s (because of "design"), or in the R&#8217;s (because of "refactoring"),
or in the E&#8217;s, etc.</p>
</div>
<div class="paragraph">
<p>So in the end, you probably don&#8217;t want your fields to be tokenized when you sort on those fields.
Normalizers solve exactly this issue: they are analyzers, but without a tokenizer,
and with some runtime checks that prevent the analysis to produce multiple tokens,
thereby ensuring your sorts will always be consistent.</p>
</div>
<div class="paragraph">
<p>Hibernate Search provides normalizer equivalent for relevant analyzer annotations:
<code>@Normalizer</code>, <code>@NormalizerDef</code>, <code>@NormalizerDefs</code>.
As with analyzer, you can use implementations directly
(for instance <code>@Normalizer(impl = MyCollactionKeyAnalyzer.class)</code>)
or named normalizers (for instance <code>@Normalizer(definition = "myNormalizer")</code>
with <code>@NormalizerDef(filters = @TokenFilterDef(factory = LowerCaseFilterFactory.class))</code>.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>You cannot define a "class-level", "property-level", or a "default" normalizer:
each field requiring normalization must be assigned a normalizer explicitly
using <code>@Field.normalizer</code>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_available_analysis_components"><a class="anchor" href="#_available_analysis_components"></a>Available analysis components</h5>
<div class="paragraph">
<p>Apache Lucene comes with a lot of useful default char filters, tokenizers and filters.
You can find a complete list of char filter factories, tokenizer factories and filter factories at
<a href="http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters">http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters</a>.
Let&#8217;s check a few of them.</p>
</div>
<table id="table-available-char-filters" class="tableblock frame-all grid-all spread">
<caption class="title">Table 11. Example of available char filters</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Factory</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Parameters</th>
<th class="tableblock halign-left valign-top">Additional dependencies</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MappingCharFilterFactory</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Replaces one or more characters with one or more characters, based on
mappings specified in the resource file</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>mapping</code>: points to a resource file containing the mappings
using the format:
"" &#8658; "a"<br>
"" &#8658; "n"<br>
"" &#8658; "o"</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>lucene-analyzers-common</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HTMLStripCharFilterFactory</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Remove HTML standard tags, keeping the text</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">none</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>lucene-analyzers-common</code></p></td>
</tr>
</tbody>
</table>
<table id="table-available-tokenizers" class="tableblock frame-all grid-all spread">
<caption class="title">Table 12. Example of available tokenizers</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Factory</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Parameters</th>
<th class="tableblock halign-left valign-top">Additional dependencies</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>StandardTokenizerFactory</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Use the Lucene StandardTokenizer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">none</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>lucene-analyzers-common</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HTMLStripCharFilterFactory</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Remove HTML tags, keep the text and pass it to a
                <code>StandardTokenizer</code>.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">none</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>lucene-analyzers-common</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PatternTokenizerFactory</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Breaks text at the specified regular expression
                pattern.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pattern</code>: the regular expression to use for tokenizing
</p><p class="tableblock">group: says which pattern group to extract into tokens</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>lucene-analyzers-common</code></p></td>
</tr>
</tbody>
</table>
<table id="table-available-filters" class="tableblock frame-all grid-all spread">
<caption class="title">Table 13. Examples of available filters</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Factory</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Parameters</th>
<th class="tableblock halign-left valign-top">Additional dependencies</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>StandardFilterFactory</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Remove dots from acronyms and 's from words</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">none</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>lucene-analyzers-common</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LowerCaseFilterFactory</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Lowercases all words</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">none</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>lucene-analyzers-common</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>StopFilterFactory</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Remove words (tokens) matching a list of stop
                words</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>words</code>: points to a resource file containing the stop words
</p><p class="tableblock"><code>ignoreCase</code>: true if <code>case</code> should be ignore when comparing stop words, <code>false</code> otherwise</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>lucene-analyzers-common</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SnowballPorterFilterFactory</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reduces a word to it&#8217;s root in a given language. (eg.
                protect, protects, protection share the same root). Using such
                a filter allows searches matching related words.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>language</code>: Danish, Dutch, English,
                Finnish, French, German, Italian, Norwegian, Portuguese,
                Russian, Spanish, Swedish and a few more</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>lucene-analyzers-common</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ASCIIFoldingFilterFactory</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Remove accents for languages like French</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">none</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>lucene-analyzers-common</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PhoneticFilterFactory</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Inserts phonetically similar tokens into the token
                stream</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>encoder</code>: One of <code>DoubleMetaphone</code>, <code>Metaphone</code>, <code>Soundex</code> or <code>RefinedSoundex</code>
</p><p class="tableblock"><code>inject</code>: true will add tokens to the stream, false will replace the existing token
</p><p class="tableblock"><code>maxCodeLength</code>: sets the maximum length of the code to be generated. Supported only for Metaphone and DoubleMetaphone encodings</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>lucene-analyzers-phonetic</code> and
                <code>commons-codec</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CollationKeyFilterFactory</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Converts each token into its
                <code>java.text.CollationKey</code>, and then
                encodes the <code>CollationKey</code> with
                <code>IndexableBinaryStringTools</code>, to allow it
                to be stored as an index term.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>custom</code>, <code>language</code>,
                <code>country</code>, <code>variant</code>,
                <code>strength</code>, <code>decomposition</code>
                see Lucene&#8217;s CollationKeyFilter javadocs for more info</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>lucene-analyzers-common</code> and <code>commons-io</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>We recommend to check out the implementations of <code>org.apache.lucene.analysis.util.TokenizerFactory</code>
and <code>org.apache.lucene.analysis.util.TokenFilterFactory</code> in your IDE to see the implementations
available.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_dynamic_analyzer_selection"><a class="anchor" href="#_dynamic_analyzer_selection"></a>4.3.3. Dynamic analyzer selection</h4>
<div class="paragraph">
<p>So far all the introduced ways to specify an analyzer were static. However, there are use cases
where it is useful to select an analyzer depending on the current state of the entity to be indexed,
for example in a multilingual applications. For an <code>BlogEntry</code> class for example the analyzer could
depend on the language property of the entry. Depending on this property the correct language
specific stemmer should be chosen to index the actual text.</p>
</div>
<div class="paragraph">
<p>To enable this dynamic analyzer selection Hibernate Search introduces the <code>@AnalyzerDiscriminator</code>
annotation. <a href="#example-analyzer-discriminator">Usage of <code>@AnalyzerDiscriminator</code></a> demonstrates the usage of this annotation.</p>
</div>
<div id="example-analyzer-discriminator" class="exampleblock">
<div class="title">Example 45. Usage of <code>@AnalyzerDiscriminator</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed
@AnalyzerDef(name = "en",
  tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
  filters = {
    @TokenFilterDef(factory = LowerCaseFilterFactory.class),
    @TokenFilterDef(factory = EnglishPorterFilterFactory.class
    )
  })
@AnalyzerDef(name = "de",
  tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
  filters = {
    @TokenFilterDef(factory = LowerCaseFilterFactory.class),
    @TokenFilterDef(factory = GermanStemFilterFactory.class)
  })
public class BlogEntry {

    @Id
    @GeneratedValue
    @DocumentId
    private Integer id;

    @Field
    @AnalyzerDiscriminator(impl = LanguageDiscriminator.class)
    private String language;

    @Field
    private String text;

    private Set&lt;BlogEntry&gt; references;

    // standard getter/setter
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public class LanguageDiscriminator implements Discriminator {

    public String getAnalyzerDefinitionName(Object value, Object entity, String field) {
        if ( value == null || !( entity instanceof Article ) ) {
            return null;
        }
        return (String) value;

    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The prerequisite for using <code>@AnalyzerDiscriminator</code> is that all analyzers which are going to be used
dynamically are predefined as <a href="#section-named-analyzers">named analyzers</a>. If this is the case, one can place the
<code>@AnalyzerDiscriminator</code> annotation either on the class or on a specific property of the entity for
which to dynamically select an analyzer. Via the <code>impl</code> parameter of the <code>@AnalyzerDiscriminator</code> you
specify a concrete implementation of the <code>Discriminator</code> interface. It is up to you to provide an
implementation for this interface. The only method you have to implement is
<code>getAnalyzerDefinitionName()</code> which gets called for each field added to the Lucene document. The
entity which is getting indexed is also passed to the interface method. The <code>value</code> parameter is
only set if the <code>AnalyzerDiscriminator</code> is placed on property level instead of class level. In this
case the value represents the current value of this property.</p>
</div>
<div class="paragraph">
<p>An implementation of the <code>Discriminator</code> interface has to return the name of an existing analyzer
definition or null if the default analyzer should not be overridden.
<a href="#example-analyzer-discriminator">Usage of <code>@AnalyzerDiscriminator</code></a> assumes that the language parameter is either 'de' or 'en' which matches the
name of an analyzer.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>There is no equivalent of <code>@AnalyzerDiscriminator</code> for <a href="#section-normalizers">normalizers</a>, at least for now.
See <a href="https://hibernate.atlassian.net/browse/HSEARCH-2738">HSEARCH-2738</a>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="analyzer-retrievinganalyzer"><a class="anchor" href="#analyzer-retrievinganalyzer"></a>4.3.4. Retrieving an analyzer</h4>
<div class="paragraph">
<p>In some situations retrieving analyzers can be handy. For example, if your domain model makes use of
multiple analyzers (maybe to benefit from stemming, use phonetic approximation and so on), you need
to make sure to use the same analyzers when you build your query.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>This rule can be broken but you need a good reason for it. If you are unsure, use the same
analyzers. If you use the Hibernate Search query DSL (see <a href="#search-query-querydsl">Building a Lucene query with the Hibernate Search query DSL</a>), you don&#8217;t have
to think about it. The query DSL does use the right analyzer transparently for you.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Whether you are using the Lucene programmatic API or the Lucene query parser, you can retrieve the
scoped analyzer for a given entity. A scoped analyzer is an analyzer which applies the right
analyzers depending on the field indexed. Remember, multiple analyzers can be defined on a given
entity each one working on an individual field. A scoped analyzer unifies all these analyzers into a
context-aware analyzer. While the theory seems a bit complex, using the right analyzer in a query is
very easy.</p>
</div>
<div class="exampleblock">
<div class="title">Example 46. Using the scoped analyzer when building a full-text query</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">org.apache.lucene.queryparser.classic.QueryParser parser = new QueryParser(
    "title",
    fullTextSession.getSearchFactory().getAnalyzer( Song.class )
);

org.apache.lucene.search.Query luceneQuery =
    parser.parse( "title:sky Or title_stemmed:diamond" );

org.hibernate.Query fullTextQuery =
    fullTextSession.createFullTextQuery( luceneQuery, Song.class );

List result = fullTextQuery.list(); //return a list of managed objects</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the example above, the song title is indexed in two fields: the standard analyzer is used in the
field <code>title</code> and a stemming analyzer is used in the field <code>title_stemmed</code>. By using the
analyzer provided by the search factory, the query uses the appropriate analyzer depending on the
field targeted.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>You can also retrieve <a href="#section-named-analyzers">named analyzers</a> by their definition name using
<code>searchFactory.getAnalyzer(String)</code>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="search-mapping-bridge"><a class="anchor" href="#search-mapping-bridge"></a>4.4. Bridges</h3>
<div class="paragraph">
<p>When discussing the basic mapping for an entity one important fact was so far disregarded. In Lucene
all index fields have to be represented as strings. All entity properties annotated with <code>@Field</code>
have to be converted to strings to be indexed. The reason we have not mentioned it so far is, that
for most of your properties Hibernate Search does the translation job for you thanks to a set of
built-in bridges. However, in some cases you need a more fine grained control over the translation
process.</p>
</div>
<div class="sect3">
<h4 id="section-built-in-bridges"><a class="anchor" href="#section-built-in-bridges"></a>4.4.1. Built-in bridges</h4>
<div class="paragraph">
<p>Hibernate Search comes bundled with a set of built-in bridges between a Java property type and its
full text representation.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>null</code></dt>
<dd>
<p>Per default <code>null</code> elements are not indexed. Lucene does not support <code>null</code> elements.
However, in some situation it can be useful to insert a custom token representing the <code>null</code> value.
See <a href="#field-annotation">@Field</a> for more information.</p>
</dd>
<dt class="hdlist1"><code>java.lang.String</code></dt>
<dd>
<p>Strings are indexed as they are.</p>
</dd>
<dt class="hdlist1"><code>boolean</code>, <code>Boolean</code></dt>
<dd>
<p>Are converted into their string representation and indexed.</p>
</dd>
<dt class="hdlist1"><code>char</code>, <code>Character</code></dt>
<dd>
<p>Are converted into their string representation and indexed.</p>
</dd>
<dt class="hdlist1"><code>int</code>, <code>Integer</code>, <code>long</code>, <code>Long</code>, <code>float</code>, <code>Float</code>, <code>double</code>, <code>Double</code></dt>
<dd>
<p>Are per default indexed numerically using a <a href="http://en.wikipedia.org/wiki/Trie">Trie structure</a> which
allows for efficient range queries and sorting, resulting in better query response times.
You need to use a <code>NumericRangeQuery</code> to search for values. See also <a href="#field-annotation">@Field</a> and
<a href="#numeric-field-annotation">@NumericField</a>.</p>
</dd>
</dl>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Prior to Hibernate Search 5, numeric field encoding was only chosen if explicitly requested via <code>@NumericField</code>.
As of Hibernate Search 5, this encoding is automatically chosen for the numeric types mentioned above.</p>
</div>
<div class="paragraph">
<p>To avoid numeric encoding you can explicitly specify a non numeric field bridge via <code>@Field.bridge</code> or <code>@FieldBridge</code>.
The package <code>org.hibernate.search.bridge.builtin</code> contains a set of bridges which encode numbers as strings,
for example <code>org.hibernate.search.bridge.builtin.IntegerBridge</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>byte</code>, <code>Byte</code>, <code>short</code>, <code>Short</code></dt>
<dd>
<p>Are converted into their string representation and indexed.
They will only be encoded in numeric fields if explicitly marked with the <code>@NumericField</code> annotation
(see <a href="#numeric-field-annotation">@NumericField</a>).</p>
</dd>
<dt class="hdlist1"><code>BigInteger</code>, <code>BigDecimal</code></dt>
<dd>
<p>Are converted into their string representation and indexed.
Note that in this form the values cannot be compared by Lucene using for example a <code>TermRangeQuery</code>.
For that the string representation would need to be padded. An alternative using numeric encoding
with a potential loss in precision can be seen in <a href="#example-custom-numericfieldbridge">Defining a custom NumericFieldBridge for <code>BigDecimal</code></a>.</p>
</dd>
<dt class="hdlist1"><code>java.util.Date</code>, <code>java.util.Calendar</code></dt>
<dd>
<p>Dates are indexed as <code>long</code> value representing the number
of milliseconds since <em>January 1, 1970, 00:00:00 GMT</em>. You shouldn&#8217;t really bother with the
internal format. It is important, however, to query a numerically indexed date via a <code>NumericRangeQuery</code>.</p>
<div class="paragraph">
<p>Usually, storing the date up to the millisecond is not necessary.
<code>@DateBridge</code> and <code>@CalendarBridge</code> allow to define the appropriate resolution you are willing to store in the index.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed
public class Meeting {
    @Field(analyze=Analyze.NO)
    @DateBridge(resolution=Resolution.MINUTE)
    private Date date;
    // ...</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can also choose to encode the date as string using the <code>encoding=EncodingType.STRING</code>
of <code>@DateBridge</code> and <code>@CalendarBridge</code>.
In this case the dates are stored in the format <em>yyyyMMddHHmmssSSS</em> (using GMT time).</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The default date bridge uses Lucene&#8217;s <code>DateTools</code> to convert from <code>Date</code> or <code>Calendar</code> to its indexed
value. This means that all dates are expressed in GMT time. If your requirements are to store dates
in a fixed time zone you have to implement a custom date bridge.</p>
</div>
</td>
</tr>
</table>
</div>
</dd>
<dt class="hdlist1"><code>java.time.Year</code></dt>
<dd>
<p>converts the year to the integer representation.</p>
</dd>
<dt class="hdlist1"><code>java.time.Duration</code></dt>
<dd>
<p>converts the duration to the total length in nanoseconds.</p>
</dd>
<dt class="hdlist1"><code>java.time.Instant</code></dt>
<dd>
<p>converts the instant to the number of milliseconds from Epoch.
Note that these values are indexed with a precision to the millisecond.</p>
</dd>
</dl>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Note that it must be possible to convert the <code>Instant</code> or the <code>Duration</code> to a <code>Long</code>.
If these values are too big or too small an exception is thrown.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>LocalDate</code>, <code>LocalTime</code>, <code>LocalDateTime</code>, <code>MonthDay</code>, <code>OffsetDateTime</code>, <code>OffsetTime</code>, <code>Period</code>, <code>YearMonth</code>, <code>ZoneDateTime</code>, <code>ZoneId</code>, <code>ZoneOffset</code></dt>
<dd>
<p>the bridges
for these classes in the <code>java.time</code> package store the values as string padded with 0 when required to allow sorting.</p>
</dd>
<dt class="hdlist1"><code>java.net.URI</code>, <code>java.net.URL</code></dt>
<dd>
<p><code>URI</code> and <code>URL</code> are converted to their string representation</p>
</dd>
<dt class="hdlist1"><code>java.lang.Class</code></dt>
<dd>
<p>Classes are converted to their fully qualified class name. The thread context
classloader is used when the class is rehydrated</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_tika_bridge"><a class="anchor" href="#_tika_bridge"></a>4.4.2. Tika bridge</h4>
<div class="paragraph">
<p>Hibernate Search allows you to extract text from various document types using the built-in
<code>TikaBridge</code> which utilizes <a href="http://tika.apache.org">Apache Tika</a> to extract text and metadata
from the provided documents. The <code>@TikaBridge</code> annotation can be used with <code>String</code>, <code>URI</code>, <code>byte[]</code> or
<code>java.sql.Blob</code> properties. In the case of <code>String</code> and <code>URI</code> the bridge interprets the values are file
paths and tries to open a file to parse the document. In the case of <code>byte[]</code> and <code>Blob</code> the values are
directly passed to Tika for parsing.</p>
</div>
<div class="paragraph">
<p>Tika uses metadata as in- and output of the parsing process and it also allows to provide additional
context information. This process is described in
<a href="http://tika.apache.org/1.1/parser.html#apiorgapachetikametadataMetadata.html">Parser interface</a>.
The Hibernate Search Tika bridge allows you to make use of these additional
configuration options by providing two interfaces in conjunction with <code>TikaBridge</code>. The first
interface is the <code>TikaParseContextProvider</code>. It allows you to create a custom <code>ParseContext</code> for the
document parsing. The second interface is <code>TikaMetadataProcessor</code> which has two methods -
<code>prepareMetadata()</code> and <code>set(String, Object, Document, LuceneOptions, Metadata metadata)</code>. The former
allows to add additional metadata to the parsing process (for example the file name) and the latter
allows you to index metadata discovered during the parsing process.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Sortable fields with Tika</div>
<div class="paragraph">
<p>If you want to add multiple fields in your <code>TikaMetadataProcessor</code>, and also want to make those
fields sortable, you should make your processor implement the <code>MetadataProvidingTikaMetadataProcessor</code>.
This is similar to implementing <code>MetadataProvidingFieldBridge</code> on a regular field bridge: see <a href="#sortablefield-annotation">@SortableField</a>.</p>
</div>
<div class="paragraph">
<p>Like <code>MetadataProvidingFieldBridge</code>, the <code>MetadataProvidingTikaMetadataProcessor</code> contract is under active development and considered experimental at this time. It may be altered in future revisions, e.g. by adding further methods, thus breaking existing implementations.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>TikaParseContextProvider</code> as well as <code>TikaMetadataProcessor</code> implementation classes can both be
specified as parameters on the <code>TikaBridge</code> annotation.</p>
</div>
<div id="example-tika-mapping" class="exampleblock">
<div class="title">Example 47. Example mapping with Apache Tika</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed
public class Song {
    @Id
    @GeneratedValue
    long id;

    @Field
    @TikaBridge(metadataProcessor = Mp3TikaMetadataProcessor.class)
    String mp3FileName;

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">QueryBuilder queryBuilder = fullTextSession.getSearchFactory()
    .buildQueryBuilder()
    .forEntity( Song.class )
    .get();
Query query = queryBuilder.keyword()
    .onField( "mp3FileName" )
    .ignoreFieldBridge() //mandatory
    .matching( "Apes" )
    .createQuery();
List result = fullTextSession.createFullTextQuery( query ).list();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the <a href="#example-tika-mapping">Example mapping with Apache Tika</a> the property <code>mp3FileName</code> represents a path to an MP3 file; the
headers of this file will be indexed and so the performed query will be able to match the MP3
metadata.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>TikaBridge</code> does not implement <code>TwoWayFieldBridge</code>: queries built using the DSL (as in the
<a href="#example-tika-mapping">Example mapping with Apache Tika</a>) need to explicitly enable the option ignoreFieldBridge().</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="section-custom-bridges"><a class="anchor" href="#section-custom-bridges"></a>4.4.3. Custom bridges</h4>
<div class="paragraph">
<p>Sometimes, the built-in bridges of Hibernate Search do not cover some of your property types, or the
<code>String</code> representation used by the bridge does not meet your requirements. The following paragraphs
describe several solutions to this problem.</p>
</div>
<div class="sect4">
<h5 id="_stringbridge"><a class="anchor" href="#_stringbridge"></a>StringBridge</h5>
<div class="paragraph">
<p>The simplest custom solution is to give Hibernate Search an implementation of your expected <code>Object</code>
to <code>String</code> bridge. To do so you need to implement the <code>org.hibernate.search.bridge.StringBridge</code>
interface. All implementations have to be thread-safe as they are used concurrently.</p>
</div>
<div id="example-custom-string-bridge" class="exampleblock">
<div class="title">Example 48. Custom <code>StringBridge</code> implementation</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">/**
 * Padding Integer bridge.
 * All numbers will be padded with 0 to match 5 digits
 *
 * @author Emmanuel Bernard
 */
public class PaddedIntegerBridge implements StringBridge {

    private int padding = 5;

    public String objectToString(Object object) {
        String rawInteger = ((Integer) object).toString();
        if (rawInteger.length() &gt; padding)
            throw new IllegalArgumentException("Number too big to be padded");
        StringBuilder paddedInteger = new StringBuilder();
        for (int padIndex = rawInteger.length(); padIndex &lt; padding; padIndex++) {
            paddedInteger.append('0');
        }
        return paddedInteger.append( rawInteger ).toString();
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Given the string bridge defined in <a href="#example-custom-string-bridge">Custom <code>StringBridge</code> implementation</a>, any property or field can use
this bridge thanks to the <code>@FieldBridge</code> annotation:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@FieldBridge(impl = PaddedIntegerBridge.class)
private Integer length;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_parameterized_bridge"><a class="anchor" href="#_parameterized_bridge"></a>Parameterized bridge</h6>
<div class="paragraph">
<p>Parameters can also be passed to the bridge implementation making it more flexible.
<a href="#example-passing-bridge-parameters">Passing parameters to your bridge implementation</a> implements a <code>ParameterizedBridge</code> interface and parameters are
passed through the <code>@FieldBridge</code> annotation.</p>
</div>
<div id="example-passing-bridge-parameters" class="exampleblock">
<div class="title">Example 49. Passing parameters to your bridge implementation</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public class PaddedIntegerBridge implements StringBridge, ParameterizedBridge {

    public static String PADDING_PROPERTY = "padding";
    private int padding = 5; //default

    public void setParameterValues(Map&lt;String,String&gt; parameters) {
        String padding = parameters.get( PADDING_PROPERTY );
        if (padding != null) this.padding = Integer.parseInt( padding );
    }

    public String objectToString(Object object) {
        String rawInteger = ((Integer) object).toString();
        if (rawInteger.length() &gt; padding)
            throw new IllegalArgumentException("Number too big to be padded");
        StringBuilder paddedInteger = new StringBuilder( );
        for (int padIndex = rawInteger.length(); padIndex &lt; padding; padIndex++) {
            paddedInteger.append('0');
        }
        return paddedInteger.append(rawInteger).toString();
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">//on the property:
@FieldBridge(impl = PaddedIntegerBridge.class,
             params = @Parameter(name="padding", value="10")
            )
private Integer length;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>ParameterizedBridge</code> interface can be implemented by <code>StringBridge</code>, <code>TwoWayStringBridge</code>,
<code>FieldBridge</code> implementations.</p>
</div>
<div class="paragraph">
<p>All implementations have to be thread-safe, but the parameters are set during initialization and no
special care is required at this stage.</p>
</div>
</div>
<div class="sect5">
<h6 id="_type_aware_bridge"><a class="anchor" href="#_type_aware_bridge"></a>Type aware bridge</h6>
<div class="paragraph">
<p>It is sometimes useful to get the type the bridge is applied on:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the return type of the property for field/getter-level bridges</p>
</li>
<li>
<p>the class type for class-level bridges</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>An example is a bridge that deals with enums in a custom fashion but needs to access the actual enum
type. Any bridge implementing <code>AppliedOnTypeAwareBridge</code> will get the type the bridge is applied on
injected. Like parameters, the type injected needs no particular care with regard to thread-safety.</p>
</div>
</div>
<div class="sect5">
<h6 id="_two_way_bridge"><a class="anchor" href="#_two_way_bridge"></a>Two-way bridge</h6>
<div class="paragraph">
<p>If you expect to use your bridge implementation on an id property (ie annotated with <code>@DocumentId</code>
), you need to use a slightly extended version of <code>StringBridge</code> named <code>TwoWayStringBridge</code>. Hibernate
Search needs to read the string representation of the identifier and generate the object out of it.
There is no difference in the way the <code>@FieldBridge</code> annotation is used.</p>
</div>
<div class="exampleblock">
<div class="title">Example 50. Implementing a <code>TwoWayStringBridge</code> usable for id properties</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public class PaddedIntegerBridge implements TwoWayStringBridge, ParameterizedBridge {

    public static String PADDING_PROPERTY = "padding";
    private int padding = 5; //default

    public void setParameterValues(Map parameters) {
        Object padding = parameters.get(PADDING_PROPERTY);
        if (padding != null) this.padding = (Integer) padding;
    }

    public String objectToString(Object object) {
        String rawInteger = ((Integer) object).toString();
        if (rawInteger.length() &gt; padding)
            throw new IllegalArgumentException("Number too big to be padded");
        StringBuilder paddedInteger = new StringBuilder();
        for (int padIndex = rawInteger.length(); padIndex &lt; padding ; padIndex++) {
            paddedInteger.append('0');
        }
        return paddedInteger.append(rawInteger).toString();
    }

    public Object stringToObject(String stringValue) {
        return new Integer(stringValue);
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">//On an id property:
@DocumentId
@FieldBridge(impl = PaddedIntegerBridge.class,
             params = @Parameter(name="padding", value="10")
private Integer id;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>It is important for the two-way process to be idempotent
(ie <code>object = stringToObject(objectToString( object ) )</code> ).</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="section-filed-bridge"><a class="anchor" href="#section-filed-bridge"></a>FieldBridge</h5>
<div class="paragraph">
<p>Some use cases require more than a simple object to string translation when mapping a property to a
Lucene index. To give you the greatest possible flexibility you can also implement a bridge as a
<code>FieldBridge</code>. This interface gives you a property value and let you map it the way you want in your
Lucene <code>Document</code>. You can for example store a property in two different document fields. The
interface is very similar in its concept to the Hibernate ORM <code>UserTypes</code>.</p>
</div>
<div id="example-field-bridge" class="exampleblock">
<div class="title">Example 51. Implementing the FieldBridge interface</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">/**
 * Store the date in 3 different fields - year, month, day - to ease the creation of RangeQuery per
 * year, month or day (eg get all the elements of December for the last 5 years).
 * @author Emmanuel Bernard
 */
public class DateSplitBridge implements FieldBridge {
    private final static TimeZone GMT = TimeZone.getTimeZone("GMT");

    public void set(String name, Object value, Document document,
                    LuceneOptions luceneOptions) {
        Date date = (Date) value;
        Calendar cal = GregorianCalendar.getInstance(GMT);
        cal.setTime(date);
        int year = cal.get(Calendar.YEAR);
        int month = cal.get(Calendar.MONTH) + 1;
        int day = cal.get(Calendar.DAY_OF_MONTH);

        // set year
        luceneOptions.addFieldToDocument(
            name + ".year",
            String.valueOf( year ),
            document );

        // set month and pad it if needed
        luceneOptions.addFieldToDocument(
            name + ".month",
            month &lt; 10 ? "0" : "" + String.valueOf( month ),
            document );

        // set day and pad it if needed
        luceneOptions.addFieldToDocument(
            name + ".day",
            day &lt; 10 ? "0" : "" + String.valueOf( day ),
            document );
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">//property
@FieldBridge(impl = DateSplitBridge.class)
private Date date;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In <a href="#example-field-bridge">Implementing the FieldBridge interface</a> the fields are not added directly to <code>Document</code>. Instead the addition is
delegated to the <code>LuceneOptions</code> helper; this helper will apply the options you have selected on
<code>@Field</code>, like <code>Store</code> or <code>TermVector</code>, or apply the chosen <code>@Boost</code> value. It is especially useful
to encapsulate the complexity of <code>COMPRESS</code> implementations. Even though it is recommended to
delegate to <code>LuceneOptions</code> to add fields to the <code>Document</code>, nothing stops you from editing the
<code>Document</code> directly and ignore the LuceneOptions in case you need to.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Classes like <code>LuceneOptions</code> are created to shield your application from changes in Lucene API and
simplify your code. Use them if you can, but if you need more flexibility you&#8217;re not required to.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_classbridge"><a class="anchor" href="#_classbridge"></a>ClassBridge</h5>
<div class="paragraph">
<p>It is sometimes useful to combine more than one property of a given entity and index this
combination in a specific way into the Lucene index. The <code>@ClassBridge</code> and <code>@ClassBridges</code>
annotations can be defined at class level (as opposed to the property level). In this case the
custom field bridge implementation receives the entity instance as the value parameter instead of a
particular property. Though not shown in <a href="#example-class-bridge">Implementing a class bridge</a>, <code>@ClassBridge</code> supports the
<code>termVector</code> attribute discussed in section <a href="#basic-mapping">Basic mapping</a>.</p>
</div>
<div id="example-class-bridge" class="exampleblock">
<div class="title">Example 52. Implementing a class bridge</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed
@ClassBridge(name="branchnetwork",
             store=Store.YES,
             impl = CatFieldsClassBridge.class,
             params = @Parameter( name="sepChar", value=" " ) )
public class Department {
    private int id;
    private String network;
    private String branchHead;
    private String branch;
    private Integer maxEmployees
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public class CatFieldsClassBridge implements FieldBridge, ParameterizedBridge {
    private String sepChar;

    public void setParameterValues(Map parameters) {
        this.sepChar = (String) parameters.get( "sepChar" );
    }

    public void set(
        String name, Object value, Document document, LuceneOptions luceneOptions) {
        // In this particular class the name of the new field was passed
        // from the name field of the ClassBridge Annotation. This is not
        // a requirement. It just works that way in this instance. The
        // actual name could be supplied by hard coding it below.
        Department dep = (Department) value;
        String fieldValue1 = dep.getBranch();
        if ( fieldValue1 == null ) {
            fieldValue1 = "";
        }
        String fieldValue2 = dep.getNetwork();
        if ( fieldValue2 == null ) {
            fieldValue2 = "";
        }
        String fieldValue = fieldValue1 + sepChar + fieldValue2;
        Field field = new Field( name, fieldValue, luceneOptions.getStore(),
            luceneOptions.getIndex(), luceneOptions.getTermVector() );
        field.setBoost( luceneOptions.getBoost() );
        document.add( field );
   }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In this example, the particular <code>CatFieldsClassBridge</code> is applied to the <code>department</code> instance, the
field bridge then concatenate both branch and network and index the concatenation.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_bridgeprovider_associate_a_bridge_to_a_given_return_type"><a class="anchor" href="#_bridgeprovider_associate_a_bridge_to_a_given_return_type"></a>4.4.4. BridgeProvider: associate a bridge to a given return type</h4>
<div class="paragraph">
<p>Custom field bridges are very flexible, but it can be tedious and error prone to apply the same
custom <code>@FieldBridge</code> annotation every time a property of a given type is present in your domain
model. That is what BridgeProviders are for.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s imagine that you have a type <code>Currency</code> in your application and that you want to apply your very
own <code>CurrencyFieldBridge</code> every time an indexed property returns <code>Currency</code>. You can do it the hard way:</p>
</div>
<div class="exampleblock">
<div class="title">Example 53. Applying the same <code>@FieldBridge</code> for a type the hard way</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity @Indexed
public class User {
    @FieldBridge(impl=CurrencyFieldBridge.class)
    public Currency getDefaultCurrency();

    // ...
}

@Entity @Indexed
public class Account {
    @FieldBridge(impl=CurrencyFieldBridge.class)
    public Currency getCurrency();

    // ...
}

// continue to add @FieldBridge(impl=CurrencyFieldBridge.class) everywhere Currency is</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Or you can write your own <code>BridgeProvider</code> implementation for <code>Currency</code>.</p>
</div>
<div class="exampleblock">
<div class="title">Example 54. Writing a <code>BridgeProvider</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public class CurrencyBridgeProvider implements BridgeProvider {

    //needs a default no-arg constructor

    @Override
    public FieldBridge provideFieldBridge(BridgeContext bridgeProviderContext) {
        if ( bridgeProviderContext.getReturnType().equals( Currency.class ) ) {
            return CurrencyFieldBridge.INSTANCE;
        }
        return null;
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre># service file named META-INF/services/org.hibernate.search.bridge.spi.BridgeProvider
com.acme.myapps.hibernatesearch.CurrencyBridgeProvider</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You need to implement <code>BridgeProvider</code> and create a service file named
<em>META-INF/services/org.hibernate.search.bridge.spi.BridgeProvider</em>. This file must contain the fully
qualified class name(s) of the <code>BridgeProvider</code> implementations. This is the classic Service Loader
discovery mechanism.</p>
</div>
<div class="paragraph">
<p>Now, any indexed property of type <code>Currency</code> will use <code>CurrencyFieldBridge</code> automatically.</p>
</div>
<div class="exampleblock">
<div class="title">Example 55. An explicit <code>@FieldBrige</code> is no longer needed</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity @Indexed
public class User {

    @Field
    public Currency getDefaultCurrency();

    // ...
}

@Entity @Indexed
public class Account {

    @Field
    public Currency getCurrency();

    // ...
}

//CurrencyFieldBridge is applied automatically everywhere Currency is found on an indexed property</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>A few more things you need to know:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a <code>BridgeProvider</code> must have a no-arg constructor</p>
</li>
<li>
<p>if a <code>BridgeProvider</code> only returns <code>FieldBridge</code> instances if it is meaningful for the calling context.
Null otherwise. In our example, the return type must be <code>Currency</code> to be meaningful to our provider.</p>
</li>
<li>
<p>if two or more bridge providers return a <code>FieldBridge</code> instance for a given return type, an exception
will be raised.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">What is a calling context</div>
<div class="paragraph">
<p>A calling context is represented by the <code>BridgeProviderContext</code> object and represents the environment for
which we are looking for a bridge. <code>BridgeProviderContext</code> gives access to the return type of the indexed
property as well as the <code>ServiceManager</code> which gives access to the <code>ClassLoaderService</code> for everything
class loader related.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">ClassLoaderService classLoaderService = serviceManager.getClassLoaderService();
CustomBridge cb = classLoaderService.classForName( "com.package.CustomBridge" );</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="search-mapping-indexinginterceptor"><a class="anchor" href="#search-mapping-indexinginterceptor"></a>4.5. Conditional indexing</h3>
<div class="paragraph">
<p>In some situations, you want to index an entity only when it is in a given state, for example:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>only index blog entries marked as published</p>
</li>
<li>
<p>no longer index invoices when they are marked archived</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This serves both functional and technical needs. You don&#8217;t want your blog readers to find your draft
entries and filtering them off the query is a bit annoying. Very few of your entities are actually
required to be indexed and you want to limit indexing overhead and keep indexes small and fast.</p>
</div>
<div class="paragraph">
<p>Hibernate Search lets you intercept entity indexing operations and override them. It is quite
simple:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Write an <code>EntityIndexingInterceptor</code> class with your entity state based logic</p>
</li>
<li>
<p>Mark the entity as intercepted by this implementation</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Let&#8217;s look at the blog example at <a href="#example-search-mapping-indexinginterceptor-blog">Index blog entries only when they are published and remove them when they are in a different state</a></p>
</div>
<div id="example-search-mapping-indexinginterceptor-blog" class="exampleblock">
<div class="title">Example 56. Index blog entries only when they are published and remove them when they are in a different state</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">/**
 * Only index blog when it is in published state
 *
 * @author Emmanuel Bernard &lt;emmanuel@hibernate.org&gt;
 */
public class IndexWhenPublishedInterceptor implements EntityIndexingInterceptor&lt;Blog&gt; {
    @Override
    public IndexingOverride onAdd(Blog entity) {
        if (entity.getStatus() == BlogStatus.PUBLISHED) {
            return IndexingOverride.APPLY_DEFAULT;
        }
        return IndexingOverride.SKIP;
    }

    @Override
    public IndexingOverride onUpdate(Blog entity) {
        if (entity.getStatus() == BlogStatus.PUBLISHED) {
            return IndexingOverride.UPDATE;
        }
        return IndexingOverride.REMOVE;
    }

    @Override
    public IndexingOverride onDelete(Blog entity) {
        return IndexingOverride.APPLY_DEFAULT;
    }

    @Override
    public IndexingOverride onCollectionUpdate(Blog entity) {
        return onUpdate(entity);
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed(interceptor=IndexWhenPublishedInterceptor.class)
public class Blog {
    @Id
    @GeneratedValue
    public Integer getId() { return id; }
    public void setId(Integer id) {  this.id = id; }
    private Integer id;

    @Field
    public String getTitle() { return title; }
    public void setTitle(String title) {  this.title = title; }
    private String title;

    public BlogStatus getStatus() { return status; }
    public void setStatus(BlogStatus status) {  this.status = status; }
    private BlogStatus status;

    // ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>We mark the <code>Blog</code> entity with <code>@Indexed.interceptor</code>. As you can see, <code>IndexWhenPublishedInterceptor</code>
implements <code>EntityIndexingInterceptor</code> and accepts <code>Blog</code> entities (it could have accepted super classes
as well - for example <code>Object</code> if you create a generic interceptor.</p>
</div>
<div class="paragraph">
<p>You can react to several planned indexing events:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>when an entity is added to your datastore</p>
</li>
<li>
<p>when an entity is updated in your datastore</p>
</li>
<li>
<p>when an entity is deleted from your datastore</p>
</li>
<li>
<p>when a collection own by this entity is updated in your datastore</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For each occurring event you can respond with one of the following actions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>APPLY_DEFAULT</code>: that&#8217;s the basic operation that lets Hibernate Search update the index as
expected - creating, updating or removing the document</p>
</li>
<li>
<p><code>SKIP</code>: ask Hibernate Search to not do anything to the index for this event - data will not be
created, updated or removed from the index in any way</p>
</li>
<li>
<p><code>REMOVE</code>: ask Hibernate Search to remove indexing data about this entity - you can safely ask
for <code>REMOVE</code> even if the entity has not yet been indexed</p>
</li>
<li>
<p><code>UPDATE</code>: ask Hibernate Search to either index or update the index for this entity - it is safe
to ask for <code>UPDATE</code> even if the entity has never been indexed</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Be careful, not every combination makes sense: for example, asking to <code>UPDATE</code> the index upon
onDelete. Note that you could ask for <code>SKIP</code> in this situation if saving indexing time is critical
for you. That&#8217;s rarely the case though.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>By default, no interceptor is applied on an entity. You have to explicitly define an interceptor via
the <code>@Indexed</code> annotation (see <a href="#indexed-annotation">@Indexed</a>) or programmatically (see
<a href="#hsearch-mapping-programmaticapi">Programmatic API</a>). This class and all its subclasses will then be intercepted.
You can stop or change the interceptor used in a subclass by overriding <code>@Indexed.interceptor</code>.
Hibernate Search provides <code>DontInterceptEntityInterceptor</code> which will explicitly not intercept any call.
This is useful to reset interception within a class hierarchy.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Dirty checking optimization is disabled when interceptors are used. Dirty checking optimization does
check what has changed in an entity and only triggers an index update if indexed properties are
changed. The reason is simple, your interceptor might depend on a non indexed property which would
be ignored by this optimization.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>An <code>EntityIndexingInterceptor</code> can never override an explicit indexing operation such as <code>index(T)</code>,
<code>purge(T, id)</code> or <code>purgeAll(class)</code>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="provided-id"><a class="anchor" href="#provided-id"></a>4.6. Providing your own id</h3>
<div class="paragraph">
<p>You can provide your own id for Hibernate Search if you are extending the internals. You will have
to generate a unique value so it can be given to Lucene to be indexed. This will have to be given to
Hibernate Search when you create an <code>org.hibernate.search.Work</code> object - the document id is required
in the constructor.</p>
</div>
<div class="sect3">
<h4 id="ProvidedId"><a class="anchor" href="#ProvidedId"></a>4.6.1. The ProvidedId annotation</h4>
<div class="paragraph">
<p>Unlike <code>@DocumentId</code> which is applied on field level, <code>@ProvidedId</code> is used on the class level.
Optionally you can specify your own bridge implementation using the bridge property. Also, if you
annotate a class with <code>@ProvidedId</code>, your subclasses will also get the annotation - but it is not done
by using the <code>java.lang.annotations.@Inherited</code>. Be sure however, to <em>not</em> use this annotation with
<code>@DocumentId</code> as your system will break.</p>
</div>
<div class="exampleblock">
<div class="title">Example 57. Providing your own id</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@ProvidedId(bridge = org.my.own.package.MyCustomBridge)
@Indexed
public class MyClass{
    @Field
    String MyString;
    ...
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="hsearch-mapping-programmaticapi"><a class="anchor" href="#hsearch-mapping-programmaticapi"></a>4.7. Programmatic API</h3>
<div class="paragraph">
<p>Although the recommended approach for mapping indexed entities is to use annotations, it is
sometimes more convenient to use a different approach:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the same entity is mapped differently depending on deployment needs (customization for clients)</p>
</li>
<li>
<p>some automation process requires the dynamic mapping of many entities sharing common traits</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>While it has been a popular demand in the past, the Hibernate team never found the idea of an XML
alternative to annotations appealing due to its heavy duplication, lack of code refactoring safety,
because it did not cover all the use case spectrum and because we are in the 21st century :)</p>
</div>
<div class="paragraph">
<p>The idea of a programmatic API was much more appealing and has now become a reality. You can
programmatically define your mapping using a programmatic API: you define entities and fields as
indexable by using mapping classes which effectively mirror the annotation concepts in Hibernate
Search. Note that fan(s) of XML approach can design their own schema and use the programmatic API to
create the mapping while parsing the XML stream.</p>
</div>
<div class="paragraph">
<p>In order to use the programmatic model you must first construct a <code>SearchMapping</code> object which you can
do in two ways:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>directly</p>
</li>
<li>
<p>via a factory</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can pass the SearchMapping object directly via the property key
<code>hibernate.search.model_mapping</code> or the constant <code>Environment.MODEL_MAPPING</code>. Use the
Configuration API or the <code>Map</code> passed to the JPA Persistence bootstrap methods.</p>
</div>
<div class="exampleblock">
<div class="title">Example 58. Programmatic mapping</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">SearchMapping mapping = new SearchMapping();
// ... configure mapping
Configuration config = new Configuration();
config.getProperties().put( Environment.MODEL_MAPPING, mapping );
SessionFactory sf = config.buildSessionFactory();</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 59. Programmatic mapping with JPA</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">SearchMapping mapping = new SearchMapping();
// ... configure mapping
Map props = new HashMap();
props.put( Environment.MODEL_MAPPING, mapping );
EntityManagerFactory emf = Persistence.createEntityManagerFactory( "userPU", props );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Alternatively, you can create a factory class (ie hosting a method annotated with <code>@Factory</code>) whose
factory method returns the <code>SearchMapping</code> object. The factory class must have a no-arg constructor
and its fully qualified class name is passed to the property key
<code>hibernate.search.model_mapping</code> or its type-safe representation <code>Environment.MODEL_MAPPING</code>. This
approach is useful when you do not necessarily control the bootstrap process like in a Java EE, CDI
or Spring Framework container.</p>
</div>
<div class="exampleblock">
<div class="title">Example 60. Use a mapping factory</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public class MyAppSearchMappingFactory {
    @Factory
    public SearchMapping getSearchMapping() {
        SearchMapping mapping = new SearchMapping();
        mapping
                .analyzerDef( "ngram", StandardTokenizerFactory.class )
                    .filter( LowerCaseFilterFactory.class )
                    .filter( NGramFilterFactory.class )
                        .param( "minGramSize", "3" )
                        .param( "maxGramSize", "3" );
        return mapping;
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-XML" data-lang="XML">&lt;persistence ...&gt;
    &lt;persistence-unit name="users"&gt;
        ...
        &lt;properties&gt;
            &lt;property name="hibernate.search.model_mapping"
                      value="com.acme.MyAppSearchMappingFactory"/&gt;
        &lt;/properties&gt;
    &lt;/persistence-unit&gt;
&lt;/persistence&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>SearchMapping</code> is the root object which contains all the necessary indexable entities and fields.
From there, the <code>SearchMapping</code> object exposes a fluent (and thus intuitive) API to express your
mappings: it contextually exposes the relevant mapping options in a type-safe way. Just let your IDE
auto-completion feature guide you through.</p>
</div>
<div class="paragraph">
<p>Today, the programmatic API cannot be used on a class annotated with Hibernate Search annotations,
chose one approach or the other. Also note that the same default values apply in annotations and the
programmatic API. For example, the <code>@Field.name</code> is defaulted to the property name and does not have
to be set.</p>
</div>
<div class="paragraph">
<p>Each core concept of the programmatic API has a corresponding example to depict how the same
definition would look using annotation. Therefore seeing an annotation example of the programmatic
approach should give you a clear picture of what Hibernate Search will build with the marked
entities and associated properties.</p>
</div>
<div class="sect3">
<h4 id="_mapping_an_entity_as_indexable"><a class="anchor" href="#_mapping_an_entity_as_indexable"></a>4.7.1. Mapping an entity as indexable</h4>
<div class="paragraph">
<p>The first concept of the programmatic API is to define an entity as indexable. Using the annotation
approach a user would mark the entity as <code>@Indexed</code>, the following example demonstrates how to
programmatically achieve this.</p>
</div>
<div class="exampleblock">
<div class="title">Example 61. Marking an entity indexable</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">SearchMapping mapping = new SearchMapping();

mapping.entity(Address.class)
           .indexed()
               .indexName("Address_Index") //optional
               .interceptor(IndexWhenPublishedInterceptor.class); //optional

cfg.getProperties().put("hibernate.search.model_mapping", mapping);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>As you can see you must first create a <code>SearchMapping</code> object which is the root object that is then
passed to the Configuration object as property. You must declare an entity and if you wish to make
that entity as indexable then you must call the <code>indexed()</code> method. The <code>indexed()</code> method has an
optional <code>indexName(String indexName)</code> which can be used to change the default index name that is
created by Hibernate Search. Likewise, an <code>interceptor(Class&lt;? extends EntityIndexedInterceptor&gt;)</code>
is available. Using the annotation model the above can be achieved as:</p>
</div>
<div class="exampleblock">
<div class="title">Example 62. Annotation example of indexing entity</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed(index="Address_Index", interceptor=IndexWhenPublishedInterceptor.class)
public class Address {
   // ...
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_adding_documentid_to_indexed_entity"><a class="anchor" href="#_adding_documentid_to_indexed_entity"></a>4.7.2. Adding DocumentId to indexed entity</h4>
<div class="paragraph">
<p>To set a property as a document id:</p>
</div>
<div class="exampleblock">
<div class="title">Example 63. Enabling document id with programmatic model</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">SearchMapping mapping = new SearchMapping();

mapping.entity(Address.class).indexed()
           .property("addressId", ElementType.FIELD) //field access
               .documentId()
                   .name("id");

cfg.getProperties().put( "hibernate.search.model_mapping", mapping);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The above is equivalent to annotating a property in the entity as <code>@DocumentId</code> as seen in the
following example:</p>
</div>
<div class="exampleblock">
<div class="title">Example 64. <code>@DocumentId</code> annotation definition</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed
public class Address {
 @Id
 @GeneratedValue
 @DocumentId(name="id")
 private Long addressId;

 // ...
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_defining_analyzers"><a class="anchor" href="#_defining_analyzers"></a>4.7.3. Defining analyzers</h4>
<div class="paragraph">
<p>Analyzers can be programmatically defined using the
<code>analyzerDef(String analyzerDef, Class&lt;? extends TokenizerFactory&gt; tokenizerFactory)</code> method. This
method also enables you to define filters for the analyzer definition. Each filter that you define
can optionally take in parameters as seen in the following example :</p>
</div>
<div class="exampleblock">
<div class="title">Example 65. Defining analyzers using programmatic model</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">SearchMapping mapping = new SearchMapping();

mapping
    .analyzerDef( "ngram", StandardTokenizerFactory.class )
        .filter( LowerCaseFilterFactory.class )
        .filter( NGramFilterFactory.class )
            .param( "minGramSize", "3" )
            .param( "maxGramSize", "3" )
    .analyzerDef( "en", StandardTokenizerFactory.class )
        .filter( LowerCaseFilterFactory.class )
        .filter( EnglishPorterFilterFactory.class )
    .analyzerDef( "de", StandardTokenizerFactory.class )
        .filter( LowerCaseFilterFactory.class )
        .filter( GermanStemFilterFactory.class )
    .entity(Address.class).indexed()
        .property("addressId", ElementType.METHOD) //getter access
            .documentId()
                .name("id");

cfg.getProperties().put( "hibernate.search.model_mapping", mapping );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The analyzer mapping defined above is equivalent to the annotation model using <code>@AnalyzerDef</code>:</p>
</div>
<div class="exampleblock">
<div class="title">Example 66. Analyzer definition using annotation</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Indexed
@Entity
@AnalyzerDef(name = "ngram",
  tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
  filters = {
    @TokenFilterDef(factory = LowerCaseFilterFactory.class),
    @TokenFilterDef(factory = NGramFilterFactory.class,
      params = {
        @Parameter(name = "minGramSize",value = "3"),
        @Parameter(name = "maxGramSize",value = "3")
     })
 })
@AnalyzerDef(name = "en",
  tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
  filters = {
    @TokenFilterDef(factory = LowerCaseFilterFactory.class),
    @TokenFilterDef(factory = EnglishPorterFilterFactory.class)
 })
@AnalyzerDef(name = "de",
  tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
  filters = {
    @TokenFilterDef(factory = LowerCaseFilterFactory.class),
    @TokenFilterDef(factory = GermanStemFilterFactory.class)
})
public class Address {
   // ...
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_defining_normalizers"><a class="anchor" href="#_defining_normalizers"></a>4.7.4. Defining normalizers</h4>
<div class="paragraph">
<p>Similarly to analyzers, normalizers can be programmatically defined using the
<code>normalizerDef(String name)</code> method.</p>
</div>
<div class="exampleblock">
<div class="title">Example 67. Defining normalizers using programmatic model</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">SearchMapping mapping = new SearchMapping();

mapping
    .normalizerDef( "lowercase" )
        .filter( ASCIIFoldingFilterFactory.class )
        .filter( LowerCaseFilterFactory.class )
    .normalizerDef( "charmapping" )
        .charFilter( MappingChar.class )
            .param( "mapping", "com/example/myapplication/lucene/mapping.properties" )
    .entity(Address.class).indexed()
        .property("addressId", ElementType.METHOD) //getter access
            .documentId()
                .name("id");

cfg.getProperties().put( "hibernate.search.model_mapping", mapping );</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_defining_full_text_filter_definitions"><a class="anchor" href="#_defining_full_text_filter_definitions"></a>4.7.5. Defining full text filter definitions</h4>
<div class="paragraph">
<p>The programmatic API provides easy mechanism for defining full text filter definitions which is
available via <code>@FullTextFilterDef</code> (see <a href="#query-filter">Filters</a>). The next example
depicts the creation of full text filter definition using the <code>fullTextFilterDef</code> method.</p>
</div>
<div class="exampleblock">
<div class="title">Example 68. Defining full text definition programmatically</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">SearchMapping mapping = new SearchMapping();

mapping
    .analyzerDef( "en", StandardTokenizerFactory.class )
        .filter( LowerCaseFilterFactory.class )
        .filter( EnglishPorterFilterFactory.class )
    .fullTextFilterDef("security", SecurityFilterFactory.class)
            .cache(FilterCacheModeType.INSTANCE_ONLY)
    .entity(Address.class)
        .indexed()
        .property("addressId", ElementType.METHOD)
            .documentId()
                .name("id")
        .property("street1", ElementType.METHOD)
            .field()
                .analyzer("en")
                .store(Store.YES)
            .field()
                .name("address_data")
                .analyzer("en")
                .store(Store.NO);

cfg.getProperties().put( "hibernate.search.model_mapping", mapping );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The previous example can effectively been seen as annotating your entity with <code>@FullTextFilterDef</code>
like below:</p>
</div>
<div class="exampleblock">
<div class="title">Example 69. Using annotation to define full text filter definition</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed
@AnalyzerDef(name = "en",
  tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
  filters = {
    @TokenFilterDef(factory = LowerCaseFilterFactory.class),
    @TokenFilterDef(factory = EnglishPorterFilterFactory.class)
 })
@FullTextFilterDef(name = "security", impl = SecurityFilterFactory.class, cache = FilterCacheModeType.INSTANCE_ONLY)
public class Address {

 @Id
 @GeneratedValue
 @DocumentId(name="id")
 public Long getAddressId() {...};

 @Field(store=Store.YES, analyzer=@Analyzer(definition="en"))
 @Field(name="address_data", analyzer=@Analyzer(definition="en"))
 public String getAddress1() {...};

 // ...

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_defining_fields_for_indexing"><a class="anchor" href="#_defining_fields_for_indexing"></a>4.7.6. Defining fields for indexing</h4>
<div class="paragraph">
<p>When defining fields for indexing using the programmatic API, call <code>field()</code> on the
<code>property(String propertyName, ElementType elementType)</code> method. From <code>field()</code> you can specify
the <code>name</code>, <code>index</code>, <code>store</code>, <code>bridge</code>, <code>analyzer</code> and <code>normalizer</code> parameters,
as well as make the field sortable using <code>.sortableField()</code>.</p>
</div>
<div class="exampleblock">
<div class="title">Example 70. Indexing fields using programmatic API</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">SearchMapping mapping = new SearchMapping();

mapping
    .analyzerDef( "en", StandardTokenizerFactory.class )
        .filter( LowerCaseFilterFactory.class )
        .filter( EnglishPorterFilterFactory.class )
    .normalizerDef( "lowercase" )
        .filter( ASCIIFoldingFilterFactory.class )
        .filter( LowerCaseFilterFactory.class )
    .entity(Address.class).indexed()
        .property("addressId", ElementType.METHOD)
            .documentId()
                .name("id")
        .property("street1", ElementType.METHOD)
            .field()
                .analyzer("en")
                .store(Store.YES)
            .field()
                .name("address_data")
                .analyzer("en")
            .field()
                .name("address_sort")
                .sortableField()
                .normalizer("lowercase");

cfg.getProperties().put( "hibernate.search.model_mapping", mapping );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The above example of marking fields as indexable is equivalent to defining fields using <code>@Field</code> as
seen below:</p>
</div>
<div class="exampleblock">
<div class="title">Example 71. Indexing fields using annotation</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed
@AnalyzerDef(name = "en",
  tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
  filters = {
    @TokenFilterDef(factory = LowerCaseFilterFactory.class),
    @TokenFilterDef(factory = EnglishPorterFilterFactory.class)
 })
@NormalizerDef(name = "lowercase",
  filters = {
    @TokenFilterDef(factory = ASCIIFoldingFilterFactory.class),
    @TokenFilterDef(factory = LowerCaseFilterFactory.class)
  }
 )
public class Address {

 @Id
 @GeneratedValue
 @DocumentId(name="id")
 private Long getAddressId() {...};

 @Field(store=Store.YES, analyzer=@Analyzer(definition="en"))
 @Field(name="address_data", analyzer=@Analyzer(definition="en"))
 @Field(name="address_sort", normalizer=@Normalizer(definition="lowercase"))
 @SortableField(forField="address_sort")
 public String getAddress1() {...}

 // ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When using a programmatic mapping for a given type <code>X</code>, you can only refer to fields defined on <code>X</code>.
Fields or methods inherited from a super type are not configurable. In case you need to configure a
super class property, you need to either override the property in <code>X</code> or create a programmatic mapping
for the super class. This mimics the usage of annotations where you cannot annotate a field or
method of a super class either, unless it is redefined in the given type.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_programmatically_defining_embedded_entities"><a class="anchor" href="#_programmatically_defining_embedded_entities"></a>4.7.7. Programmatically defining embedded entities</h4>
<div class="paragraph">
<p>In this section you will see how to programmatically define entities to be embedded into the indexed
entity similar to using the <code>@IndexedEmbedded</code> model. In order to define this you must mark the
property as <code>indexEmbedded</code>. There is the option to add a prefix to the embedded entity definition
which can be done by calling prefix as seen in the example below:</p>
</div>
<div class="exampleblock">
<div class="title">Example 72. Programmatically defining embedded entities</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">SearchMapping mapping = new SearchMapping();

mapping
    .entity(ProductCatalog.class)
        .indexed()
        .property("catalogId", ElementType.METHOD)
            .documentId()
                .name("id")
        .property("title", ElementType.METHOD)
            .field()
                .index(Index.YES)
                .store(Store.NO)
        .property("description", ElementType.METHOD)
             .field()
                 .index(Index.YES)
                 .store(Store.NO)
        .property("items", ElementType.METHOD)
            .indexEmbedded()
                .prefix("catalog.items"); //optional

cfg.getProperties().put( "hibernate.search.model_mapping", mapping )</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The next example shows the same definition using annotation (<code>@IndexedEmbedded</code>):</p>
</div>
<div class="exampleblock">
<div class="title">Example 73. Using <code>@IndexedEmbedded</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed
public class ProductCatalog {
 @Id
 @GeneratedValue
 @DocumentId(name="id")
 public Long getCatalogId() {...}

 @Field
 public String getTitle() {...}

 @Field
 public String getDescription();

 @OneToMany(fetch = FetchType.LAZY)
 @IndexColumn(name = "list_position")
 @Cascade(org.hibernate.annotations.CascadeType.ALL)
 @IndexedEmbedded(prefix="catalog.items")
 public List&lt;Item&gt; getItems() {...}

 // ...
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_contained_in_definition"><a class="anchor" href="#_contained_in_definition"></a>4.7.8. Contained In definition</h4>
<div class="paragraph">
<p><code>@ContainedIn</code> can be defined as seen in the example below:</p>
</div>
<div class="exampleblock">
<div class="title">Example 74. Programmatically defining <code>containedIn</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">SearchMapping mapping = new SearchMapping();

mapping
    .entity(ProductCatalog.class)
        .indexed()
        .property("catalogId", ElementType.METHOD)
            .documentId()
        .property("title", ElementType.METHOD)
            .field()
        .property("description", ElementType.METHOD)
            .field()
        .property("items", ElementType.METHOD)
            .indexEmbedded()

    .entity(Item.class)
        .property("description", ElementType.METHOD)
            .field()
        .property("productCatalog", ElementType.METHOD)
            .containedIn();

cfg.getProperties().put( "hibernate.search.model_mapping", mapping );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This is equivalent to defining <code>@ContainedIn</code> in your entity:</p>
</div>
<div class="exampleblock">
<div class="title">Example 75. Annotation approach for <code>@ContainedIn</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed
public class ProductCatalog {

 @Id
 @GeneratedValue
 @DocumentId
 public Long getCatalogId() {...}

 @Field
 public String getTitle() {...}

 @Field
 public String getDescription() {...}

 @OneToMany(fetch = FetchType.LAZY)
 @IndexColumn(name = "list_position")
 @Cascade(org.hibernate.annotations.CascadeType.ALL)
 @IndexedEmbedded
 private List&lt;Item&gt; getItems() {...}

 // ...
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
public class Item {

 @Id
 @GeneratedValue
 private Long itemId;

 @Field
 public String getDescription() {...}

 @ManyToOne( cascade = { CascadeType.PERSIST, CascadeType.REMOVE } )
 @ContainedIn
 public ProductCatalog getProductCatalog() {...}

 // ...
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_date_calendar_bridge"><a class="anchor" href="#_date_calendar_bridge"></a>4.7.9. Date/Calendar Bridge</h4>
<div class="paragraph">
<p>In order to define a calendar or date bridge mapping, call the <code>dateBridge(Resolution resolution)</code> or
<code>calendarBridge(Resolution resolution)</code> methods after you have defined a <code>field()</code> in the <code>SearchMapping</code>
hierarchy.</p>
</div>
<div class="exampleblock">
<div class="title">Example 76. Programmatic model for defining calendar/date bridge</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">SearchMapping mapping = new SearchMapping();

mapping
    .entity(Address.class)
        .indexed()
        .property("addressId", ElementType.FIELD)
            .documentId()
    .property("street1", ElementType.FIELD()
        .field()
    .property("createdOn", ElementType.FIELD)
        .field()
        .dateBridge(Resolution.DAY)
    .property("lastUpdated", ElementType.FIELD)
        .calendarBridge(Resolution.DAY);

cfg.getProperties().put( "hibernate.search.model_mapping", mapping );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>See below for defining the above using <code>@CalendarBridge</code> and <code>@DateBridge</code>:</p>
</div>
<div class="exampleblock">
<div class="title">Example 77. <code>@CalendarBridge</code> and <code>@DateBridge</code> definition</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed
public class Address {

 @Id
 @GeneratedValue
 @DocumentId
 private Long addressId;

 @Field
 private String address1;

 @Field
 @DateBridge(resolution=Resolution.DAY)
 private Date createdOn;

 @CalendarBridge(resolution=Resolution.DAY)
 private Calendar lastUpdated;

 // ...
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_declaring_bridges"><a class="anchor" href="#_declaring_bridges"></a>4.7.10. Declaring bridges</h4>
<div class="paragraph">
<p>It is possible to associate bridges to programmatically defined fields. When you define a <code>field()</code>
programmatically you can use the <code>bridge(Class&lt;?&gt; impl)</code> to associate a <code>FieldBridge</code> implementation
class. The bridge method also provides optional methods to include any parameters required for the
bridge class. The below shows an example of programmatically defining a bridge:</p>
</div>
<div class="exampleblock">
<div class="title">Example 78. Declaring field bridges programmatically</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">SearchMapping mapping = new SearchMapping();

mapping
    .entity(Address.class)
        .indexed()
        .property("addressId", ElementType.FIELD)
            .documentId()
        .property("street1", ElementType.FIELD)
            .field()
            .field()
                .name("street1_abridged")
                .bridge( ConcatStringBridge.class )
                    .param( "size", "4" );

cfg.getProperties().put( "hibernate.search.model_mapping", mapping );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The above can equally be defined using annotations, as seen in the next example.</p>
</div>
<div class="exampleblock">
<div class="title">Example 79. Declaring field bridges using annotation</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed
public class Address {

 @Id
 @GeneratedValue
 @DocumentId(name="id")
 private Long addressId;

 @Field
 @Field(name="street1_abridged",
        bridge = @FieldBridge( impl = ConcatStringBridge.class,
        params = @Parameter( name="size", value="4" ))
 private String address1;

 // ...
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_mapping_class_bridge"><a class="anchor" href="#_mapping_class_bridge"></a>4.7.11. Mapping class bridge</h4>
<div class="paragraph">
<p>You can define class bridges on entities programmatically. This is shown in the next example:</p>
</div>
<div class="exampleblock">
<div class="title">Example 80. Defining class bridges using API</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">SearchMapping mapping = new SearchMapping();

mapping
    .entity(Departments.class)
      .classBridge(CatDeptsFieldsClassBridge.class)
         .name("branchnetwork")
         .index(Index.YES)
         .store(Store.YES)
         .param("sepChar", " ")
      .classBridge(EquipmentType.class)
         .name("equiptype")
         .index(Index.YES)
         .store(Store.YES)
         .param("C", "Cisco")
         .param("D", "D-Link")
         .param("K", "Kingston")
         .param("3", "3Com")
      .indexed();

cfg.getProperties().put( "hibernate.search.model_mapping", mapping );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The above is similar to using <code>@ClassBridge</code> as seen in the next example:</p>
</div>
<div class="exampleblock">
<div class="title">Example 81. Using <code>@ClassBridge</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed
@ClassBridge(name="branchnetwork",
  store= Store.YES,
  impl = CatDeptsFieldsClassBridge.class,
  params = @Parameter( name="sepChar", value=" " ) ),
@ClassBridge(name="equiptype",
  store= Store.YES,
  impl = EquipmentType.class,
  params = {@Parameter( name="C", value="Cisco" ),
     @Parameter( name="D", value="D-Link" ),
     @Parameter( name="K", value="Kingston" ),
     @Parameter( name="3", value="3Com" )
})
public class Departments {
   // ...
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_mapping_dynamic_boost"><a class="anchor" href="#_mapping_dynamic_boost"></a>4.7.12. Mapping dynamic boost</h4>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Index-time boosting is deprecated: support for this approach will be removed in Apache Lucene since version 7.</p>
</div>
<div class="paragraph">
<p>We recommend to use query-time boosting instead: see <a href="#search-query">Querying</a>.</p>
</div>
<div class="paragraph">
<p>If query-time boosting is not enough for your use case, you can implement dynamic boosting
using a <a href="#section-custom-similarity">custom similarity</a> (advanced use).</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can apply a dynamic boost factor on either a field or a whole entity:</p>
</div>
<div class="exampleblock">
<div class="title">Example 82. <code>dynamicBoost</code> mapping using programmatic model</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">SearchMapping mapping = new SearchMapping();
mapping
  .entity(DynamicBoostedDescLibrary.class)
   .indexed()
   .dynamicBoost(CustomBoostStrategy.class)
  .property("libraryId", ElementType.FIELD)
    .documentId().name("id")
  .property("name", ElementType.FIELD)
    .dynamicBoost(CustomFieldBoostStrategy.class);
    .field()
      .store(Store.YES)

cfg.getProperties().put( "hibernate.search.model_mapping", mapping );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The next example shows the equivalent mapping using the <code>@DynamicBoost</code> annotation:</p>
</div>
<div class="exampleblock">
<div class="title">Example 83. Using the <code>@DynamicBoost</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed
@DynamicBoost(impl = CustomBoostStrategy.class)
public class DynamicBoostedDescriptionLibrary {

 @Id
 @GeneratedValue
 @DocumentId
 private int id;

 private float dynScore;

 @Field(store = Store.YES)
 @DynamicBoost(impl = CustomFieldBoostStrategy.class)
 private String name;

 public DynamicBoostedDescriptionLibrary() {
  dynScore = 1.0f;
 }

 // ...
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="search-query"><a class="anchor" href="#search-query"></a>5. Querying</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The second most important capability of Hibernate Search is the ability to execute Lucene queries
and retrieve entities managed by a Hibernate session. The search provides the power of Lucene
without leaving the Hibernate paradigm, giving another dimension to the Hibernate classic search
mechanisms (HQL, Criteria query, native SQL query).</p>
</div>
<div class="paragraph">
<p>Preparing and executing a query consists of four simple steps:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Creating a <code>FullTextSession</code></p>
</li>
<li>
<p>Creating a Lucene query either via the Hibernate Search query DSL (recommended) or by utilizing
the Lucene query API</p>
</li>
<li>
<p>Wrapping the Lucene query using an <code>org.hibernate.Query</code></p>
</li>
<li>
<p>Executing the search by calling for example <code>list()</code> or <code>scroll()</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To access the querying facilities, you have to use a <code>FullTextSession</code>. This Search specific session
wraps a regular <code>org.hibernate.Session</code> in order to provide query and indexing capabilities.</p>
</div>
<div class="exampleblock">
<div class="title">Example 84. Creating a FullTextSession</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Session session = sessionFactory.openSession();
//...
FullTextSession fullTextSession = Search.getFullTextSession(session);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Once you have a <code>FullTextSession</code> you have two options to build the full-text query: the Hibernate
Search query DSL or the native Lucene query.</p>
</div>
<div class="paragraph">
<p>If you use the Hibernate Search query DSL, it will look like this:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">QueryBuilder b = fullTextSession.getSearchFactory()
    .buildQueryBuilder().forEntity(Myth.class).get();

org.apache.lucene.search.Query luceneQuery =
    b.keyword()
        .onField("history").boostedTo(3)
        .matching("storm")
        .createQuery();

org.hibernate.Query fullTextQuery = fullTextSession.createFullTextQuery(luceneQuery);
List result = fullTextQuery.list(); //return a list of managed objects</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can alternatively write your Lucene query either using the Lucene query parser or Lucene
programmatic API.</p>
</div>
<div class="exampleblock">
<div class="title">Example 85. Creating a Lucene query via the QueryParser</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">SearchFactory searchFactory = fullTextSession.getSearchFactory();
org.apache.lucene.queryparser.classic.QueryParser parser =
    new QueryParser("title", searchFactory.getAnalyzer(Myth.class));
try {
    org.apache.lucene.search.Query luceneQuery = parser.parse("history:storm^3");
}
catch (ParseException e) {
    //handle parsing failure
}

org.hibernate.Query fullTextQuery = fullTextSession.createFullTextQuery(luceneQuery);
List result = fullTextQuery.list(); //return a list of managed objects</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The Hibernate query built on top of the Lucene query is a regular <code>org.hibernate.Query</code>, which means
you are in the same paradigm as the other Hibernate query facilities (HQL, Native or Criteria). The
regular <code>list()</code> , <code>uniqueResult()</code>, <code>iterate()</code> and <code>scroll()</code> methods can be used.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In case you are using the Java Persistence APIs of Hibernate, the same extensions exist:</p>
</div>
<div class="exampleblock">
<div class="title">Example 86. Creating a Search query using the JPA API</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">EntityManager em = entityManagerFactory.createEntityManager();

FullTextEntityManager fullTextEntityManager =
    org.hibernate.search.jpa.Search.getFullTextEntityManager(em);

// ...
QueryBuilder b = fullTextEntityManager.getSearchFactory()
    .buildQueryBuilder().forEntity( Myth.class ).get();

org.apache.lucene.search.Query luceneQuery =
    b.keyword()
        .onField("history").boostedTo(3)
        .matching("storm")
        .createQuery();
javax.persistence.Query fullTextQuery =
    fullTextEntityManager.createFullTextQuery( luceneQuery );

List result = fullTextQuery.getResultList(); //return a list of managed objects</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The following examples we will use the Hibernate APIs but the same example can be easily rewritten
with the Java Persistence API by just adjusting the way the FullTextQuery is retrieved.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="section-building-lucene-queries"><a class="anchor" href="#section-building-lucene-queries"></a>5.1. Building queries</h3>
<div class="paragraph">
<p>Hibernate Search queries are built on top of Lucene queries which gives you total freedom on the
type of Lucene query you want to execute. However, once built, Hibernate Search wraps further query
processing using org.hibernate.Query as your primary query manipulation API.</p>
</div>
<div class="sect3">
<h4 id="search-query-lucene-api"><a class="anchor" href="#search-query-lucene-api"></a>5.1.1. Building a Lucene query using the Lucene API</h4>
<div class="paragraph">
<p>Using the Lucene API, you have several options. You can use the query parser (fine for simple
queries) or the Lucene programmatic API (for more complex use cases). It is out of the scope of this
documentation on how to exactly build a Lucene query. Please refer to the online Lucene
documentation or get hold of a copy of Lucene In Action or Hibernate Search in Action.</p>
</div>
</div>
<div class="sect3">
<h4 id="search-query-querydsl"><a class="anchor" href="#search-query-querydsl"></a>5.1.2. Building a Lucene query with the Hibernate Search query DSL</h4>
<div class="paragraph">
<p>Writing full-text queries with the Lucene programmatic API is quite complex. It&#8217;s even more complex
to understand the code once written. Besides the inherent API complexity, you have to remember to
convert your parameters to their string equivalent as well as make sure to apply the correct
analyzer to the right field (a ngram analyzer will for example use several ngrams as the tokens for
a given word and should be searched as such).</p>
</div>
<div class="paragraph">
<p>The Hibernate Search query DSL makes use of a style of API called a fluent API. This API has a few
key characteristics:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>it has meaningful method names making a succession of operations reads almost like English</p>
</li>
<li>
<p>it limits the options offered to what makes sense in a given context (thanks to strong typing and
IDE auto-completion).</p>
</li>
<li>
<p>it often uses the chaining method pattern</p>
</li>
<li>
<p>it&#8217;s easy to use and even easier to read</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Let&#8217;s see how to use the API. You first need to create a query builder that is attached to a given
indexed entity type. This QueryBuilder will know what analyzer to use and what field bridge to
apply. You can create several <code>QueryBuilder</code> instances (one for each entity type involved in the root
of your query). You get the <code>QueryBuilder</code> from the <code>SearchFactory</code>.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">QueryBuilder mythQB = searchFactory.buildQueryBuilder().forEntity( Myth.class ).get();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can also override the analyzer used for a given field or fields. This is rarely needed and should be avoided unless you know what you are doing.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">QueryBuilder mythQB = searchFactory.buildQueryBuilder()
    .forEntity( Myth.class )
        .overridesForField("history","stem_analyzer_definition")
    .get();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Using the query builder, you can then build queries. It is important to realize that the end result
of a QueryBuilder is a Lucene query. For this reason you can easily mix and match queries generated
via Lucene&#8217;s query parser or Query objects you have assembled with the Lucene programmatic API and
use them with the Hibernate Search DSL. Just in case the DSL is missing some features.</p>
</div>
<div class="sect4">
<h5 id="_keyword_queries"><a class="anchor" href="#_keyword_queries"></a>Keyword queries</h5>
<div class="paragraph">
<p>Let&#8217;s start with the most basic use case - searching for a specific word:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Query luceneQuery = mythQB.keyword().onField("history").matching("storm").createQuery();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>keyword()</code> means that you are trying to find a specific word. <code>onField()</code> specifies in which Lucene
field to look. <code>matching()</code> tells what to look for. And finally <code>createQuery()</code> creates the Lucene
query object. A lot is going on with this line of code.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The value storm is passed through the <code>history</code> FieldBridge: it does not matter here but you will
see that it&#8217;s quite handy when dealing with numbers or dates.</p>
</li>
<li>
<p>The field bridge value is then passed to the analyzer used to index the field <code>history</code>. This
ensures that the query uses the same term transformation than the indexing (lower case, n-gram,
stemming and so on). If the analyzing process generates several terms for a given word, a boolean
query is used with the <code>SHOULD</code> logic (roughly an <code>OR</code> logic).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>We make the example a little more advanced now and have a look at how to search a field that uses
ngram analyzers. ngram analyzers index succession of ngrams of your words which helps to recover
from user typos. For example the 3-grams of the word hibernate are hib, ibe, ber, rna, nat, ate.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@AnalyzerDef(name = "ngram",
  tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class ),
  filters = {
    @TokenFilterDef(factory = StandardFilterFactory.class),
    @TokenFilterDef(factory = LowerCaseFilterFactory.class),
    @TokenFilterDef(factory = StopFilterFactory.class),
    @TokenFilterDef(factory = NGramFilterFactory.class,
      params = {
        @Parameter(name = "minGramSize", value = "3"),
        @Parameter(name = "maxGramSize", value = "3") } )
  }
)
@Entity
@Indexed
public class Myth {
  @Field(analyzer=@Analyzer(definition="ngram")
  public String getName() { return name; }
  public String setName(String name) { this.name = name; }
  private String name;

  ...
}

Query luceneQuery = mythQb.keyword().onField("name").matching("Sisiphus")
   .createQuery();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The matching word "Sisiphus" will be lower-cased and then split into 3-grams: sis, isi, sip, phu,
hus. Each of these n-gram will be part of the query. We will then be able to find the Sysiphus myth
(with a <code>y</code>). All that is transparently done for you.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If for some reason you do not want a specific field to use the field bridge or the analyzer you can
call the <code>ignoreAnalyzer()</code> or <code>ignoreFieldBridge()</code> functions.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To search for multiple possible words in the same field, simply add them all in the matching clause.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">//search document with storm or lightning in their history
Query luceneQuery =
    mythQB.keyword().onField("history").matching("storm lightning").createQuery();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>To search the same word on multiple fields, use the onFields method.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Query luceneQuery = mythQB
    .keyword()
    .onFields("history","description","name")
    .matching("storm")
    .createQuery();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Sometimes, one field should be treated differently from another field even if searching the same
term, you can use the andField() method for that.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Query luceneQuery = mythQB.keyword()
    .onField("history")
    .andField("name")
        .boostedTo(5f)
    .andField("description")
    .matching("storm")
    .createQuery();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the previous example, only field name is boosted to 5.</p>
</div>
</div>
<div class="sect4">
<h5 id="_simple_query_string_queries"><a class="anchor" href="#_simple_query_string_queries"></a>Simple Query String queries</h5>
<div class="paragraph">
<p>Simple Query String queries use the Lucene <code>SimpleQueryParser</code>, presented as a "parser for
human-entered queries". The point of this parser is to be a very simple lenient state machine
to parse queries entered by your end users.</p>
</div>
<div class="paragraph">
<p>The parser is capable to transform <code>keyword "some phrase" -keywordidontwant fuzzy~ prefix*</code>
into a Lucene query, giving your users a little more power (phrase queries, fuzzy queries,
boolean operators&#8230;&#8203;).</p>
</div>
<div class="paragraph">
<p>The lenient part is important as it will try to build the best possible query without throwing
a parsing exception, even if the query is not what we would consider syntactically correct.</p>
</div>
<div class="paragraph">
<p>Another nice feature is that it allows to search on multiple fields. You basically end up
establishing the following contract with Lucene:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>users will enter a search query (more or less syntactically correct)</p>
</li>
<li>
<p>it will search on the fields you have specified (and you can also specify a specific
boost for each field)</p>
</li>
<li>
<p>you can enable each of the features that you want to expose to the users
(i.e. you can enable the phrase queries but not the boolean operators)</p>
</li>
<li>
<p>building the query wont throw an exception</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Even if we are talking about Lucene queries here, this feature is also supported by our
Elasticsearch integration.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Here are a couple of examples introducing the features of our Simple Query String support one at a time.</p>
</div>
<div class="paragraph">
<p>The query below is the most simple form of Simple Query String query. It simply returns documents
whose <code>history</code> field contains <code>storm</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Query luceneQuery = mythQB
    .simpleQueryString()
    .onField("history")
    .matching("storm")
    .createQuery();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>By default, a Simple Query String query uses the OR operator if the operator is not explicitly defined.
If you prefer using the AND operator as default, you can add the <code>withAndAsDefaultOperator</code> flag.
The following query returns results containing <code>storm</code> AND <code>tree</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Query luceneQuery = mythQB
    .simpleQueryString()
    .onField("history")
    .withAndAsDefaultOperator()
    .matching("storm tree")
    .createQuery();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>It is also possible to search on several fields at the same time, meaning you can search for the presence
of keywords in e.g. <code>name</code>, <code>history</code> or <code>description</code>, potentially with different boosts:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Query luceneQuery = mythQB
    .simpleQueryString()
    .onField("name")
        .boostedTo(5f)
    .andFields("history", "description")
        .boostedTo(2f)
    .withAndAsDefaultOperator()
    .matching("storm tree")
    .createQuery();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The above query returns results containing <code>storm</code> and <code>tree</code> either in <code>name</code>, <code>history</code> or <code>description</code>.</p>
</div>
<div class="paragraph">
<p>The syntax supported by the <code>SimpleQueryParser</code> includes the following operators:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>boolean (AND using <code>+</code>, OR using <code>|</code>, NOT using <code>-</code>)</p>
</li>
<li>
<p>prefix (<code>prefix*</code>)</p>
</li>
<li>
<p>phrase (<code>"some phrase"</code>)</p>
</li>
<li>
<p>precedence (using parentheses)</p>
</li>
<li>
<p>fuzzy (<code>fuzy~2</code>)</p>
</li>
<li>
<p>near operator for phrase queries (<code>"war peace"~3</code>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The query below will also return results containing <code>storms</code> or <code>sturm</code>.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Query luceneQuery = mythQB
    .simpleQueryString()
    .onFields("name", "history", "description")
    .matching("storm~2")
    .createQuery();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The query below will return results containing <code>war</code> and either <code>peace</code> or <code>harmony</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Query luceneQuery = mythQB
    .simpleQueryString()
    .onFields("name", "history", "description")
    .matching("war + (peace | harmony)")
    .createQuery();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>And, finally, the following query will return results containing exactly the phrase <code>storm and tree</code> in either
<code>name</code>, <code>history</code> or <code>description</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Query luceneQuery = mythQB
    .simpleQueryString()
    .onFields("name", "history", "description")
    .matching("\"storm and tree\"")
    .createQuery();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_fuzzy_queries"><a class="anchor" href="#_fuzzy_queries"></a>Fuzzy queries</h5>
<div class="paragraph">
<p>To execute a fuzzy query (based on the Levenshtein distance algorithm), start like a <code>keyword</code> query
and add the fuzzy flag.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Query luceneQuery = mythQB
    .keyword()
      .fuzzy()
        .withThreshold(.8f)
        .withPrefixLength(1)
    .onField("history")
    .matching("starm")
    .createQuery();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>threshold</code> is the limit above which two terms are considering matching. It&#8217;s a decimal between 0 and
1 and defaults to 0.5. <code>prefixLength</code> is the length of the prefix ignored by the "fuzzyness": while
it defaults to 0, a non zero value is recommended for indexes containing a huge amount of distinct
terms.</p>
</div>
</div>
<div class="sect4">
<h5 id="_wildcard_queries"><a class="anchor" href="#_wildcard_queries"></a>Wildcard queries</h5>
<div class="paragraph">
<p>You can also execute wildcard queries (queries where some of parts of the word are unknown).
The character <code>?</code> represents a single character and <code>*</code> represents any character sequence.
Note that for performance purposes, it is recommended that the query does not start with either <code>?</code> or <code>*</code>.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Query luceneQuery = mythQB
    .keyword()
      .wildcard()
    .onField("history")
    .matching("sto*")
    .createQuery();</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Wildcard queries do not apply the analyzer on the matching terms. Otherwise the risk of <code>*</code> or <code>?</code>
being mangled is too high.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_phrase_queries"><a class="anchor" href="#_phrase_queries"></a>Phrase queries</h5>
<div class="paragraph">
<p>So far we have been looking for words or sets of words, you can also search exact or approximate
sentences. Use <code>phrase()</code> to do so.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Query luceneQuery = mythQB
    .phrase()
    .onField("history")
    .sentence("Thou shalt not kill")
    .createQuery();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can search approximate sentences by adding a slop factor. The slop factor represents the number
of other words permitted in the sentence: this works like a within or near operator</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Query luceneQuery = mythQB
    .phrase()
      .withSlop(3)
    .onField("history")
    .sentence("Thou kill")
    .createQuery();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_range_queries"><a class="anchor" href="#_range_queries"></a>Range queries</h5>
<div class="paragraph">
<p>After looking at all these query examples for searching for to a given word, it is time to introduce
range queries (on numbers, dates, strings etc). A range query searches for a value in between given
boundaries (included or not) or for a value below or above a given boundary (included or not).</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">//look for 0 &lt;= starred &lt; 3
Query luceneQuery = mythQB
    .range()
    .onField("starred")
    .from(0).to(3).excludeLimit()
    .createQuery();

//look for myths strictly BC
Date beforeChrist = ...;
Query luceneQuery = mythQB
    .range()
    .onField("creationDate")
    .below(beforeChrist).excludeLimit()
    .createQuery();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="search-query-querydsl-spatial"><a class="anchor" href="#search-query-querydsl-spatial"></a>Spatial (or geolocation) queries</h5>
<div class="paragraph">
<p>This set of queries has its own chapter, check out <a href="#spatial">Spatial</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="search-query-querydsl-mlt"><a class="anchor" href="#search-query-querydsl-mlt"></a>More Like This queries</h5>
<div class="paragraph">
<p>Have you ever looked at an article or document and thought: "I want to find more like this"? Have you ever
appreciated an e-commerce website that gives you similar articles to the one you are exploring?</p>
</div>
<div class="paragraph">
<p>More Like This queries are achieving just that. You feed it an entity (or its identifier) and
Hibernate Search returns the list of entities that are similar.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">How does it work?</div>
<div class="paragraph">
<p>For each (selected) field of the targeted entity, we look at the most meaningful terms. Then we
create a query matching the most meaningful terms per field. This is a slight variation compared to
the original Lucene <code>MoreLikeThisQuery</code> implementation.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The query DSL API should be self explaining. Let&#8217;s look at some usage examples.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">QueryBuilder qb = fullTextSession.getSearchFactory()
        .buildQueryBuilder()
        .forEntity( Coffee.class )
        .get();

Query mltQuery = qb
        .moreLikeThis()
            .comparingAllFields()
            .toEntityWithId( coffeeId )
            .createQuery();
List&lt;Object[]&gt; results = (List&lt;Object[]&gt;) fullTextSession
        .createFullTextQuery( mltQuery, Coffee.class )
        .setProjection( ProjectionConstants.THIS, ProjectionConstants.SCORE )
        .list();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This first example takes the id of an Coffee entity and finds the matching coffees across all fields. To be fair,
this is not across <em>all</em> fields. To be included in the More Like This query, fields need to store term vectors or the
actual field value. Id fields (of the root entity as well as embedded entities) and numeric fields are excluded.
The latter exclusion might change in future versions.</p>
</div>
<div class="paragraph">
<p>Looking at the <code>Coffee</code> class, the following fields are considered: <code>name</code> as it is stored,
<code>description</code> as it stores the term vector. <code>id</code> and <code>internalDescription</code> are excluded.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity @Indexed
public class Coffee {

    @Id @GeneratedValue
    public Integer getId() { return id; }

    @Field(termVector = TermVector.NO, store = Store.YES)
    public String getName() { return name; }

    @Field(termVector = TermVector.YES)
    public String getSummary() { return summary; }

    @Column(length = 2000)
    @Field(termVector = TermVector.YES)
    public String getDescription() { return description; }

    public int getIntensity() { return intensity; }

    // Not stored nor term vector, i.e. cannot be used for More Like This
    @Field
    public String getInternalDescription() { return internalDescription; }

    // ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In the example above we used projection to retrieve the relative score of each element. We might use the
score to only display the results for which the score is high enough.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>For best performance and best results, store the term vectors for the fields you want to include in
a More Like This query.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Often, you are only interested in a few key fields to find similar entities. Plus some fields are
more important than others and should be boosted.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Query mltQuery = qb
        .moreLikeThis()
            .comparingField("summary").boostedTo(10f)
            .andField("description")
            .toEntityWithId( coffeeId )
            .createQuery();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In this example, we look for similar entities by summary and description. But similar summaries are
more important than similar descriptions. This is a critical tool to make More Like This meaningful
for your data set.</p>
</div>
<div class="paragraph">
<p>Instead of providing the entity id, you can pass the full entity object. If the entity contains the
identifier, we will use it to find the term vectors or field values. This means that we will compare
the entity state as stored in the Lucene index. If the identifier cannot be retrieved (for example
if the entity has not been persisted yet), we will look at each of the entity properties to find the
most meaningful terms. The latter is slower and won&#8217;t give the best results - avoid it if possible.</p>
</div>
<div class="paragraph">
<p>Here is how you pass the entity instance you want to compare with:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Coffee coffee = ...; //managed entity from somewhere

Query mltQuery = qb
        .moreLikeThis()
            .comparingField("summary").boostedTo(10f)
            .andField("description")
            .toEntity( coffee )
            .createQuery();</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>By default, the results contain at the top the entity you are comparing with. This is particularly
useful to compare relative scores. If you don&#8217;t need it, you can exclude it.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Query mltQuery = qb
        .moreLikeThis()
            .excludeEntityUsedForComparison()
            .comparingField("summary").boostedTo(10f)
            .andField("description")
            .toEntity( coffee )
            .createQuery();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can ask Hibernate Search to give a higher score to the very similar entities and downgrade the
score of mildly similar entities. We do that by boosting each meaningful terms by their individual
overall score. Start with a boost factor of <code>1</code> and adjust from there.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Query mltQuery = qb
        .moreLikeThis()
            .favorSignificantTermsWithFactor(1f)
            .comparingField("summary").boostedTo(10f)
            .andField("description")
            .toEntity( coffee )
            .createQuery();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Remember, more like this is a very subjective meaning and will vary depending on your data and the
rules of your domain. With the various options offered, Hibernate Search arms you with the tools to
adjust this weapon. Make sure to continuously test the results against your data set.</p>
</div>
</div>
<div class="sect4">
<h5 id="_combining_queries"><a class="anchor" href="#_combining_queries"></a>Combining queries</h5>
<div class="paragraph">
<p>You can combine queries to create more complex queries.
The following aggregation operators are available:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>SHOULD</code>: the query should contain the matching elements of the subquery</p>
</li>
<li>
<p><code>MUST</code>: the query must contain the matching elements of the subquery</p>
</li>
<li>
<p><code>MUST NOT</code>: the query must not contain the matching elements of the subquery</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These aggregations have a similar effect as the classic boolean operators <code>AND</code>, <code>OR</code> and <code>NOT</code>,
but have different names to emphasise that they will have an impact on scoring.</p>
</div>
<div class="paragraph">
<p>For example the <code>SHOULD</code> operator between two queries will have an effect similar to the boolean <code>OR</code>:
if either of the two combined queries matches the entry, the entry will be included in the match;
though the entries which match both queries will have an higher score than those which only match one of them.</p>
</div>
<div class="paragraph">
<p>The sub-queries can be any Lucene query including a boolean query itself.</p>
</div>
<div class="exampleblock">
<div class="title">Example 87. Structure of a boolean <code>AND</code> query: the <code>must</code> method.</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Query combinedQuery = querybuilder
    .bool()
        .must( queryA )
        .must( queryB )
    .createQuery();</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 88. Structure of boolean <code>OR</code> query: the <code>should</code> method.</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Query combinedQuery = querybuilder
    .bool()
        .should( queryA )
        .should( queryB )
    .createQuery();</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 89. Structure of a negation query: apply a <code>not</code> modifier to a <code>must</code>.</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Query combinedQuery = querybuilder
    .bool()
        .must( queryA )
        .must( queryB ).not()
    .createQuery();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s look at a few more practical examples; note how the querybuilder usage can be nested
and how 'should', 'must', and 'not' can be combined in many ways:</p>
</div>
<div class="exampleblock">
<div class="title">Example 90. Full example of combining fulltext queries</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">//look for popular modern myths that are not urban
Date twentiethCentury = ...;
Query luceneQuery = mythQB
    .bool()
      .must( mythQB.keyword().onField("description").matching("urban").createQuery() )
        .not()
      .must( mythQB.range().onField("starred").above(4).createQuery() )
      .must( mythQB
        .range()
        .onField("creationDate")
        .above(twentiethCentury)
        .createQuery() )
    .createQuery();

//look for popular myths that are preferably urban
Query luceneQuery = mythQB
    .bool()
      .should( mythQB.keyword().onField("description").matching("urban").createQuery() )
      .must( mythQB.range().onField("starred").above(4).createQuery() )
    .createQuery();

//look for all myths except religious ones
Query luceneQuery = mythQB
    .all()
      .except( monthQb
        .keyword()
        .onField( "description_stem" )
        .matching( "religion" )
        .createQuery()
      )
    .createQuery();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_query_options"><a class="anchor" href="#_query_options"></a>Query options</h5>
<div class="paragraph">
<p>We already have seen several query options in the previous example, but lets summarize again the
options for query types and fields:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>boostedTo</code> (on query type and on field): boost the whole query or the specific field to a given
factor</p>
</li>
<li>
<p><code>withConstantScore</code> (on query): all results matching the query have a constant score equals to the
boost</p>
</li>
<li>
<p><code>filteredBy(Filter)</code> (on query): filter query results using the Filter instance</p>
</li>
<li>
<p><code>ignoreAnalyzer</code> (on field): ignore the <a href="#analyzer">analyzer</a> (or <a href="#section-normalizers">normalizer</a>)
when processing this field</p>
</li>
<li>
<p><code>ignoreFieldBridge</code> (on field): ignore field bridge when processing this field</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Let&#8217;s check out an example using some of these options</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Query luceneQuery = mythQB
    .bool()
      .should( mythQB.keyword().onField("description").matching("urban").createQuery() )
      .should( mythQB
        .keyword()
        .onField("name")
          .boostedTo(3)
          .ignoreAnalyzer()
        .matching("urban").createQuery() )
      .must( mythQB
        .range()
          .boostedTo(5).withConstantScore()
        .onField("starred").above(4).createQuery() )
    .createQuery();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>As you can see, the Hibernate Search query DSL is an easy to use and easy to read query API and by
accepting and producing Lucene queries, you can easily incorporate query types not (yet) supported
by the DSL. Please give us feedback!</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_building_a_hibernate_search_query"><a class="anchor" href="#_building_a_hibernate_search_query"></a>5.1.3. Building a Hibernate Search query</h4>
<div class="paragraph">
<p>So far we only covered the process of how to create your Lucene query (see <a href="#section-building-lucene-queries">Building queries</a>).
However, this is only the first step in the chain of actions. Let&#8217;s now see how
to build the Hibernate Search query from the Lucene query.</p>
</div>
<div class="sect4">
<h5 id="_generality"><a class="anchor" href="#_generality"></a>Generality</h5>
<div class="paragraph">
<p>Once the Lucene query is built, it needs to be wrapped into an Hibernate Query. If not specified
otherwise, the query will be executed against all indexed entities, potentially returning all types
of indexed classes.</p>
</div>
<div class="exampleblock">
<div class="title">Example 91. Wrapping a Lucene query into a Hibernate Query</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">FullTextSession fullTextSession = Search.getFullTextSession( session );
org.hibernate.Query fullTextQuery = fullTextSession.createFullTextQuery( luceneQuery );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>It is advised, from a performance point of view, to restrict the returned types:</p>
</div>
<div id="example-filtering-by-entity-type" class="exampleblock">
<div class="title">Example 92. Filtering the search result by entity type</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">fullTextQuery = fullTextSession
    .createFullTextQuery(luceneQuery, Customer.class);

// or

fullTextQuery = fullTextSession
    .createFullTextQuery(luceneQuery, Item.class, Actor.class);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In <a href="#example-filtering-by-entity-type">Filtering the search result by entity type</a> the first example returns only matching <code>Customer</code> instances,
the second returns matching <code>Actor</code> and <code>Item</code> instances. The type restriction is fully polymorphic
which means that if there are two indexed subclasses <code>Salesman</code> and <code>Customer</code> of the baseclass
<code>Person</code>, it is possible to just specify <code>Person.class</code> in order to filter on result types.</p>
</div>
</div>
<div class="sect4">
<h5 id="_pagination"><a class="anchor" href="#_pagination"></a>Pagination</h5>
<div class="paragraph">
<p>Out of performance reasons it is recommended to restrict the number of returned objects per query.
In fact is a very common use case anyway that the user navigates from one page to an other. The way
to define pagination is exactly the way you would define pagination in a plain HQL or Criteria
query.</p>
</div>
<div class="exampleblock">
<div class="title">Example 93. Defining pagination for a search query</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">org.hibernate.Query fullTextQuery =
    fullTextSession.createFullTextQuery(luceneQuery, Customer.class);
fullTextQuery.setFirstResult(15); //start from the 15th element
fullTextQuery.setMaxResults(10); //return 10 elements</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>It is still possible to get the total number of matching elements regardless of the pagination via
fulltextQuery.getResultSize()</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="query-sorting"><a class="anchor" href="#query-sorting"></a>Sorting</h5>
<div class="paragraph">
<p>Apache Lucene provides a very flexible and powerful way to sort results. While the default sorting
(by relevance) is appropriate most of the time, it can be interesting to sort by one or several
other properties.</p>
</div>
<div class="paragraph">
<p>In order to do so, you will have to build a Lucene <code>Sort</code> object, which can be done by using either the Hibernate Search sort DSL or the native Lucene <code>SortField</code> class.</p>
</div>
<div class="paragraph">
<p>If you use the Hibernate Search sort DSL, it will look like this:</p>
</div>
<div class="exampleblock">
<div class="title">Example 94. Sorting the results with a DSL-built Lucene <code>Sort</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">QueryBuilder builder = fullTextSession.getSearchFactory()
    .buildQueryBuilder().forEntity(Book.class).get();
Query luceneQuery = /* ... */;
FullTextQuery query = s.createFullTextQuery( luceneQuery, Book.class );
Sort sort = builder
  .sort()
    .byField("author").desc() // Descending order
    .andByField("title") // Default order (ascending)
  .createSort();
query.setSort(sort);
List results = query.list();</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If you use the Sort DSL (like in the example above) to target fields indexed through <strong>custom</strong> <code>FieldBridge</code>s,
then those field bridges must implement <a href="#metadata-providing-field-bridge"><code>MetadataProvidingFieldBridge</code></a>,
so as to define the type of those fields and to mention that they are sortable.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Alternatively, you may build your sort using the Lucene <code>SortField</code> class directly. Then you will have to always specify the sort field type manually.</p>
</div>
<div class="exampleblock">
<div class="title">Example 95. Sorting the results with a custom-built Lucene <code>Sort</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">FullTextQuery query = s.createFullTextQuery( luceneQuery, Book.class );
org.apache.lucene.search.Sort sort = new Sort(
    new SortField("author", SortField.Type.STRING),
    new SortField("title", SortField.Type.STRING));
query.setSort(sort);
List results = query.list();</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Be aware that fields used for sorting must not be tokenized (see <a href="#field-annotation">@Field</a>). Also they should
be marked as sortable field using the <code>@SortableField</code> annotation (see <a href="#sortablefield-annotation">@SortableField</a>).</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect5">
<h6 id="_handling_missing_values"><a class="anchor" href="#_handling_missing_values"></a>Handling missing values</h6>
<div class="paragraph">
<p>By default, Hibernate Search will expect every document to contain exactly one value for the given sort fields. If it&#8217;s not the case, you may decide whether documents with missing values will end up in first or last position in the result list:</p>
</div>
<div class="exampleblock">
<div class="title">Example 96. Returning documents with missing values in first position when sorting</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">QueryBuilder builder = fullTextSession.getSearchFactory()
    .buildQueryBuilder().forEntity(Book.class).get();
Query luceneQuery = /* ... */;
FullTextQuery query = s.createFullTextQuery( luceneQuery, Book.class );
Sort sort = builder
  .sort()
    .byField("author")
      .onMissingValue().sortFirst()
    .andByField("title")
  .createSort();
query.setSort(sort);
List results = query.list();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>For numeric fields (and only numeric fields), you may even provide a default value to be used in case it&#8217;s missing:</p>
</div>
<div class="exampleblock">
<div class="title">Example 97. Using a default value on a sort field</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">QueryBuilder builder = fullTextSession.getSearchFactory()
    .buildQueryBuilder().forEntity(Book.class).get();
Query luceneQuery = /* ... */;
FullTextQuery query = s.createFullTextQuery( luceneQuery, Book.class );
Sort sort = builder
  .sort()
    .byField("authorId")
      .onMissingValue().use(42L) // Assume the ID is 42 when it's missing
    .andByField("title")
  .createSort();
query.setSort(sort);
List results = query.list();</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The <code>use(Object)</code> method expects a value matching the actual type of the field. Field bridges, if any, are <strong>not</strong> applied.
Thus, in the example above, providing an <code>Author</code> instead of the identifier directly would not work.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="_using_native_sorts_within_the_sort_dsl"><a class="anchor" href="#_using_native_sorts_within_the_sort_dsl"></a>Using native sorts within the sort DSL</h6>
<div class="paragraph">
<p>If you happen to find a sorting feature that is supported by Lucene, but not yet implemented in Hibernate Search sort DSL. If so, you may still use the DSL to mix a native <code>SortField</code> with DSL-defined sorts:</p>
</div>
<div class="exampleblock">
<div class="title">Example 98. Mixing DSL-defined sorts with native Lucene <code>SortField</code>s</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">QueryBuilder builder = fullTextSession.getSearchFactory()
    .buildQueryBuilder().forEntity(Book.class).get();
Query luceneQuery = /* ... */;
FullTextQuery query = s.createFullTextQuery( luceneQuery, Book.class );
SortField complexSortField = /* ... */;
Sort sort = builder
  .sort()
    .byField("author")
    .andByNative(complexSortField)
  .createSort();
query.setSort(sort);
List results = query.list();</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_fetching_strategy"><a class="anchor" href="#_fetching_strategy"></a>Fetching strategy</h5>
<div class="paragraph">
<p>When you restrict the return types to one class, Hibernate Search loads the objects using a single
query. It also respects the static fetching strategy defined in your domain model.</p>
</div>
<div class="paragraph">
<p>It is often useful, however, to refine the fetching strategy for a specific use case.</p>
</div>
<div class="exampleblock">
<div class="title">Example 99. Specifying FetchMode on a query</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Criteria criteria =
    s.createCriteria(Book.class).setFetchMode("authors", FetchMode.JOIN);
s.createFullTextQuery(luceneQuery).setCriteriaQuery(criteria);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In this example, the query will return all Books matching the luceneQuery. The authors collection
will be loaded from the same query using an SQL outer join.</p>
</div>
<div class="paragraph">
<p>When defining a criteria query, it is not necessary to restrict the returned entity types when
creating the Hibernate Search query from the full text session: the type is guessed from the
criteria query itself.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Only fetch mode can be adjusted, refrain from applying any other restriction. While it is known to
work as of Hibernate Search 4, using restriction (ie a where clause) on your Criteria query should
be avoided when possible. <code>getResultSize()</code> will throw a <code>SearchException</code> if used in conjunction with a
Criteria with restriction.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>You cannot use setCriteriaQuery if more than one entity type is expected to be returned.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="projections"><a class="anchor" href="#projections"></a>Projection</h5>
<div class="paragraph">
<p>For some use cases, returning the domain object (including its associations) is overkill. Only a
small subset of the properties is necessary. Hibernate Search allows you to return a subset of
properties:</p>
</div>
<div class="exampleblock">
<div class="title">Example 100. Using projection instead of returning the full domain object</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">org.hibernate.search.FullTextQuery query =
    s.createFullTextQuery(luceneQuery, Book.class);
query.setProjection("id", "summary", "body", "mainAuthor.name");
List results = query.list();
Object[] firstResult = (Object[]) results.get(0);
Integer id = firstResult[0];
String summary = firstResult[1];
String body = firstResult[2];
String authorName = firstResult[3];</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Hibernate Search extracts the properties from the Lucene index and convert them back to their object
representation, returning a list of <code>Object[]</code>. Projections avoid a potential database round trip
(useful if the query response time is critical). However, it also has several constraints:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the properties projected must be stored in the index (<code>@Field(store=Store.YES)</code>), which
increases the index size</p>
</li>
<li>
<p>the properties projected must use a <code>FieldBridge</code> implementing org.hibernate.search.bridge.TwoWayFieldBridge or <code>org.hibernate.search.bridge.TwoWayStringBridge</code>, the latter being the simpler version.</p>
</li>
<li>
<p>you can only project simple properties of the indexed entity or its embedded associations.
This means you cannot project a whole embedded entity.</p>
</li>
<li>
<p>projection does not work on collections or maps which are indexed via <code>@IndexedEmbedded</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Projection is also useful for another kind of use case. Lucene can provide metadata information
about the results. By using some special projection constants, the projection mechanism can retrieve
this metadata:</p>
</div>
<div class="exampleblock">
<div class="title">Example 101. Using projection in order to retrieve meta data</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">org.hibernate.search.FullTextQuery query =
    s.createFullTextQuery(luceneQuery, Book.class);
query.setProjection(
    FullTextQuery.SCORE,
    FullTextQuery.THIS,
    "mainAuthor.name" );
List results = query.list();
Object[] firstResult = (Object[]) results.get(0);
float score = firstResult[0];
Book book = firstResult[1];
String authorName = firstResult[2];</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You can mix and match regular fields and projection constants. Here is the list of the available
constants:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>FullTextQuery.THIS</code>: returns the initialized and managed entity (as a non projected query would
have done).</p>
</li>
<li>
<p><code>FullTextQuery.DOCUMENT</code>: returns the Lucene Document related to the object projected.</p>
</li>
<li>
<p><code>FullTextQuery.OBJECT_CLASS</code>: returns the class of the indexed entity.</p>
</li>
<li>
<p><code>FullTextQuery.SCORE</code>: returns the document score in the query. Scores are handy to compare one
result against an other for a given query but are useless when comparing the result of different
queries.</p>
</li>
<li>
<p><code>FullTextQuery.ID</code>: the id property value of the projected object.</p>
</li>
<li>
<p><code>FullTextQuery.DOCUMENT_ID</code>: the Lucene document id. Careful, Lucene document id can change
overtime between two different IndexReader opening.</p>
</li>
<li>
<p><code>FullTextQuery.EXPLANATION</code>: returns the Lucene Explanation object for the matching object/document
in the given query. Do not use if you retrieve a lot of data. Running explanation typically is as
costly as running the whole Lucene query per matching element. Make sure you use projection!</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_customizing_object_initialization_strategies"><a class="anchor" href="#_customizing_object_initialization_strategies"></a>Customizing object initialization strategies</h5>
<div class="paragraph">
<p>By default, Hibernate Search uses the most appropriate strategy to initialize entities matching your
full text query. It executes one (or several) queries to retrieve the required entities. This is the
best approach to minimize database round trips in a scenario where none / few of the retrieved
entities are present in the persistence context (ie the session) or the second level cache.</p>
</div>
<div class="paragraph">
<p>If most of your entities are present in the second level cache, you can force Hibernate Search to
look into the cache before retrieving an object from the database.</p>
</div>
<div class="exampleblock">
<div class="title">Example 102. Check the second-level cache before using a query</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">FullTextQuery query = session.createFullTextQuery(luceneQuery, User.class);
query.initializeObjectWith(
    ObjectLookupMethod.SECOND_LEVEL_CACHE,
    DatabaseRetrievalMethod.QUERY
);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>ObjectLookupMethod</code> defines the strategy used to check if an object is easily accessible (without
database round trip). Other options are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ObjectLookupMethod.PERSISTENCE_CONTEXT</code>: useful if most of the matching entities are
already in the persistence context (ie loaded in the Session or EntityManager)</p>
</li>
<li>
<p><code>ObjectLookupMethod.SECOND_LEVEL_CACHE</code>: check first the persistence context and then
the second-level cache.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Note that to search in the second-level cache, several settings must be in place:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the second level cache must be properly configured and active</p>
</li>
<li>
<p>the entity must have enabled second-level cache (eg via <code>@Cacheable</code>)</p>
</li>
<li>
<p>the <code>Session</code>, <code>EntityManager</code> or <code>Query</code> must allow access to the second-level cache for
read access (ie <code>CacheMode.NORMAL</code> in Hibernate native APIs or <code>CacheRetrieveMode.USE</code> in JPA 2 APIs).</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Avoid using <code>ObjectLookupMethod.SECOND_LEVEL_CACHE</code> unless your second level cache
implementation is either EHCache or Infinispan; other second level cache providers don&#8217;t currently
implement this operation efficiently.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can also customize how objects are loaded from the database (if not found before). Use
<code>DatabaseRetrievalMethod</code> for that:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>QUERY</code> (default): use a (set of) queries to load several objects in batch. This is usually the
best approach.</p>
</li>
<li>
<p><code>FIND_BY_ID</code>: load objects one by one using the <code>Session.get</code> or <code>EntityManager.find</code> semantic.
This might be useful if batch-size is set on the entity (in which case, entities will be loaded in
batch by Hibernate Core). QUERY should be preferred almost all the time.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The defaults for both methods, the object lookup as well as the database retrieval can also be
configured via configuration properties. This way you don&#8217;t have to specify your preferred methods on
each query creation. The property names are <code>hibernate.search.query.object_lookup_method</code>
and <code>hibernate.search.query.database_retrieval_method</code> respectively. As value use the name of the
method (upper- or lowercase). For example:</p>
</div>
<div class="exampleblock">
<div class="title">Example 103. Setting object lookup and database retrieval methods via configuration properties</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>hibernate.search.query.object_lookup_method = second_level_cache
hibernate.search.query.database_retrieval_method = query</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_limiting_the_time_of_a_query"><a class="anchor" href="#_limiting_the_time_of_a_query"></a>Limiting the time of a query</h5>
<div class="paragraph">
<p>You can limit the time a query takes in Hibernate Search in two ways:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>raise an exception when the limit is reached</p>
</li>
<li>
<p>limit to the number of results retrieved when the time limit is raised</p>
</li>
</ul>
</div>
<div class="sect5">
<h6 id="_raise_an_exception_on_time_limit"><a class="anchor" href="#_raise_an_exception_on_time_limit"></a>Raise an exception on time limit</h6>
<div class="paragraph">
<p>You can decide to stop a query if when it takes more than a predefined amount of time. Note that
this is a best effort basis but if Hibernate Search still has significant work to do and if we are
beyond the time limit, a QueryTimeoutException will be raised (org.hibernate.QueryTimeoutException
or javax.persistence.QueryTimeoutException depending on your programmatic API).</p>
</div>
<div class="paragraph">
<p>To define the limit when using the native Hibernate APIs, use one of the following approaches</p>
</div>
<div class="exampleblock">
<div class="title">Example 104. Defining a timeout in query execution</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Query luceneQuery = ...;
FullTextQuery query = fullTextSession.createFullTextQuery(luceneQuery, User.class);

//define the timeout in seconds
query.setTimeout(5);

//alternatively, define the timeout in any given time unit
query.setTimeout(450, TimeUnit.MILLISECONDS);

try {
    query.list();
}
catch (org.hibernate.QueryTimeoutException e) {
    //do something, too slow
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Likewise <code>getResultSize()</code>, <code>iterate()</code> and <code>scroll()</code> honor the timeout but only until the end of
the method call. That simply means that the methods of Iterable or the ScrollableResults ignore the
timeout.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>explain()</code> does not honor the timeout: this method is used for debug purposes and in particular to find out why a query is slow</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When using JPA, simply use the standard way of limiting query execution time.</p>
</div>
<div class="exampleblock">
<div class="title">Example 105. Defining a timeout in query execution</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Query luceneQuery = ...;
FullTextQuery query = fullTextEM.createFullTextQuery(luceneQuery, User.class);

//define the timeout in milliseconds
query.setHint( "javax.persistence.query.timeout", 450 );

try {
    query.getResultList();
}
catch (javax.persistence.QueryTimeoutException e) {
    //do something, too slow
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Remember, this is a best effort approach and does not guarantee to stop exactly on the specified timeout.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="_limit_the_number_of_results_when_the_time_limit_is_reached"><a class="anchor" href="#_limit_the_number_of_results_when_the_time_limit_is_reached"></a>Limit the number of results when the time limit is reached</h6>
<div class="paragraph">
<p>Alternatively, you can return the number of results which have already been fetched by the time the
limit is reached. Note that only the Lucene part of the query is influenced by this limit. It is
possible that, if you retrieve managed object, it takes longer to fetch these objects.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>This approach is not compatible with the setTimeout approach.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To define this soft limit, use the following approach</p>
</div>
<div class="exampleblock">
<div class="title">Example 106. Defining a time limit in query execution</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Query luceneQuery = ...;
FullTextQuery query = fullTextSession.createFullTextQuery(luceneQuery, User.class);

//define the timeout in seconds
query.limitExecutionTimeTo(500, TimeUnit.MILLISECONDS);
List results = query.list();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Likewise <code>getResultSize()</code>, <code>iterate()</code> and <code>scroll()</code> honor the time limit but only until the end
of the method call. That simply means that the methods of Iterable or the <code>ScrollableResults</code> ignore
the timeout.</p>
</div>
<div class="paragraph">
<p>You can determine if the results have been partially loaded by invoking the <code>hasPartialResults</code>
method.</p>
</div>
<div class="exampleblock">
<div class="title">Example 107. Determines when a query returns partial results</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Query luceneQuery = ...;
FullTextQuery query = fullTextSession.createFullTextQuery(luceneQuery, User.class);

//define the timeout in seconds
query.limitExecutionTimeTo(500, TimeUnit.MILLISECONDS);
List results = query.list();

if ( query.hasPartialResults() ) {
    displayWarningToUser();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If you use the JPA API, limitExecutionTimeTo and hasPartialResults are also available to you.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_retrieving_the_results"><a class="anchor" href="#_retrieving_the_results"></a>5.2. Retrieving the results</h3>
<div class="paragraph">
<p>Once the Hibernate Search query is built, executing it is in no way different than executing a HQL
or Criteria query. The same paradigm and object semantic applies. All the common operations are
available: <code>list()</code>, <code>uniqueResult()</code>, <code>iterate()</code>, <code>scroll()</code>.</p>
</div>
<div class="sect3">
<h4 id="_performance_considerations"><a class="anchor" href="#_performance_considerations"></a>5.2.1. Performance considerations</h4>
<div class="paragraph">
<p>If you expect a reasonable number of results (for example using pagination) and expect to work on
all of them, <code>list()</code> or <code>uniqueResult()</code> are recommended. <code>list()</code> work best if the entity <code>batch-size</code>
is set up properly. Note that Hibernate Search has to process all Lucene Hits elements (within the
pagination) when using <code>list()</code> , <code>uniqueResult()</code> and <code>iterate()</code>.</p>
</div>
<div class="paragraph">
<p>If you wish to minimize Lucene document loading, <code>scroll()</code> is more appropriate. Don&#8217;t forget to close
the <code>ScrollableResults</code> object when you&#8217;re done, since it keeps Lucene resources. If you expect to use
scroll, but wish to load objects in batch, you can use <code>query.setFetchSize()</code>. When an object is
accessed, and if not already loaded, Hibernate Search will load the next <code>fetchSize</code> objects in one
pass.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Pagination is preferred over scrolling.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_result_size"><a class="anchor" href="#_result_size"></a>5.2.2. Result size</h4>
<div class="paragraph">
<p>It is sometimes useful to know the total number of matching documents:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>for the Google-like feature "1-10 of about 888,000,000"</p>
</li>
<li>
<p>to implement a fast pagination navigation</p>
</li>
<li>
<p>to implement a multi step search engine (adding approximation if the restricted query return no
or not enough results)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Of course it would be too costly to retrieve all the matching documents. Hibernate Search allows you
to retrieve the total number of matching documents regardless of the pagination parameters. Even
more interesting, you can retrieve the number of matching elements without triggering a single
object load.</p>
</div>
<div class="exampleblock">
<div class="title">Example 108. Determining the result size of a query</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">org.hibernate.search.FullTextQuery query =
    s.createFullTextQuery(luceneQuery, Book.class);
//return the number of matching books without loading a single one
assert 3245 == query.getResultSize();

org.hibernate.search.FullTextQuery query =
    s.createFullTextQuery(luceneQuery, Book.class);
query.setMaxResult(10);
List results = query.list();
//return the total number of matching books regardless of pagination
assert 3245 == query.getResultSize();</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Like Google, the number of results is an approximation if the index is not fully up-to-date with the
database (asynchronous cluster for example).</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_resulttransformer"><a class="anchor" href="#_resulttransformer"></a>5.2.3. ResultTransformer</h4>
<div class="paragraph">
<p>As seen in <a href="#projections">Projection</a> projection results are returns as Object arrays. This data structure is
not always matching the application needs. In this cases It is possible to apply a ResultTransformer
which post query execution can build the needed data structure:</p>
</div>
<div class="exampleblock">
<div class="title">Example 109. Using ResultTransformer in conjunction with projections</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">org.hibernate.search.FullTextQuery query =
    s.createFullTextQuery(luceneQuery, Book.class);
query.setProjection("title", "mainAuthor.name");

query.setResultTransformer(
    new StaticAliasToBeanResultTransformer(
        BookView.class,
        "title",
        "author" )
);
ListBookView&gt;; results = (List&lt;BookView&gt;) query.list();
for (BookView view : results) {
    log.info("Book: " + view.getTitle() + ", " + view.getAuthor());
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Examples of ResultTransformer implementations can be found in the Hibernate Core codebase.</p>
</div>
</div>
<div class="sect3">
<h4 id="_understanding_results"><a class="anchor" href="#_understanding_results"></a>5.2.4. Understanding results</h4>
<div class="paragraph">
<p>You will find yourself sometimes puzzled by a result showing up in a query or a result not showing
up in a query. Luke is a great tool to understand those mysteries. However, Hibernate Search also
gives you access to the Lucene Explanation object for a given result (in a given query). This class
is considered fairly advanced to Lucene users but can provide a good understanding of the scoring of
an object. You have two ways to access the Explanation object for a given result:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Use the fullTextQuery.explain(int) method</p>
</li>
<li>
<p>Use projection</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The first approach takes a document id as a parameter and return the Explanation object. The
document id can be retrieved using projection and the <code>FullTextQuery.DOCUMENT_ID</code> constant.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The Document id has nothing to do with the entity id. Do not mess up these two notions.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In the second approach you project the Explanation object using the <code>FullTextQuery.EXPLANATION</code>
constant.</p>
</div>
<div class="exampleblock">
<div class="title">Example 110. Retrieving the Lucene Explanation object using projection</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">FullTextQuery ftQuery = s.createFullTextQuery( luceneQuery, Dvd.class )
        .setProjection(
             FullTextQuery.DOCUMENT_ID,
             FullTextQuery.EXPLANATION,
             FullTextQuery.THIS );
@SuppressWarnings("unchecked") List&lt;Object[]&gt; results = ftQuery.list();
for (Object[] result : results) {
    Explanation e = (Explanation) result[1];
    display( e.toString() );
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Be careful, building the explanation object is quite expensive, it is roughly as expensive as
running the Lucene query again. Don&#8217;t do it if you don&#8217;t need the object</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="query-filter"><a class="anchor" href="#query-filter"></a>5.3. Filters</h3>
<div class="sect3">
<h4 id="query-filter-fulltext"><a class="anchor" href="#query-filter-fulltext"></a>5.3.1. Full-text filters</h4>
<div class="paragraph">
<p>Apache Lucene has a powerful feature that allows to filter query results according to a custom
filtering process. This is a very powerful way to apply additional data restrictions, especially
since filters can be cached and reused. Some interesting use cases are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>security</p>
</li>
<li>
<p>temporal data (eg. view only last month&#8217;s data)</p>
</li>
<li>
<p>population filter (eg. search limited to a given category)</p>
</li>
<li>
<p>and many more</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Hibernate Search pushes the concept further by introducing the notion of parameterizable named
filters which are transparently cached. For people familiar with the notion of Hibernate Core
filters, the API is very similar:</p>
</div>
<div class="exampleblock">
<div class="title">Example 111. Enabling fulltext filters for a given query</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">fullTextQuery = s.createFullTextQuery(query, Driver.class);
fullTextQuery.enableFullTextFilter("bestDriver");
fullTextQuery.enableFullTextFilter("security").setParameter("login", "andre");
fullTextQuery.list(); //returns only best drivers where andre has credentials</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In this example we enabled two filters on top of the query. You can enable (or disable) as many
filters as you like.</p>
</div>
<div class="paragraph">
<p>Declaring filters is done through the <code>@FullTextFilterDef</code> annotation.
You can use one or more <code>@FullTextFilterDef</code> on any:
*<code>@Indexed</code> entity regardless of the query the filter is later applied to
* Parent class of an <code>@Indexed</code> entity
* package-info.java of a package containing an <code>@Indexed</code> entity</p>
</div>
<div class="paragraph">
<p>This implies that filter definitions are global and their names must be unique.
A <code>SearchException</code> is thrown in case two different <code>@FullTextFilterDef</code> annotations
with the same name are defined. Each named filter has to
specify a way to retrieve the actual filter implementation.</p>
</div>
<div class="exampleblock">
<div class="title">Example 112. Defining and implementing a Filter</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed
@FullTextFilterDef(name = "bestDriver", impl = BestDriversFilterFactory.class)
@FullTextFilterDef(name = "security", impl = SecurityFilterFactory.class)
public class Driver { ... }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public class BestDriversFilterFactory {

    @org.hibernate.search.annotations.Factory
    public Query create() {
        return new TermQuery( new Term( "score", "5" ) );
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>BestDriversFilterFactory</code> is an example of a simple Lucene filter which reduces the result set to drivers
whose score is 5.
In this example we use the factory pattern: the class assigned to <code>@FullTextFilterDef.impl</code> is a factory class,
and the actual filter will be returned by a <code>@Factory</code> annotated, no-argument method on this class.
Make sure the factory has a public constructor which does not require any parameter.</p>
</div>
<div class="paragraph">
<p>Alternatively, you can assign to <code>@FullTextFilterDef.impl</code> the exact type of your filter,
i.e. a class extending <code>org.apache.lucene.search.Query</code>.
The class will still have to provide a public, no-argument constructor.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph">
<p>In previous versions of Hibernate Search, filters had to extend the <code>org.apache.lucene.search.Filter</code> type
instead of <code>org.apache.lucene.search.Query</code>.</p>
</div>
<div class="paragraph">
<p>This is still supported, but the <code>Filter</code> type has been deprecated
and will be removed in a future version of Lucene.</p>
</div>
<div class="paragraph">
<p>Thus, it is advisable to convert your existing filters and filter factories
so as not to rely on the <code>org.apache.lucene.search.Filter</code> type anymore, and to use simple queries instead.
There should be a <code>Query</code> equivalent for every <code>Filter</code> subtype: <code>TermQuery</code> replaces <code>TermFilter</code>,
<code>BooleanQuery</code> replaces <code>BooleanFilter</code>, etc.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Named filters come in handy where parameters have to be passed to the filter. For example a security
filter might want to know which security level you want to apply:</p>
</div>
<div class="exampleblock">
<div class="title">Example 113. Passing parameters to a defined filter</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">fullTextQuery = s.createFullTextQuery(query, Driver.class);
fullTextQuery.enableFullTextFilter("security").setParameter("level", 5);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Each parameter must have an associated setter on either the filter or filter factory of the
targeted named filter definition.</p>
</div>
<div class="exampleblock">
<div class="title">Example 114. Using parameters in the actual filter implementation</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public class SecurityFilterFactory {
    private Integer level;

    /**
     * injected parameter
     */
    public void setLevel(Integer level) {
        this.level = level;
    }

    @Factory
    public Query getFilter() {
        return new TermQuery( new Term( "level", level.toString() ) );
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Filters will be cached once created, based on all their parameter names and values.
Caching happens using a combination of
hard and soft references to allow disposal of memory when needed. The hard reference cache keeps
track of the most recently used filters and transforms the ones least used to SoftReferences when
needed. Once the limit of the hard reference cache is reached additional filters are cached as
SoftReferences. To adjust the size of the hard reference cache, use
<code>hibernate.search.filter.cache_strategy.size</code> (defaults to 128). For advanced use of filter
caching, you can implement your own FilterCachingStrategy. The classname is defined by
<code>hibernate.search.filter.cache_strategy</code>.</p>
</div>
<div class="paragraph">
<p>This filter caching mechanism should not be confused with caching the actual filter results. In
Lucene it is common practice to wrap filters using the IndexReader around a <code>CachingWrapperQuery</code>.
The wrapper will cache the set of matching documents to
avoid expensive re-computation. It is important to mention that the computed set of matching documents is only
cachable for the same IndexReader instance, because the reader effectively represents the state of
the index at the moment it was opened. The document list cannot change within an opened
<code>IndexReader</code>. A different/new <code>IndexReader</code> instance, however, works potentially on a different set
of documents (either from a different index or simply because the index has changed), hence the
filter result has to be recomputed.</p>
</div>
<div class="paragraph">
<p>Hibernate Search also helps with this aspect of caching. Per default the <code>cache</code> flag of
<code>@FullTextFilterDef</code> is set to <code>FilterCacheModeType.INSTANCE_AND_DOCIDSETRESULTS</code> which will
automatically cache the filter instance as well as wrap the specified filter around a Hibernate
specific implementation of <code>CachingWrapperQuery</code>. In contrast to Lucene&#8217;s version of this class
<code>SoftReferences</code> are used together with a hard reference count (see discussion about filter cache).
The hard reference count can be adjusted using <code>hibernate.search.filter.cache_docidresults.size</code>
(defaults to 5). The wrapping behavior can be controlled using the <code>@FullTextFilterDef.cache</code>
parameter. There are three different values for this parameter:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Value</th>
<th class="tableblock halign-left valign-top">Definition</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">FilterCacheModeType.NONE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No filter instance and no result is cached by Hibernate
              Search. For every filter call, a new filter instance is created.
              This setting might be useful for rapidly changing data sets or
              heavily memory constrained environments.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">FilterCacheModeType.INSTANCE_ONLY</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The filter instance is cached and reused across
              concurrent filter calls.
              Filter results are not cached. This
              setting is useful when a filter uses its own specific caching
              mechanism or the filter results change dynamically due to
              application specific events making filter results caching in both cases
              unnecessary.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">FilterCacheModeType.INSTANCE_AND_DOCIDSETRESULTS</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Both the filter instance and the
              filter results are cached. This is the
              default value.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Last but not least - why should filters be cached? There are two areas where filter caching shines:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the system does not update the targeted entity index often (in other words, the IndexReader is
reused a lot)</p>
</li>
<li>
<p>the filter&#8217;s result is expensive to compute (compared to the time spent to execute the query)</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="query-filter-shard"><a class="anchor" href="#query-filter-shard"></a>5.3.2. Using filters in a sharded environment</h4>
<div class="paragraph">
<p>It is possible, in a sharded environment to execute queries on a subset of the available shards.
This can be done in two steps:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>create a sharding strategy that does select a subset of IndexManagers depending on some filter configuration</p>
</li>
<li>
<p>activate the proper filter at query time</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Let&#8217;s first look at an example of sharding strategy that query on a specific customer shard if the
customer filter is activated.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public class CustomerShardingStrategy implements IndexShardingStrategy {

 // stored IndexManagers in a array indexed by customerID
 private IndexManager[] indexManagers;

 public void initialize(Properties properties, IndexManager[] indexManagers) {
   this.indexManagers = indexManagers;
 }

 public IndexManager[] getIndexManagersForAllShards() {
   return indexManagers;
 }

 public IndexManager getIndexManagerForAddition(
     Class&lt;?&gt; entity, Serializable id, String idInString, Document document) {
   Integer customerID = Integer.parseInt(document.getFieldable("customerID").stringValue());
   return indexManagers[customerID];
 }

 public IndexManager[] getIndexManagersForDeletion(
     Class&lt;?&gt; entity, Serializable id, String idInString) {
   return getIndexManagersForAllShards();
 }

  /**
  * Optimization; don't search ALL shards and union the results; in this case, we
  * can be certain that all the data for a particular customer Filter is in a single
  * shard; simply return that shard by customerID.
  */
 public IndexManager[] getIndexManagersForQuery(
     FullTextFilterImplementor[] filters) {
   FullTextFilter filter = getCustomerFilter(filters, "customer");
   if (filter == null) {
     return getIndexManagersForAllShards();
   }
   else {
     return new IndexManager[] { indexManagers[Integer.parseInt(
       filter.getParameter("customerID").toString())] };
   }
 }

 private FullTextFilter getCustomerFilter(FullTextFilterImplementor[] filters, String name) {
   for (FullTextFilterImplementor filter: filters) {
     if (filter.getName().equals(name)) return filter;
   }
   return null;
 }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In this example, if the filter named <code>customer</code> is present, we make sure to only use the shard
dedicated to this customer. Otherwise, we return all shards. A given Sharding strategy can react to
one or more filters and depends on their parameters.</p>
</div>
<div class="paragraph">
<p>The second step is simply to activate the filter at query time. While the filter can be a regular
filter (as defined in <a href="#query-filter-fulltext">Full-text filters</a>) which also filters Lucene results after the query, you can
make use of a special filter that will only be passed to the sharding strategy and otherwise ignored
for the rest of the query. Simply use the <code>ShardSensitiveOnlyFilter</code> class when declaring your filter.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity @Indexed
@FullTextFilterDef(name="customer", impl=ShardSensitiveOnlyFilter.class)
public class Customer {
   // ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">FullTextQuery query = ftEm.createFullTextQuery(luceneQuery, Customer.class);
query.enableFulltextFilter("customer").setParameter("CustomerID", 5);
@SuppressWarnings("unchecked")
List&lt;Customer&gt; results = query.getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Note that by using the <code>ShardSensitiveOnlyFilter</code>, you do not have to implement any Lucene filter.
Using filters and sharding strategy reacting to these filters is recommended to speed up queries in
a sharded environment.</p>
</div>
</div>
<div class="sect3">
<h4 id="query-filter-orm"><a class="anchor" href="#query-filter-orm"></a>5.3.3. Hibernate ORM filters</h4>
<div class="paragraph">
<p>Hibernate ORM filters, enabled using <code>org.hibernate.Session.enableFilter(String)</code>,
will only work partially when combined with a full-text query.</p>
</div>
<div class="paragraph">
<p>The filtered entities will be excluded from the results, but:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the result size returned by <code>FullTextQuery.getResultSize()</code> will ignore the filters
(it will return the size before applying the filters);</p>
</li>
<li>
<p>if you use paging, the <code>setFirstResult</code> and <code>setMaxResults</code> modifiers will be applied
before the filters, leading to some result pages being smaller than <code>maxResults</code>
(or even empty) even though they are not the last.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These limitations are necessary to keep performance at a reasonable level.
If they are not acceptable for your use case,
you should use <a href="#query-filter-fulltext">full-text filters</a> in your full-text queries.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="query-faceting"><a class="anchor" href="#query-faceting"></a>5.4. Faceting</h3>
<div class="paragraph">
<p><a href="http://en.wikipedia.org/wiki/Faceted_search">Faceted search</a> is a technique which allows to
divide the results of a query into multiple categories. This categorization includes the calculation
of hit counts for each category and the ability to further restrict search results based on these
facets (categories). <a href="#example-amazon-facets">Facets Example on Amazon</a> shows a faceting example. The search for 'Hibernate
Search' results in fifteen hits which are displayed on the main part of the page. The navigation bar
on the left, however, shows the category<em>Computers &amp; Internet</em> with its subcategories
<em>Programming</em>, <em>Computer Science</em>, <em>Databases</em>, <em>Software</em>, <em>Web Development,</em>
<em>Networking</em> and <em>Home Computing</em>. For each of these subcategories the number of books is shown
matching the main search criteria and belonging to the respective subcategory. This division of the
category <em>Computers &amp; Internet</em> is one facet of this search. Another one is for example the
average customer review rating.</p>
</div>
<div id="example-amazon-facets" class="imageblock">
<div class="content">
<img src="images/faceting.png" alt="Search for _'Hibernate Search'_ on Amazon">
</div>
<div class="title">Figure 1. Facets Example on Amazon</div>
</div>
<div class="paragraph">
<p>In Hibernate Search the classes <code>QueryBuilder</code> and <code>FullTextQuery</code> are the entry point to the faceting
API. The former allows to create faceting requests whereas the latter gives access to the so called
<code>FacetManager</code>. With the help of the <code>FacetManager</code> faceting requests can be applied on a query and
selected facets can be added to an existing query in order to refine search results. The following
sections will describe the faceting process in more detail. The examples will use the entity <code>Cd</code> as
shown in <a href="#example-faceting-entity">Example entity for faceting</a>:</p>
</div>
<div id="example-faceting-entity" class="exampleblock">
<div class="title">Example 115. Example entity for faceting</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed
public class Cd {

    @Id
    @GeneratedValue
    private int id;

    @Field,
    private String name;

    @Field(analyze = Analyze.NO)
    @Facet
    private int price;

    @Field(analyze = Analyze.NO)
    @DateBridge(resolution = Resolution.YEAR)
    @Facet
    private Date releaseYear;

    @Field(analyze = Analyze.NO)
    @Facet
    private String label;


// setter/getter
// ...</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In order to facet on a given indexed field, the field needs to be configured with the <code>@Facet</code>
annotation. Also, the field itself cannot be analyzed.</p>
</div>
<div class="paragraph">
<p><code>@Facet</code> contains a <code>name</code> and <code>forField</code> parameter. The <code>name</code> is arbitrary and used to identify
the facet. Per default it matches the field name it belongs to. <code>forField</code> is relevant in case the
property is mapped to multiple fields using <code>@Field</code> multiple times, as it is a repeatable annotation.
In this case <code>forField</code> can be used to identify the index field to which it applies.
Both <code>@Field</code> and <code>@Facet</code> are repeatable annotations.</p>
</div>
<div class="paragraph">
<p>Last but not least, <code>@Facet</code> contains a
<code>encoding</code> parameter. Usually, Hibernate Search automatically selects the encoding:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>String fields are encoded as <code>FacetEncodingType.STRING</code></p>
</li>
<li>
<p><code>byte</code>, <code>short</code>, <code>int</code>, <code>long</code> (including corresponding wrapper types) and <code>Date</code>
as <code>FacetEncodingType.LONG</code></p>
</li>
<li>
<p>and <code>float</code> and <code>double</code> (including corresponding wrapper types) as <code>FacetEncodingType.DOUBLE</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In some cases it can make sense, however, to explicitly set the encoding.
<a href="#discrete-faceting-request">Discrete faceting request</a>s for example only work for string encoded
facets. In order to use a discrete facet for numbers the encoding must be explicitly set to
<code>FacetEncodingType.STRING</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Pre Hibernate Search 5.2 there was no need to explicitly use a <code>@Facet</code> annotation. In 5.2 it became
necessary in order to use Lucene&#8217;s native faceting API.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="section-creating-faceting-request"><a class="anchor" href="#section-creating-faceting-request"></a>5.4.1. Creating a faceting request</h4>
<div class="paragraph">
<p>The first step towards a faceted search is to create the <code>FacetingRequest</code>. Currently two types of
faceting requests are supported. The first type is called <em>discrete faceting</em> and the second type
<em>range faceting</em> request.</p>
</div>
<div class="sect4">
<h5 id="discrete-faceting-request"><a class="anchor" href="#discrete-faceting-request"></a>Discrete faceting request</h5>
<div class="paragraph">
<p>In the case of a discrete faceting request, you start with giving the request a unique name. This
name will later be used to retrieve the facet values (see <a href="#section-interpreting-facet-result">Interpreting a Facet result</a>).
Then you need to specify on which index field you want to categorize on and which faceting options
to apply. An example for a discrete faceting request can be seen in <a href="#example-discrete-faceting">Creating a discrete faceting request</a>:</p>
</div>
<div id="example-discrete-faceting" class="exampleblock">
<div class="title">Example 116. Creating a discrete faceting request</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">QueryBuilder builder = fullTextSession.getSearchFactory()
    .buildQueryBuilder().forEntity(Cd.class).get();

FacetingRequest labelFacetingRequest = builder.facet()
    .name("labelFacetRequest")
    .onField("label")
    .discrete()
    .orderedBy(FacetSortOrder.COUNT_DESC)
    .includeZeroCounts(false)
    .maxFacetCount(3)
    .createFacetingRequest();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>When executing this faceting request a <code>Facet</code> instance will be created for each discrete value for
the indexed field <code>label</code>. The <code>Facet</code> instance will record the actual field value including how often
this particular field value occurs within the original query results. Parameters <code>orderedBy</code>,
<code>includeZeroCounts</code> and <code>maxFacetCount</code> are optional and can be applied on any faceting request.
Parameter <code>orderedBy</code> allows to specify in which order the created facets will be returned. The
default is <code>FacetSortOrder.COUNT_DESC</code>, but you can also sort on the field value. Parameter
<code>includeZeroCount</code> determines whether facets with a count of 0 will be included in the result (by
default they are not) and <code>maxFacetCount</code> allows to limit the maximum amount of facets returned.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>There are several preconditions an indexed field has to meet in order to categorize (facet) on it:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The indexed property must be of type <code>String</code>, <code>Date</code> or of the numeric type byte, shirt, int,
long, double or float (or their respective Java wrapper types).</p>
</li>
<li>
<p>The property has to be indexed with Analyze.NO.</p>
</li>
<li>
<p><em>null</em> values should be avoided.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When you need conflicting options, we suggest to index the property twice and use the appropriate
 field depending on the use case:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Field(name="price")
@Field(name="price_facet",
       analyze=Analyze.NO,
       bridge=@FieldBridge(impl = IntegerBridge.class))
private int price;</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="range-faceting-request"><a class="anchor" href="#range-faceting-request"></a>Creating a range faceting request</h5>
<div class="paragraph">
<p>The creation of a range faceting request is similar. We also start with a name for the request and
the field to facet on. Then we have to specify ranges for the field values. A range faceting request
can be seen in <a href="#example-range-faceting">Creating a range faceting request</a>. There, three different price ranges are specified. <code>below</code>
and <code>above</code> can only be specified once, but you can specify as many <code>from</code> - <code>to</code> ranges as you want.
For each range boundary you can also specify via <code>excludeLimit</code> whether it is included into the range
or not.</p>
</div>
<div id="example-range-faceting" class="exampleblock">
<div class="title">Example 117. Creating a range faceting request</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">QueryBuilder builder = fullTextSession.getSearchFactory()
    .buildQueryBuilder()
        .forEntity(Cd.class)
            .get();
FacetingRequest priceFacetingRequest = builder.facet()
    .name("priceFaceting")
    .onField("price_facet")
    .range()
    .below(1000)
    .from(1001).to(1500)
    .above(1500).excludeLimit()
    .createFacetingRequest();</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="section-sorting-faceting-request"><a class="anchor" href="#section-sorting-faceting-request"></a>5.4.2. Setting the facet sort order</h4>
<div class="paragraph">
<p>The result of applying a faceting request is a list of <code>Facet</code> instances as seen in
<a href="#example-applying-faceting">Applying a faceting request</a>. The order within the list is given by the <code>FacetSortOrder</code> parameter
specified via <code>orderedBy</code> when creating the faceting request. The default value is
<code>FacetSortOrder.COUNT_DESC</code>, meaning facets are ordered by their count in descending order (highest
count first). Other values are <code>COUNT_ASC</code>, <code>FIELD_VALUE</code> and <code>RANGE_DEFINITION_ORDER</code>. <code>COUNT_ASC</code>
returns the facets in ascending count order whereas <code>FIELD_VALUE</code> will return them in alphabetical
order of the facet/category value (see <a href="#section-interpreting-facet-result">Interpreting a Facet result</a>).
<code>RANGE_DEFINITION_ORDER</code> only applies for range faceting request and returns the facets in the same
order in which the ranges are defined. For <a href="#example-range-faceting">Creating a range faceting request</a> this would mean the facet for
the range of below 1000 would be returned first, followed by the facet for the range 1001 to 1500
and finally the facet for above 1500.</p>
</div>
</div>
<div class="sect3">
<h4 id="section-applying-faceting-request"><a class="anchor" href="#section-applying-faceting-request"></a>5.4.3. Applying a faceting request</h4>
<div class="paragraph">
<p>In <a href="#section-creating-faceting-request">Creating a faceting request</a> we have seen how to create a faceting request. Now it is
time to apply it on a query. The key is the <code>FacetManager</code> which can be retrieved via the
<code>FullTextQuery</code> (see <a href="#example-applying-faceting">Applying a faceting request</a>).</p>
</div>
<div id="example-applying-faceting" class="exampleblock">
<div class="title">Example 118. Applying a faceting request</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">// create a fulltext query
Query luceneQuery = builder.all().createQuery(); // match all query
FullTextQuery fullTextQuery = fullTextSession.createFullTextQuery(luceneQuery, Cd.class);

// retrieve facet manager and apply faceting request
FacetManager facetManager = fullTextQuery.getFacetManager();
facetManager.enableFaceting(priceFacetingRequest);

// get the list of Cds
List&lt;Cd&gt; cds = fullTextQuery.list();
...

// retrieve the faceting results
List&lt;Facet&gt; facets = facetManager.getFacets("priceFaceting");
...</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>You need to enable the faceting request before you execute the query. You do that via
<code>facetManager.enableFaceting(&lt;facetName&gt;)</code>. You can enable as many faceting requests as you
like. Then you execute the query and retrieve the facet results for a given request via
<code>facetManager.getFacets(&lt;facetname&gt;)</code>. For each request you will get a list of <code>Facet</code> instances.
Facet requests stay active and get applied to the fulltext query until they are either explicitly
disabled via <code>disableFaceting(&lt;facetName&gt;)</code> or the query is <code>discarded</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="section-interpreting-facet-result"><a class="anchor" href="#section-interpreting-facet-result"></a>5.4.4. Interpreting a Facet result</h4>
<div class="paragraph">
<p>Each facet request results in a list of <code>Facet</code> instances. Each instance represents one facet/category
value. In the CD example (<a href="#example-discrete-faceting">Creating a discrete faceting request</a>) where we want to categorize on the CD
labels, there would for example be a <code>Facet</code> for each of the record labels Universal, Sony and Warner.
<a href="#example-facet-api">Facet API</a> shows the API of Facet.</p>
</div>
<div id="example-facet-api" class="exampleblock">
<div class="title">Example 119. Facet API</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public interface Facet {
    /**
     * @return the faceting name this {@code Facet} belongs to.
     *
     * @see org.hibernate.search.query.facet.FacetingRequest#getFacetingName()
     */
    String getFacetingName();

    /**
     * Return the {@code Document} field name this facet is targeting.
     * The field needs to be indexed with {@code Analyze.NO}.
     *
     * @return the {@code Document} field name this facet is targeting.
     */
    String getFieldName();

    /**
     * @return the value of this facet. In case of a discrete facet it is the actual
     *         {@code Document} field value. In case of a range query the value is a
     *         string representation of the range.
     */
    String getValue();

    /**
     * @return the facet count.
     */
    int getCount();

    /**
     * @return a Lucene {@link Query} which can be executed to retrieve all
     *         documents matching the value of this facet.
     */
    Query getFacetQuery();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>getFacetingName()</code> and <code>getFieldName()</code> are returning the facet request name and the targeted document
field name as specified by the underlying <code>FacetRequest</code>. For example "<a href="#example-discrete-faceting">Creating a discrete faceting request</a>"
that would be <code>labelFacetRequest</code> and <code>label</code> respectively.
The interesting information is provided by <code>getValue()</code> and <code>getCount()</code>.
The former is the actual facet/category value, for example a concrete record label
like Universal. The latter returns the count for this value. To stick with the example again, the
count value tells you how many Cds are released under the Universal label. Last but not least,
<code>getFacetQuery()</code> returns a Lucene query which can be used to retrieve the entities counted in this
facet.</p>
</div>
</div>
<div class="sect3">
<h4 id="_restricting_query_results"><a class="anchor" href="#_restricting_query_results"></a>5.4.5. Restricting query results</h4>
<div class="paragraph">
<p>A common use case for faceting is a "drill-down" functionality which allows you to narrow your
original search by applying a given facet on it. To do this, you can apply any of the returned
<code>Facet</code> instances as additional criteria on your original query via <code>FacetSelection</code>. <code>FacetSelection</code>
is available via the <code>FacetManager</code> and allow you to select a facet as query criteria (<code>selectFacets</code>),
remove a facet restriction (<code>deselectFacets</code>), remove all facet restrictions (<code>clearSelectedFacets</code>) and
retrieve all currently selected facets (<code>getSelectedFacets</code>). <a href="#example-restricting-query-results">Restricting query results via the application of a <code>FacetSelection</code></a>
shows an example.</p>
</div>
<div id="example-restricting-query-results" class="exampleblock">
<div class="title">Example 120. Restricting query results via the application of a <code>FacetSelection</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">// create a fulltext query
Query luceneQuery = builder.all().createQuery(); // match all query
FullTextQuery fullTextQuery = fullTextSession.createFullTextQuery( luceneQuery, clazz );

// retrieve facet manager and apply faceting request
FacetManager facetManager = fullTextQuery.getFacetManager();
facetManager.enableFaceting( priceFacetingRequest );

// get the list of Cd
List&lt;Cd&gt; cds = fullTextQuery.list();
assertTrue(cds.size() == 10);

// retrieve the faceting results
List&lt;Facet&gt; facets = facetManager.getFacets( "priceFaceting" );
assertTrue(facets.get(0).getCount() == 2)

// apply first facet as additional search criteria
FacetSelection facetSelection = facetManager.getFacetGroup( "priceFaceting" );
facetSelection.selectFacets( facets.get( 0 ) );

// re-execute the query
cds = fullTextQuery.list();
assertTrue(cds.size() == 2);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Per default selected facets are combined via  disjunction (OR). In case a field has multiple values,
like a potential <code>Cd.artists</code> association, you can also use  conjunction (AND) for the facet selection.</p>
</div>
<div id="example-using-conjunction-restricting-query-results" class="exampleblock">
<div class="title">Example 121. Using conjunction in <code>FacetSelection</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">FacetSelection facetSelection = facetManager.getFacetGroup( "artistsFaceting" );
facetSelection.selectFacets( FacetCombine.AND, facets.get( 0 ), facets.get( 1 ) );</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_optimizing_the_query_process"><a class="anchor" href="#_optimizing_the_query_process"></a>5.5. Optimizing the query process</h3>
<div class="paragraph">
<p>Query performance depends on several criteria:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the Lucene query itself: read the literature on this subject.</p>
</li>
<li>
<p>the number of loaded objects: use pagination and / or index projection (if needed).</p>
</li>
<li>
<p>the way Hibernate Search interacts with the Lucene readers: defines the appropriate
<a href="#search-architecture-readerstrategy">Reader strategy</a>.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="query-logging"><a class="anchor" href="#query-logging"></a>5.5.1. Logging executed search queries</h4>
<div class="paragraph">
<p>Knowing the executed search queries is vital when working on performance optimizations. This is especially
the case if your application accepts queries passed in by the user or e.g. dynamically builds queries
using the Hibernate Search query DSL.</p>
</div>
<div class="paragraph">
<p>In order to log all search queries executed by Hibernate Search, enable <code>DEBUG</code> logging for the log
category <code>org.hibernate.search.fulltext_query</code>.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="manual-index-changes"><a class="anchor" href="#manual-index-changes"></a>6. Manual index changes</h2>
<div class="sectionbody">
<div class="paragraph">
<p>As Hibernate core applies changes to the Database, Hibernate Search detects these changes and will
update the index automatically (unless the EventListeners are disabled). Sometimes changes are made
to the database without using Hibernate, as when backup is restored or your data is otherwise
affected; for these cases Hibernate Search exposes the Manual Index APIs to explicitly update or
remove a single entity from the index, or rebuild the index for the whole database, or remove all
references to a specific type.</p>
</div>
<div class="paragraph">
<p>All these methods affect the Lucene Index only, no changes are applied to the Database.</p>
</div>
<div class="sect2">
<h3 id="_adding_instances_to_the_index"><a class="anchor" href="#_adding_instances_to_the_index"></a>6.1. Adding instances to the index</h3>
<div class="paragraph">
<p>Using <code>FullTextSession.index(T entity)</code> you can directly add or update a specific object instance to
the index. If this entity was already indexed, then the index will be updated. Changes to the index
are only applied at transaction commit.</p>
</div>
<div class="exampleblock">
<div class="title">Example 122. Indexing an entity via <code>FullTextSession.index(T entity)</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">FullTextSession fullTextSession = Search.getFullTextSession(session);
Transaction tx = fullTextSession.beginTransaction();
Object customer = fullTextSession.load( Customer.class, 8 );
fullTextSession.index(customer);
tx.commit(); //index only updated at commit time</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In case you want to add all instances for a type, or for all indexed types, the recommended approach
is to use a MassIndexer: see <a href="#search-batchindex-massindexer">Using a MassIndexer</a> for more details.</p>
</div>
<div class="paragraph">
<p>The method <code>FullTextSession.index(T entity)</code> is considered an explicit indexing operation, so any
registered EntityIndexingInterceptor won&#8217;t be applied in this case. For more information on
EntityIndexingInterceptor see <a href="#search-mapping-indexinginterceptor">Conditional indexing</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_deleting_instances_from_the_index"><a class="anchor" href="#_deleting_instances_from_the_index"></a>6.2. Deleting instances from the index</h3>
<div class="paragraph">
<p>It is equally possible to remove an entity or all entities of a given type from a Lucene index
without the need to physically remove them from the database. This operation is named purging and is
also done through the <code>FullTextSession</code>.</p>
</div>
<div class="exampleblock">
<div class="title">Example 123. Purging a specific instance of an entity from the index</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">FullTextSession fullTextSession = Search.getFullTextSession(session);
Transaction tx = fullTextSession.beginTransaction();
for (Customer customer : customers) {
    fullTextSession.purge( Customer.class, customer.getId() );
}
tx.commit(); //index is updated at commit time</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Purging will remove the entity with the given id from the Lucene index but will not touch the
database.</p>
</div>
<div class="paragraph">
<p>If you need to remove all entities of a given type, you can use the purgeAll method. This operation
removes all entities of the type passed as a parameter as well as all its subtypes.</p>
</div>
<div class="exampleblock">
<div class="title">Example 124. Purging all instances of an entity from the index</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">FullTextSession fullTextSession = Search.getFullTextSession(session);
Transaction tx = fullTextSession.beginTransaction();
fullTextSession.purgeAll( Customer.class );
//optionally optimize the index
//fullTextSession.getSearchFactory().optimize( Customer.class );
tx.commit(); //index changes are applied at commit time</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>As in the previous example, it is suggested to optimize the index after many purge operation to
actually free the used space.</p>
</div>
<div class="paragraph">
<p>As is the case with method <code>FullTextSession.index(T entity)</code>, also <code>purge</code> and <code>purgeAll</code> are
considered explicit indexing operations: any registered <code>EntityIndexingInterceptor</code> won&#8217;t be
applied. For more information on <code>EntityIndexingInterceptor</code> see
<a href="#search-mapping-indexinginterceptor">Conditional indexing</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Methods index, purge and purgeAll are available on FullTextEntityManager as well.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>All manual indexing methods (index, purge and purgeAll) only affect the index, not the database,
nevertheless they are transactional and as such they won&#8217;t be applied until the transaction is
successfully committed, or you make use of flushToIndexes.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="search-batchindex"><a class="anchor" href="#search-batchindex"></a>6.3. Rebuilding the whole index</h3>
<div class="paragraph">
<p>If you change the entity mapping to the index, chances are that the whole index needs to be updated;
for example if you decide to index an existing field using a different analyzer you&#8217;ll need to
rebuild the index for affected types. Also if the Database is replaced (like restored from a backup,
imported from a legacy system) you&#8217;ll want to be able to rebuild the index from existing data.
Hibernate Search provides two main strategies to choose from:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Using <code>FullTextSession.flushToIndexes()</code> periodically, while using FullTextSession.index() on all
entities.</p>
</li>
<li>
<p>Use a MassIndexer.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When you change the entity mapping to the index, if you don&#8217;t know whether the changes require
a full reindexing or not, you can follow this rule of thumb:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Rebuilding the whole index is <strong>not</strong> required if all you did was:</p>
<div class="ulist">
<ul>
<li>
<p><strong>adding</strong> new indexed entities that will not have any persisted instance,
e.g. adding an <code>@Indexed</code> annotation on an entity which has no rows in database.</p>
</li>
<li>
<p><strong>adding</strong> new fields that will be empty for all currently persisted entities,
e.g. adding a new property on an entity type and mapping it to a field,
but with the guarantee that this property will initially be null for every instance of this entity;</p>
</li>
<li>
<p>and/or <strong>removing</strong> data from existing indexes/fields,
e.g. removing an index field, or removing the need for a field to be stored.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Rebuilding the whole index <strong>is</strong> required if you made any change to the mapping that is not mentioned above.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="search-batchindex-flushtoindexes"><a class="anchor" href="#search-batchindex-flushtoindexes"></a>6.3.1. Using flushToIndexes()</h4>
<div class="paragraph">
<p>This strategy consists in removing the existing index and then adding all entities back to the index
using <code>FullTextSession.purgeAll()</code> and <code>FullTextSession.index()</code>, however there are some memory and
efficiency constraints. For maximum efficiency Hibernate Search batches index operations and executes
them at commit time. If you expect to index a lot of data you need to be careful about memory
consumption since all documents are kept in a queue until the transaction commit. You can
potentially face an <code>OutOfMemoryException</code> if you don&#8217;t empty the queue periodically: to do this you
can use <code>fullTextSession.flushToIndexes()</code>. Every time <code>fullTextSession.flushToIndexes()</code> is called (or
if the transaction is committed), the batch queue is processed applying all index changes. Be aware
that, once flushed, the changes cannot be rolled back.</p>
</div>
<div class="exampleblock">
<div class="title">Example 125. Index rebuilding using index() and flushToIndexes()</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">fullTextSession.setFlushMode(FlushMode.MANUAL);
fullTextSession.setCacheMode(CacheMode.IGNORE);
transaction = fullTextSession.beginTransaction();
//Scrollable results will avoid loading too many objects in memory
ScrollableResults results = fullTextSession.createCriteria( Email.class )
    .setFetchSize(BATCH_SIZE)
    .scroll(ScrollMode.FORWARD_ONLY);
int index = 0;
while(results.next()) {
    index++;
    fullTextSession.index(results.get(0)); //index each element
    if (index % BATCH_SIZE == 0) {
        fullTextSession.flushToIndexes(); //apply changes to indexes
        fullTextSession.clear(); //free memory since the queue is processed
    }
}
transaction.commit();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Try to use a batch size that guarantees that your application will not run out of memory: with a
bigger batch size objects are fetched faster from database but more memory is needed.</p>
</div>
</div>
<div class="sect3">
<h4 id="search-batchindex-massindexer"><a class="anchor" href="#search-batchindex-massindexer"></a>6.3.2. Using a MassIndexer</h4>
<div class="paragraph">
<p>Hibernate Search&#8217;s MassIndexer uses several parallel threads to rebuild the index; you can
optionally select which entities need to be reloaded or have it reindex all entities. This approach
is optimized for best performance but requires to set the application in maintenance mode: making
queries to the index is not recommended when a MassIndexer is busy.</p>
</div>
<div class="exampleblock">
<div class="title">Example 126. Index rebuilding using a MassIndexer</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">fullTextSession.createIndexer().startAndWait();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This will rebuild the index, deleting it and then reloading all entities from the database. Although
it&#8217;s simple to use, some tweaking is recommended to speed up the process: there are several
parameters configurable.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>During the progress of a MassIndexer the content of the index is undefined! If a query is performed
while the MassIndexer is working most likely some results will be missing.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="title">Example 127. Using a tuned MassIndexer</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">fullTextSession
 .createIndexer( User.class )
 .batchSizeToLoadObjects( 25 )
 .cacheMode( CacheMode.NORMAL )
 .threadsToLoadObjects( 12 )
 .idFetchSize( 150 )
 .transactionTimeout( 1800 )
 .progressMonitor( monitor ) //a MassIndexerProgressMonitor implementation
 .startAndWait();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>This will rebuild the index of all <code>User</code> instances (and subtypes), and will create 12 parallel
threads to load the User instances using batches of 25 objects per query; these same 12 threads will
also need to process indexed embedded relations and custom FieldBridges or ClassBridges, to finally
output a Lucene document. In this conversion process these threads are likely going to need to
trigger lazy loading of additional attributes, so you will probably need a high number of threads
working in parallel. When run in a JTA environment such as the WildFly application server, the mass
indexer will use a timeout of 1800 seconds (= 30 minutes) for its transactions. Configure a timeout
value which is long enough to load and index all entities of the type with the most instances,
taking into account the configured batch size and number of threads to load objects. Note that
these transactions are read-only, so choosing a substantially large value should pose no problem in
general.</p>
</div>
<div class="paragraph">
<p>As of Hibernate Search 4.4.0, instead of indexing all the types in parallel, the MassIndexer is
configured by default to index only one type in parallel. It prevents resource exhaustion especially
database connections and usually does not slow down the indexing. You can however configure this
behavior using <code>MassIndexer.typesToIndexInParallel(int threadsToIndexObjects)</code>:</p>
</div>
<div class="exampleblock">
<div class="title">Example 128. Configuring the MassIndexer to index several types in parallel</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">fullTextSession
 .createIndexer( User.class, Customer.class )
 .typesToIndexInParallel( 2 )
 .batchSizeToLoadObjects( 25 )
 .cacheMode( CacheMode.NORMAL )
 .threadsToLoadObjects( 5 )
 .idFetchSize( 150 )
 .progressMonitor( monitor ) //a MassIndexerProgressMonitor implementation
 .startAndWait();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Generally we suggest to leave cacheMode to <code>CacheMode.IGNORE</code> (the default), as in most reindexing
situations the cache will be a useless additional overhead; it might be useful to enable some other
<code>CacheMode</code> depending on your data: it could increase performance if the main entity is relating to
enum-like data included in the index.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The MassIndexer was designed for speed and is unaware of transactions, so there is no need to begin
one or committing. Also because it is not transactional it is not recommended to let users use the
system during its processing, as it is unlikely people will be able to find results and the system
load might be too high anyway.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="search-batchindexing-threadsandconnections"><a class="anchor" href="#search-batchindexing-threadsandconnections"></a>MassIndexer using threads and JDBC connections</h5>
<div class="paragraph">
<p>The MassIndexer was designed to finish the re-indexing task as quickly as possible, but this requires
a bit of care in its configuration to behave fairly with your server resources.</p>
</div>
<div class="paragraph">
<p>There is a simple formula to understand how the different options applied to the MassIndexer affect
the number of used worker threads and connections: each thread will require a JDBC connection.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>threads = typesToIndexInParallel * (threadsToLoadObjects + 1);
required JDBC connections = threads;</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s see some suggestions for a roughly sane tuning starting point:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Option <code>typesToIndexInParallel</code> should probably be a low value, like 1 or 2, depending on how much
of your CPUs have spare cycles and how slow a database round trip will be.</p>
</li>
<li>
<p>Before tuning a parallel run, experiment with options to tune your primary indexed entities in
isolation.</p>
</li>
<li>
<p>Making <code>threadsToLoadObjects</code> higher increases the pre-loading rate for the picked entities from
the database, but also increases memory usage and the pressure on the threads working on subsequent
indexing.</p>
</li>
<li>
<p>Increasing parallelism usually helps as the bottleneck usually is the latency to the database
connection: it&#8217;s probably worth it to experiment with values significantly higher than the number
of actual cores available, but make sure your database can handle all the multiple requests.</p>
</li>
<li>
<p>This advice might not apply to you: always measure the effects! We&#8217;re providing this as a means to
help you understand how these options are related.</p>
</li>
</ol>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Running the MassIndexer with many threads will require many connections to the database. If you
don&#8217;t have a sufficiently large connection pool, the MassIndexer itself and/or your other
applications could starve being unable to serve other requests: make sure you size your connection
pool accordingly to the options as explained in the above paragraph.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The "sweet spot" of number of threads to achieve best performance is highly dependent on your
overall architecture, database design and even data values. All internal thread groups have
meaningful names so they should be easily identified with most diagnostic tools, including simply
thread dumps.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="search-batchindex-custommassindexer"><a class="anchor" href="#search-batchindex-custommassindexer"></a>Using a custom MassIndexer implementation</h5>
<div class="paragraph">
<p>The provided MassIndexer is quite general purpose, and while we believe it&#8217;s a robust approach, you
might be able to squeeze some better performance by writing a custom implementation. To run your own
MassIndexer instead of using the one shipped with Hibernate Search you have to:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>create an implementation of the <code>org.hibernate.search.spi.MassIndexerFactory</code> interface;</p>
</li>
<li>
<p>set the property <code>hibernate.search.massindexer.factoryclass</code> with the qualified class name of the
factory implementation.</p>
</li>
</ol>
</div>
<div class="exampleblock">
<div class="title">Example 129. Custom MassIndexerFactory example</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">package org.myproject
import org.hibernate.search.spi.MassIndexerFactory

// ...

public class CustomIndexerFactory implements MassIndexerFactory {

  public void initialize(Properties properties) {
  }

  public MassIndexer createMassIndexer(...) {
    return new CustomIndexer();
  }

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>hibernate.search.massindexer.factoryclass = org.myproject.CustomIndexerFactory</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_useful_parameters_for_batch_indexing"><a class="anchor" href="#_useful_parameters_for_batch_indexing"></a>6.3.3. Useful parameters for batch indexing</h4>
<div class="paragraph">
<p>Other parameters which affect indexing time and memory consumption are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>hibernate.search.[default|&lt;indexname&gt;].exclusive_index_use</code></p>
</li>
<li>
<p><code>hibernate.search.[default|&lt;indexname&gt;].indexwriter.max_buffered_docs</code></p>
</li>
<li>
<p><code>hibernate.search.[default|&lt;indexname&gt;].indexwriter.max_merge_docs</code></p>
</li>
<li>
<p><code>hibernate.search.[default|&lt;indexname&gt;].indexwriter.merge_factor</code></p>
</li>
<li>
<p><code>hibernate.search.[default|&lt;indexname&gt;].indexwriter.merge_min_size</code></p>
</li>
<li>
<p><code>hibernate.search.[default|&lt;indexname&gt;].indexwriter.merge_max_size</code></p>
</li>
<li>
<p><code>hibernate.search.[default|&lt;indexname&gt;].indexwriter.merge_max_optimize_size</code></p>
</li>
<li>
<p><code>hibernate.search.[default|&lt;indexname&gt;].indexwriter.merge_calibrate_by_deletes</code></p>
</li>
<li>
<p><code>hibernate.search.[default|&lt;indexname&gt;].indexwriter.ram_buffer_size</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Previous versions also had a <code>max_field_length</code> but this was removed from Lucene, it&#8217;s possible
to obtain a similar effect by using a <code>LimitTokenCountAnalyzer</code>.</p>
</div>
<div class="paragraph">
<p>All <code>.indexwriter</code> parameters are Lucene specific and Hibernate Search is just passing these
parameters through - see <a href="#lucene-indexing-performance">Tuning indexing performance</a> for more details.</p>
</div>
<div class="paragraph">
<p>The MassIndexer uses a forward only scrollable result to iterate on the primary keys to be loaded,
but MySQL&#8217;s JDBC driver will load all values in memory; to avoid this "optimization" set
<code>idFetchSize</code> to <code>Integer.MIN_VALUE</code>.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="search-optimize"><a class="anchor" href="#search-optimize"></a>7. Index Optimization</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section explains some low level tricks to keep your indexes at peak performance. We cover some
Lucene details which in most cases you don&#8217;t have to know about: Hibernate Search will handle these
operations optimally and transparently in most cases without the need for further configuration.
Still, it is good to know that there are ways to configure the behavior, if the need arises.</p>
</div>
<div class="paragraph">
<p>The index is physically stored in several smaller segments. Each segment is immutable and represents
a generation of index writes. Index segments are periodically compacted, both to merge smaller
segments and to remove stale entries; this merging process happens constantly in the background and
can be tuned with the options specified in <a href="#lucene-indexing-performance">Tuning indexing performance</a>, but you can also define
policies to fully run index optimizations when it is most suited for your specific workload.</p>
</div>
<div class="paragraph">
<p>With older versions of Lucene it was important to frequently optimize the index to maintain good
performance, but with current Lucene versions this doesn&#8217;t apply anymore. The benefit of explicit
optimization is very low, and in certain cases even counter-productive. During an explicit
optimization the whole index is processed and rewritten inflicting a significant performance cost.
Optimization is for this reason a double-edged sword.</p>
</div>
<div class="paragraph">
<p>Another reason to avoid optimizing the index too often is that an optimization will, as a side
effect, invalidate cached filters and field caches and internal buffers need to be refreshed.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Optimizing the index is often not needed, does not benefit write (update) performance at all, and is
a slow operation: make sure you need it before activating it.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Of course optimizing the index does not only present drawbacks: after the optimization process is
completed and new IndexReader instances have loaded their buffers, queries will perform at peak
performance and you will have reclaimed all disk space potentially used by stale entries.</p>
</div>
<div class="paragraph">
<p>It is recommended to not schedule any optimization, but if you wish to perform it periodically you
should run it:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>on an idle system or when the searches are less frequent</p>
</li>
<li>
<p>after a lot of index modifications</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When using a MassIndexer (see <a href="#search-batchindex-massindexer">Using a MassIndexer</a>) it will optimize involved indexes
by default at the start and at the end of processing; you can change this behavior by using
MassIndexer.optimizeAfterPurge and MassIndexer.optimizeOnFinish respectively. The initial
optimization is actually very cheap as it is performed on an empty index: its purpose is to release
the storage space occupied by the old index.</p>
</div>
<div class="sect2">
<h3 id="_automatic_optimization"><a class="anchor" href="#_automatic_optimization"></a>7.1. Automatic optimization</h3>
<div class="paragraph">
<p>While in most cases this is not needed, Hibernate Search can automatically optimize an index after:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a certain amount of write operations</p>
</li>
<li>
<p>or after a certain amount of transactions</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The configuration for automatic index optimization can be defined on a global level or per index:</p>
</div>
<div class="exampleblock">
<div class="title">Example 130. Defining automatic optimization parameters</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre>hibernate.search.default.optimizer.operation_limit.max = 1000
hibernate.search.default.optimizer.transaction_limit.max = 100
hibernate.search.Animal.optimizer.transaction_limit.max = 50</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>With the above example an optimization will be triggered to the <code>Animal</code> index as soon as either:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the number of additions and deletions reaches 1000</p>
</li>
<li>
<p>the number of transactions reaches 50 (hibernate.search.Animal.optimizer.transaction_limit.max
having priority over hibernate.search.default.optimizer.transaction_limit.max)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If none of these parameters are defined, no optimization is processed automatically.</p>
</div>
<div class="paragraph">
<p>The default implementation of OptimizerStrategy can be overridden by implementing
<code>org.hibernate.search.store.optimization.OptimizerStrategy</code> and setting the
<code>optimizer.implementation</code> property to the fully qualified name of your implementation. This
implementation must implement the interface, be a public class and have a public constructor taking
no arguments.</p>
</div>
<div class="exampleblock">
<div class="title">Example 131. Loading a custom OptimizerStrategy</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre>hibernate.search.default.optimizer.implementation = com.acme.worlddomination.SmartOptimizer
hibernate.search.default.optimizer.SomeOption = CustomConfigurationValue
hibernate.search.humans.optimizer.implementation = default</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The keyword <code>default</code> can be used to select the Hibernate Search default implementation; all
properties after the <code>.optimizer</code> key separator will be passed to the implementation&#8217;s initialize
method at start.</p>
</div>
</div>
<div class="sect2">
<h3 id="_manual_optimization"><a class="anchor" href="#_manual_optimization"></a>7.2. Manual optimization</h3>
<div class="paragraph">
<p>You can programmatically optimize (defragment) a Lucene index from Hibernate Search through the
SearchFactory:</p>
</div>
<div class="exampleblock">
<div class="title">Example 132. Programmatic index optimization</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">FullTextSession fullTextSession = Search.getFullTextSession(regularSession);
SearchFactory searchFactory = fullTextSession.getSearchFactory();

searchFactory.optimize(Order.class);
// or
searchFactory.optimize();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The first example optimizes the Lucene index holding Orders; the second, optimizes all indexes.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>searchFactory.optimize()</code> has no effect on a JMS or JGroups backend: you must apply the optimize operation on the Master node.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_adjusting_optimization"><a class="anchor" href="#_adjusting_optimization"></a>7.3. Adjusting optimization</h3>
<div class="paragraph">
<p>The Lucene index is constantly being merged in the background to keep a good balance between write
and read performance; in a sense this is a form of background optimization which is always applied.</p>
</div>
<div class="paragraph">
<p>The following match attributes of Lucene&#8217;s IndexWriter and are commonly used to tune how often
merging occurs and how aggressive it is applied. They are exposed by Hibernate Search via:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>hibernate.search.[default|&lt;indexname&gt;].indexwriter.max_buffered_docs</code></p>
</li>
<li>
<p><code>hibernate.search.[default|&lt;indexname&gt;].indexwriter.max_merge_docs</code></p>
</li>
<li>
<p><code>hibernate.search.[default|&lt;indexname&gt;].indexwriter.merge_factor</code></p>
</li>
<li>
<p><code>hibernate.search.[default|&lt;indexname&gt;].indexwriter.ram_buffer_size</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>See <a href="#lucene-indexing-performance">Tuning indexing performance</a> for a description of these properties.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="search-monitoring"><a class="anchor" href="#search-monitoring"></a>8. Monitoring</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Hibernate Search offers access to a <code>Statistics</code> object via <code>SearchFactory.getStatistics()</code>.
It allows you for example to determine which classes are indexed and how many entities are in the index.
This information is always available. However, by specifying the
<code>hibernate.search.generate_statistics</code> property in your configuration you can also collect total
and average Lucene query and object loading timings.</p>
</div>
<div class="sect2">
<h3 id="_jmx"><a class="anchor" href="#_jmx"></a>8.1. JMX</h3>
<div class="paragraph">
<p>You can also enable access to the statistics via JMX.
Setting the property <code>hibernate.search.jmx_enabled</code> will automatically register the <code>StatisticsInfoMBean</code>.
Depending on your the configuration the <code>IndexControlMBean</code> and <code>IndexingProgressMonitorMBean</code> will also be
registered. In case you are having more than one JMX enabled Hibernate Search instance running
within a single JVM, you should also set <code>hibernate.search.jmx_bean_suffix</code> to a different value for
each of the instances. The specified suffix will be used to distinguish between the different MBean
instances. Let&#8217;s have a closer look at the mentioned MBeans.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If you want to access your JMX beans remotely via JConsole make sure to set the system property
<code>com.sun.management.jmxremote</code> to true.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_statisticsinfombean"><a class="anchor" href="#_statisticsinfombean"></a>8.1.1. StatisticsInfoMBean</h4>
<div class="paragraph">
<p>This MBean gives you access to Statistics object as described in the previous section.</p>
</div>
</div>
<div class="sect3">
<h4 id="_indexcontrolmbean"><a class="anchor" href="#_indexcontrolmbean"></a>8.1.2. IndexControlMBean</h4>
<div class="paragraph">
<p>This MBean allows to build, optimize and purge the index for a given entity. Indexing occurs via the
mass indexing API (see <a href="#search-batchindex-massindexer">Using a MassIndexer</a>). A requirement for this bean to be
registered in JMX is, that the Hibernate SessionFactory is bound to JNDI via the
<code>hibernate.session_factory_name</code> property. Refer to the Hibernate Core manual for more
information on how to configure JNDI.</p>
</div>
</div>
<div class="sect3">
<h4 id="_indexingprogressmonitormbean"><a class="anchor" href="#_indexingprogressmonitormbean"></a>8.1.3. IndexingProgressMonitorMBean</h4>
<div class="paragraph">
<p>This MBean is an implementation MassIndexerProgressMonitor interface.
If <code>hibernate.search.jmx_enabled</code> is enabled and the mass indexer API is used the indexing progress
can be followed via this bean. The bean will only be bound to JMX while indexing is in progress.
Once indexing is completed the MBean is not longer available.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="spatial"><a class="anchor" href="#spatial"></a>9. Spatial</h2>
<div class="sectionbody">
<div class="paragraph">
<p>With the spatial extensions you can combine full-text queries with distance restrictions, filter results based on distances
or sort results on such a distance criteria.</p>
</div>
<div class="paragraph">
<p>The spatial support of Hibernate Search has the following goals:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Enable spatial search on entities: find entities within x km from a given location (latitude, longitude) on Earth</p>
</li>
<li>
<p>Provide an easy way to enable spatial indexing via expressive annotations</p>
</li>
<li>
<p>Provide a simple way for querying</p>
</li>
<li>
<p>Hide geographical complexity</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For example, you might search for restaurants somewhere in a 2 km radius around your office.</p>
</div>
<div class="paragraph">
<p>In order to use the spatial extensions for an indexed entity, you need to add the <code>@Spatial</code>
annotation (<code>org.hibernate.search.annotations.Spatial</code>) and specify one or more sets of coordinates.</p>
</div>
<div class="sect2">
<h3 id="spatial-indexing"><a class="anchor" href="#spatial-indexing"></a>9.1. Enable indexing of Spatial Coordinates</h3>
<div class="paragraph">
<p>There are different techniques to index point coordinates. Hibernate Search Spatial offers a choice between two strategies:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>index as numbers</p>
</li>
<li>
<p>index as labeled spatial hashes</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>We will now describe both methods, so you can make a suitable choice. You can pick a different strategy for each set of
coordinates. The strategy is selected by specifying the <code>spatialMode</code> attribute of the <code>@Spatial</code> annotation.</p>
</div>
<div class="sect3">
<h4 id="spatial-indexing-range"><a class="anchor" href="#spatial-indexing-range"></a>9.1.1. Indexing coordinates for range queries</h4>
<div class="paragraph">
<p>When setting the <code>@Spatial.spatialMode</code> attribute to <code>SpatialMode.RANGE</code> (which is the default)
coordinates are indexed as numeric fields, so that range queries can be performed to narrow down the
initial area of interest.</p>
</div>
<div class="paragraph">
<p>Pros:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Is quick on small data sets (&lt; 100k entities)</p>
</li>
<li>
<p>Is very simple: straightforward to debug/analyze</p>
</li>
<li>
<p>Impact on index size is moderate</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Cons:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Poor performance on large data sets</p>
</li>
<li>
<p>Poor performance if your data set is distributed across the whole world (for example when
indexing points of interest in the United States, in Europe and in Asia, large areas collide because
they share the same latitude. The latitude range query returns large amounts of data that need to be
cross checked with those returned by the longitude range).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To index your entities for range querying you have to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>add the <code>@Spatial</code> annotation on your entity</p>
</li>
<li>
<p>add the <code>@Latitude</code> and <code>@Longitude</code> annotations on your properties representing the coordinates;
these must be of type <code>Double</code></p>
</li>
</ul>
</div>
<div class="exampleblock">
<div class="title">Example 133. Sample Spatial indexing: Hotel class</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">import org.hibernate.search.annotations.*;

@Entity
@Indexed
@Spatial
public class Hotel {

  @Latitude
  Double latitude

  @Longitude
  Double longitude

  // ...</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="spatial-indexing-spatialHash"><a class="anchor" href="#spatial-indexing-spatialHash"></a>9.1.2. Indexing coordinates in a grid with spatial hashes</h4>
<div class="paragraph">
<p>When setting <code>@Spatial.spatialMode</code> to <code>SpatialMode.HASH</code> the coordinates are encoded in several fields
representing different zoom levels. Each box for each level is labeled so coordinates are assigned
matching labels for each zoom level. This results in a grid encoding of labels called <code>spatial
hashes</code>.</p>
</div>
<div class="paragraph">
<p>Pros :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Good performance even with large data sets</p>
</li>
<li>
<p>World wide data distribution independent</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Cons :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Index size is larger: need to encode multiple labels per pair of coordinates</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To index your entities you have to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>add the <code>@Spatial</code> annotation on the entity with the <code>SpatialMode</code> set to GRID :
@Spatial(spatialMode = SpatialMode.HASH)</p>
</li>
<li>
<p>add the <code>@Latitude</code> and <code>@Longitude</code> annotations on the properties representing your coordinates;
these must be of type <code>Double</code></p>
</li>
</ul>
</div>
<div class="exampleblock">
<div class="title">Example 134. Indexing coordinates in a grid using spatial hashes</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Spatial(spatialMode = SpatialMode.HASH)
@Indexed
@Entity
public class Hotel {

  @Latitude
  Double latitude;

  @Longitude
  Double longitude;

  // ...</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="spatial-coordinatesinterface"><a class="anchor" href="#spatial-coordinatesinterface"></a>9.1.3. Implementing the Coordinates interface</h4>
<div class="paragraph">
<p>Instead of using the <code>@Latitude</code> and <code>@Longitude</code> annotations you can choose to implement the
<code>org.hibernate.search.spatial.Coordinates</code> interface.</p>
</div>
<div class="exampleblock">
<div class="title">Example 135. Implementing the Coordinates interface</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">import org.hibernate.search.annotations.*;
import org.hibernate.search.spatial.Coordinates;

@Entity
@Indexed
@Spatial
public class Song implements Coordinates {

  @Id long id;
  double latitude;
  double longitude;
  // ...

  @Override
  Double getLatitude() {
    return latitude;
  }

  @Override
  Double getLongitude() {
    return longitude;
  }

  // ...</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>As we will see in the section <a href="#spatial-multiplecoordinates">Multiple Coordinate pairs</a>, an entity can have multiple <code>@Spatial</code> annotations;
when having the entity implement <code>Coordinates</code>, the implemented methods refer to the default <code>@Spatial</code> annotation with
the default pair of coordinates.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The default (field) name in case <code>@Spatial</code> is placed on the entity level is <code>org.hibernate.search.annotations.Spatial.COORDINATES_DEFAULT_FIELD</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>An alternative is to use properties implementing the <code>Coordinates</code> interface; this way you can have
multiple <code>Spatial</code> instances:</p>
</div>
<div class="exampleblock">
<div class="title">Example 136. Using attributes of type Coordinates</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">@Entity
@Indexed
public class Event {
  @Id
  Integer id;

  @Field(store = Store.YES)
  String name;

  double latitude;
  double longitude;

  @Spatial(spatialMode = SpatialMode.HASH)
  public Coordinates getLocation() {
    return new Coordinates() {
      @Override
      public Double getLatitude() {
        return latitude;
      }

      @Override
      public Double getLongitude() {
        return longitude;
      }
    };
  }

// ...</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>When using this form the <code>@Spatial.name</code> automatically defaults to the property name. In the above case to <code>location</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="spatial-queries"><a class="anchor" href="#spatial-queries"></a>9.2. Performing Spatial Queries</h3>
<div class="paragraph">
<p>You can use the Hibernate Search query DSL to build a query to search around a pair of coordinates (latitude, longitude)
or around a bean implementing the <code>Coordinates</code> interface.</p>
</div>
<div class="paragraph">
<p>As with any full-text query, the spatial query creation flow looks like:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>retrieve a <code>QueryBuilder</code> from the <code>SearchFactory</code></p>
</li>
<li>
<p>use the DSL to build a spatial query, defining search center and radius</p>
</li>
<li>
<p>optionally combine the resulting <code>Query</code> with other filters</p>
</li>
<li>
<p>call the <code>createFullTextQuery()</code> and use the resulting query like any standard Hibernate or JPA query</p>
</li>
</ol>
</div>
<div id="spatial-example-firstquery" class="exampleblock">
<div class="title">Example 137. Search for an Hotel by distance</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">QueryBuilder builder = fullTextSession.getSearchFactory()
  .buildQueryBuilder().forEntity( Hotel.class ).get();

org.apache.lucene.search.Query luceneQuery = builder
  .spatial()
  .within( radius, Unit.KM )
    .ofLatitude( centerLatitude )
    .andLongitude( centerLongitude )
  .createQuery();

org.hibernate.Query hibQuery = fullTextSession
  .createFullTextQuery( luceneQuery, Hotel.class );
List results = hibQuery.list();</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>In the above example we did not explicitly specify the field name to use. The default coordinates field name was used
implicitly. To target an alternative pair of coordinates at query time, we need to specify the field name as well.
See <a href="#spatial-multiplecoordinates">Multiple Coordinate pairs</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A fully working example can be found in the test-suite of the <a href="https://github.com/hibernate/hibernate-search">source code</a>.
Refer to <code>SpatialIndexingTest.testSpatialAnnotationOnClassLevel()</code> and its corresponding <code>Hotel</code> test class.</p>
</div>
<div class="paragraph">
<p>Alternatively to passing separate latitude and longitude values, you can also pass an instance implementing the
<code>Coordinates</code> interface:</p>
</div>
<div class="exampleblock">
<div class="title">Example 138. DSL example with Coordinates</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Coordinates coordinates = Point.fromDegrees(24d, 31.5d);
Query query = builder
  .spatial()
    .within( 51, Unit.KM )
      .ofCoordinates( coordinates )
  .createQuery();

List results = fullTextSession.createFullTextQuery( query, POI.class ).list();</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="spatial-queries-distance"><a class="anchor" href="#spatial-queries-distance"></a>9.2.1. Returning distance to query point in the search results</h4>
<div class="sect4">
<h5 id="spatial-distance-projection"><a class="anchor" href="#spatial-distance-projection"></a>Returning distance to the center in the results</h5>
<div class="paragraph">
<p>To retrieve the actual distance values (in kilometers) you need to use projection (see <a href="#projections">Projection</a>):</p>
</div>
<div class="exampleblock">
<div class="title">Example 139. Distance projection example</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">double centerLatitude = 24.0d;
double centerLongitude= 32.0d;

QueryBuilder builder = fullTextSession.getSearchFactory()
  .buildQueryBuilder().forEntity(POI.class).get();
org.apache.lucene.search.Query luceneQuery = builder
  .spatial()
     .onField("location")
     .within(100, Unit.KM)
       .ofLatitude(centerLatitude)
       .andLongitude(centerLongitude)
  .createQuery();

FullTextQuery hibQuery = fullTextSession.createFullTextQuery(luceneQuery, POI.class);
hibQuery.setProjection(FullTextQuery.SPATIAL_DISTANCE, FullTextQuery.THIS);
hibQuery.setSpatialParameters(centerLatitude, centerLongitude, "location");
List results = hibQuery.list();</code></pre>
</div>
</div>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Use <code>FullTextQuery.setProjection</code> with <code>FullTextQuery.SPATIAL_DISTANCE</code> as one of the projected fields.</p>
</li>
<li>
<p>Call <code>FullTextQuery.setSpatialParameters</code> with the latitude, longitude and the name of the
spatial field used to build the spatial query. Note that using coordinates different than the
center used for the query will have unexpected results.</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The default (field) name in case <code>@Spatial</code> is placed on the entity level is <code>org.hibernate.search.annotations.Spatial.COORDINATES_DEFAULT_FIELD</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Distance projection and null values</div>
<div class="paragraph">
<p>When a spatial field on an entity has a <code>null</code> value for either its latitude or longitude (or both),
the resulting projected distance will always be <code>null</code>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="spatial-distance-sort"><a class="anchor" href="#spatial-distance-sort"></a>Sorting by distance</h5>
<div class="paragraph">
<p>To sort the results by distance to the center of the search you will have to build a <code>Sort</code> instance
using Hibernate Search sort DSL:</p>
</div>
<div class="exampleblock">
<div class="title">Example 140. Distance sort example using the sort DSL</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">double centerLatitude = 24.0d;
double centerLongitude = 32.0d;

QueryBuilder builder = fullTextSession.getSearchFactory()
   .buildQueryBuilder().forEntity( POI.class ).get();
org.apache.lucene.search.Query luceneQuery = builder
  .spatial()
    .onField("location")
      .within(100, Unit.KM)
      .ofLatitude(centerLatitude)
      .andLongitude(centerLongitude)
  .createQuery();

FullTextQuery hibQuery = fullTextSession.createFullTextQuery(luceneQuery, POI.class);
List results = query.list();
Sort distanceSort = qb
  .sort()
    .byDistance()
      .onField("location")
      .fromLatitude(centerLatitude)
      .andLongitude(centerLongitude)
    .createSort();
hibQuery.setSort(distanceSort);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The sort must be constructed using the same coordinates on the same spatial field used
to build the spatial query, otherwise the sorting will occur with another center than the query. This
repetition is needed to allow you to define Queries with any tool.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Sorting and null values</div>
<div class="paragraph">
<p>When a spatial field on an entity has a <code>null</code> value for either its latitude or longitude (or both):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>if you are filtering the results using a distance query, the entity with missing coordinates
will not appear in the query results and its rank in the sort is irrelevant.</p>
</li>
<li>
<p>otherwise, the resulting distance will always be the greatest possible value,
which means the entity will be ranked last if the sort is ascending, or
first if the sort is descending.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Alternatively, you may also use a <code>DistanceSortField</code> directly, as it was done before the introduction of Hibernate Search sort DSL:</p>
</div>
<div class="exampleblock">
<div class="title">Example 141. Distance sort example without using the sort DSL</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">double centerLatitude = 24.0d;
double centerLongitude = 32.0d;

QueryBuilder builder = fullTextSession.getSearchFactory()
   .buildQueryBuilder().forEntity( POI.class ).get();
org.apache.lucene.search.Query luceneQuery = builder
  .spatial()
    .onField("location")
      .within(100, Unit.KM)
      .ofLatitude(centerLatitude)
      .andLongitude(centerLongitude)
  .createQuery();

FullTextQuery hibQuery = fullTextSession.createFullTextQuery(luceneQuery, POI.class);
Sort distanceSort = new Sort(
    new DistanceSortField(centerLatitude, centerLongitude, "location"));
hibQuery.setSort(distanceSort);</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="spatial-multiplecoordinates"><a class="anchor" href="#spatial-multiplecoordinates"></a>9.3. Multiple Coordinate pairs</h3>
<div class="paragraph">
<p>You can associate multiple pairs of coordinates to the same entity, as long as each pair is
uniquely identified by using a different name.
This is achieved by stacking multiple <code>@Spatial</code> annotations and specifying the <code>name</code> attribute
on the individual <code>@Spatial</code> annotation.
At most one of them will be allowed to use the default name.</p>
</div>
<div class="exampleblock">
<div class="title">Example 142. Multiple sets of coordinates</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">import org.hibernate.search.annotations.*;

@Entity
@Indexed
@Spatial
@Spatial(name="work",  spatialMode = SpatialMode.HASH)
public class UserEx {

  @Id
  Integer id;

  @Latitude
  Double homeLatitude;

  @Longitude
  Double homeLongitude;

  @Latitude(of="work")
  Double workLatitude;

  @Longitude(of="work")
  Double workLongitude;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>To target an alternative pair of coordinates at query time, we need to specify the pair by name using <code>onField(String)</code>:</p>
</div>
<div class="exampleblock">
<div class="title">Example 143. Querying on non-default coordinate set</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">QueryBuilder builder = fullTextSession.getSearchFactory()
  .buildQueryBuilder().forEntity( UserEx.class ).get();

org.apache.lucene.search.Query luceneQuery = builder
  .spatial()
  .onField( "work" )
  .within( radius, Unit.KM )
    .ofLatitude( centerLatitude )
    .andLongitude( centerLongitude )
  .createQuery();

org.hibernate.Query hibQuery = fullTextSession.createFullTextQuery( luceneQuery,
   Hotel.class );
List results = hibQuery.list();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="spatial-behind-curtain"><a class="anchor" href="#spatial-behind-curtain"></a>9.4. Insight: implementation details of spatial hashes indexing</h3>
<div class="paragraph">
<p>The following chapter is meant to provide a technical insight in spatial hash (grid) indexing. It discusses how
coordinates are mapped to the index and how queries are implemented.</p>
</div>
<div class="sect3">
<h4 id="_at_indexing_level"><a class="anchor" href="#_at_indexing_level"></a>9.4.1. At indexing level</h4>
<div class="paragraph">
<p>When Hibernate Search indexes an entity annotated with <code>@Spatial</code>, it instantiates a
<code>SpatialFieldBridge</code> to transform the latitude and longitude fields accessed via the <code>Coordinates</code>
interface to the multiple index fields stored in the Lucene index.</p>
</div>
<div class="paragraph">
<p>Principle of the spatial index: the spatial index used in Hibernate Search is a
<a href="http://en.wikipedia.org/wiki/Grid_(spatial_index)#Grid-based_spatial_indexing">grid based spatial index</a> where grid ids
are hashes derived from latitude and longitude.</p>
</div>
<div class="paragraph">
<p>To make computations easier the latitude and longitude field values will be
projected into a flat coordinate system with the help of a <a href="http://en.wikipedia.org/wiki/Sinusoidal_projection">sinusoidal projection</a>.
Origin value space is :</p>
</div>
<div class="paragraph">
<p>[-90 &#8594; +90],]-180 &#8594;; 180]</p>
</div>
<div class="paragraph">
<p>for latitude,longitude coordinates and projected space is:</p>
</div>
<div class="paragraph">
<p>]-pi &#8594; +pi],[-pi/2 &#8594; +pi/2]</p>
</div>
<div class="paragraph">
<p>for Cartesian x,y coordinates (beware of fields order inversion: x is longitude and y is latitude).</p>
</div>
<div class="paragraph">
<p>The index is divided into n levels labeled from 0 to n-1.</p>
</div>
<div class="paragraph">
<p>At the level 0 the projected space is the whole Earth. At the level 1 the projected space is divided
into 4 rectangles (called boxes as in bounding box):</p>
</div>
<div class="paragraph">
<p>[-pi,-pi/2]&#8594;[0,0], [-pi,0]&#8594;[0,+pi/2], [0,-pi/2]&#8594;[+pi,0] and [0,0]&#8594;[+pi,+pi/2]</p>
</div>
<div class="paragraph">
<p>At level n+1 each box of level n is divided into 4 new boxes and so on. The numbers of boxes at a
given level is 4^n.</p>
</div>
<div class="paragraph">
<p>Each box is given an id, in this format: [Box index on the X axis]|[Box index on the Y axis]. To
calculate the index of a box on an axis we divide the axis range in 2^n slots and find the slot the
box belongs to. At the n level the indexes on an axis are from -(2^n)/2 to (2^n)/2. For instance,
the 5th level has 4^5 = 1024 boxes with 32 indexes on each axis (32x32 is 1024) and the box of Id
"0|8" is covering the [0,8/32*pi/2]&#8594;[1/32*pi,9/32*pi/2] rectangle is projected space.</p>
</div>
<div class="paragraph">
<p>Beware! The boxes are rectangles in projected space but the related area on Earth is not rectangular!</p>
</div>
<div class="paragraph">
<p>Now that we have all these boxes at all these levels, we index points "into" them.</p>
</div>
<div class="paragraph">
<p>For a point (lat,long) we calculate its projection (x,y) and then we calculate for each level of the
spatial index, the ids of the boxes it belongs to.</p>
</div>
<div class="paragraph">
<p>At each level the point is in one and only one box. For points on the edges the box are considered
exclusive n the left side and inclusive on the right i-e ]start,end] (the points are normalized
before projection to [-90,+90],]-180,+180]).</p>
</div>
<div class="paragraph">
<p>We store in the Lucene document corresponding to the entity to index one field for each level of the
spatial hash grid. The field is named: <em class="spatial index fields name">HSSI</em>[n]. [spatial index fields
name] is given either by the parameter at class level annotation or derived from the name of the
spatial annotated method of the entity, HSSI stands for Hibernate Search Spatial Index and n is the
level of the spatial hashes grid.</p>
</div>
<div class="paragraph">
<p>We also store the latitude and longitude as a numeric field under [spatial index fields
name]_HSSI_Latitude and [spatial index fields name]_HSSI_Longitude fields. They will be used to
filter precisely results by distance in the second stage of the search.</p>
</div>
</div>
<div class="sect3">
<h4 id="_at_search_level"><a class="anchor" href="#_at_search_level"></a>9.4.2. At search level</h4>
<div class="paragraph">
<p>Now that we have all these fields, what are they used for?</p>
</div>
<div class="paragraph">
<p>When you ask for a spatial search by providing a search discus (center+radius) we will calculate the
box ids that do cover the search discus in the projected space, fetch all the documents that
belong to these boxes (thus narrowing the number of documents for which we will have to calculate
distance to the center) and then filter this subset with a real distance calculation. This is called
two level spatial filtering.</p>
</div>
<div class="sect4">
<h5 id="_step_1_compute_the_best_spatial_hashes_grid_level_for_the_search_discus"><a class="anchor" href="#_step_1_compute_the_best_spatial_hashes_grid_level_for_the_search_discus"></a>Step 1: Compute the best spatial hashes grid level for the search discus</h5>
<div class="paragraph">
<p>For a given search radius there is an optimal hash grid level where the number of boxes to
retrieve shall be minimal without bringing back to many documents (level 0 has only 1 box but
retrieve all documents). The optimal hash grid level is the maximum level where the width of each
box is larger than the search area. Near the equator line where projection deformation is minimal,
this will lead to the retrieval of at most 4 boxes. Towards the poles where the deformation is more
significant, it might need to examine more boxes but as the sinusoidal projection has a simple
Tissot&#8217;s indicatrix (see <a href="http://en.wikipedia.org/wiki/Sinusoidal_projection">Sinusoidal projection</a>) in populated areas,
the overhead is minimal.</p>
</div>
</div>
<div class="sect4">
<h5 id="_step_2_compute_ids_of_the_corresponding_covering_boxes_at_that_level"><a class="anchor" href="#_step_2_compute_ids_of_the_corresponding_covering_boxes_at_that_level"></a>Step 2: Compute ids of the corresponding covering boxes at that level</h5>
<div class="paragraph">
<p>Now that we have chosen the optimal level, we can compute the ids of the boxes covering the search
discus (which is not a discus in projected space anymore).</p>
</div>
<div class="paragraph">
<p>This is done by <code>org.hibernate.search.spatial.impl.SpatialHelper.getSpatialHashCellsIds(Point center,
double radius, int spatialHashLevel)</code></p>
</div>
<div class="paragraph">
<p>It will calculate the bounding box of the search discus and then call
<code>org.hibernate.search.spatial.impl.SpatialHelper.getSpatialHashCellsIds(Point lowerLeft, Point
upperRight, int spatialHashLevel)</code> that will do the actual computation. If the bounding box crosses
the meridian line it will cut the search in two and make two calls to <code>getSpatialHashCellsIds(Point
lowerLeft, Point upperRight, int spatialHashLevel)</code> with left and right parts of the box.</p>
</div>
<div class="paragraph">
<p>There are some geo related hacks (search radius too large, search radius crossing the poles) that
are handled in bounding box computations done by <code>Rectangle.fromBoundingCircle(Coordinates center,
double radius)</code> (see <a href="http://janmatuschek.de/LatitudeLongitudeBoundingCoordinates" class="bare">http://janmatuschek.de/LatitudeLongitudeBoundingCoordinates</a> for reference on
those subjects).</p>
</div>
<div class="paragraph">
<p>The <code>SpatialHelper.getSpatialHashCellsIds(Point lowerLeft, Point upperRight, int spatialHashLevel)</code>
project the defining points of the bounding box and compute the boxes they belong to. It returns all
the box Ids between the lower left to the upper right corners, thus covering the area.</p>
</div>
</div>
<div class="sect4">
<h5 id="_step_3_lucene_index_lookup"><a class="anchor" href="#_step_3_lucene_index_lookup"></a>Step 3: Lucene index lookup</h5>
<div class="paragraph">
<p>The query is built with theses Ids searching for documents having a <em class="spatial index fields
name">HSSI</em>[n] (n the level found at Step 1) field valued with one of the ids of Step 2.</p>
</div>
<div class="paragraph">
<p>See also the implementation of <code>org.hibernate.search.spatial.impl.SpatialHashFilter</code>.</p>
</div>
<div class="paragraph">
<p>This query will return all documents in the boxes covering the projected bounding box of the search
discus. So it is too large and needs refining. But we have narrowed the distance calculation
problems to a subset of our data.</p>
</div>
</div>
<div class="sect4">
<h5 id="_step_4_refine"><a class="anchor" href="#_step_4_refine"></a>Step 4: Refine</h5>
<div class="paragraph">
<p>A distance calculation filter is set after the Lucene index lookup query of Step 3 to exclude false
candidates from the result list.</p>
</div>
<div class="paragraph">
<p>See <code>SpatialQueryBuilderFromCoordinates.buildSpatialQuery(Coordinates center, double radius, String
fieldName)</code></p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="search-lucene-native"><a class="anchor" href="#search-lucene-native"></a>10. Advanced features</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In this final chapter we are offering a smrgsbord of tips and tricks which might become useful as
you dive deeper and deeper into Hibernate Search.</p>
</div>
<div class="sect2">
<h3 id="AccessingSearchFactory"><a class="anchor" href="#AccessingSearchFactory"></a>10.1. Accessing the <code>SearchFactory</code></h3>
<div class="paragraph">
<p>The <code>SearchFactory</code> object keeps track of the underlying Lucene resources for Hibernate Search. It is
a convenient way to access Lucene natively. The <code>SearchFactory</code> can be accessed from a
FullTextSession:</p>
</div>
<div class="exampleblock">
<div class="title">Example 144. Accessing the <code>SearchFactory</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">FullTextSession fullTextSession = Search.getFullTextSession(regularSession);
SearchFactory searchFactory = fullTextSession.getSearchFactory();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="AccessingSearchIntegrator"><a class="anchor" href="#AccessingSearchIntegrator"></a>10.2. Accessing the <code>SearchIntegrator</code></h3>
<div class="paragraph">
<p>The interface <code>SearchIntegrator</code> gives access to lower level APIs of Hibernate Search.
You can access the <code>SearchIntegrator</code> SPI using the SearchFactory (<a href="#AccessingSearchFactory">Accessing the <code>SearchFactory</code></a>):</p>
</div>
<div class="exampleblock">
<div class="title">Example 145. Accessing the <code>SearchIntegrator</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">SearchIntegrator searchIntegrator = searchFactory.unwrap(SearchIntegrator.class);</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="IndexReaders"><a class="anchor" href="#IndexReaders"></a>10.3. Using an <code>IndexReader</code></h3>
<div class="paragraph">
<p>Queries in Lucene are executed on an <code>IndexReader</code>. Hibernate Search caches index readers to maximize
performance and implements other strategies to retrieve updated IndexReaders in order to minimize IO
operations. Your code can access these cached resources, but you have to follow some "good citizen"
rules.</p>
</div>
<div class="exampleblock">
<div class="title">Example 146. Accessing an <code>IndexReader</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">IndexReader reader = searchFactory.getIndexReaderAccessor().open(Order.class);
try {
   //perform read-only operations on the reader
}
finally {
   searchFactory.getIndexReaderAccessor().close(reader);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>In this example the SearchFactory figures out which indexes are needed to query this entity. Using
the configured ReaderProvider (described in <a href="#search-architecture-readerstrategy">Reader strategy</a>) on each index,
it returns a compound <code>IndexReader</code> on top of all involved indexes. Because this <code>IndexReader</code> is
shared amongst several clients, you must adhere to the following rules:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Never call <code>indexReader.close()</code>, but always call <code>readerProvider.closeReader(reader)</code>, using a
finally block.</p>
</li>
<li>
<p>Don&#8217;t use this <code>IndexReader</code> for modification operations: it&#8217;s a read-only instace, you would
get an exception.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Aside from those rules, you can use the <code>IndexReader</code> freely, especially to do native Lucene queries.
Using this shared IndexReaders will be more efficient than by opening one directly from - for
example - the filesystem.</p>
</div>
<div class="paragraph">
<p>As an alternative to the method <code>open(Class&#8230;&#8203; types)</code> you can use <code>open(String&#8230;&#8203; indexNames)</code>
in this case you pass in one or more index names; using this strategy you can also select a subset
of the indexes for any indexed type if sharding is used.</p>
</div>
<div class="exampleblock">
<div class="title">Example 147. Accessing an <code>IndexReader</code> by index names</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">IndexReader reader = searchFactory
      .getIndexReaderAccessor()
      .open("Products.1", "Products.3");</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_accessing_a_lucene_directory"><a class="anchor" href="#_accessing_a_lucene_directory"></a>10.4. Accessing a Lucene Directory</h3>
<div class="paragraph">
<p>A Directory is the most common abstraction used by Lucene to represent the index storage; Hibernate
Search doesn&#8217;t interact directly with a Lucene Directory but abstracts these interactions via an
IndexManager: an index does not necessarily need to be implemented by a Directory.</p>
</div>
<div class="paragraph">
<p>If you are certain that your index is represented as a Directory and need to access it, you can get
a reference to the Directory via the IndexManager. You will have to cast the IndexManager instance
to a DirectoryBasedIndexManager and then use <code>getDirectoryProvider().getDirectory()</code> to get a
reference to the underlying Directory. This is not recommended, if you need low level access to the
index using Lucene APIs we suggest to see <a href="#IndexReaders">Using an <code>IndexReader</code></a> instead.</p>
</div>
</div>
<div class="sect2">
<h3 id="advanced-features-sharding"><a class="anchor" href="#advanced-features-sharding"></a>10.5. Sharding indexes</h3>
<div class="paragraph">
<p>In some cases it can be useful to split (shard) the data into several Lucene indexes. There are two
main use use cases:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A single index is so big that index update times are slowing the application down. In this case
static sharding can be used to split the data into a pre-defined number of shards.</p>
</li>
<li>
<p>Data is naturally segmented by customer, region, language or other application parameter and the
index should be split according to these segments. This is a use case for dynamic sharding.</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>By default sharding is not enabled.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_static_sharding"><a class="anchor" href="#_static_sharding"></a>10.5.1. Static sharding</h4>
<div class="paragraph">
<p>To enable static sharding set the hibernate.search.&lt;indexName&gt;.sharding_strategy.nbr_of_shards
property as seen in <a href="#example-index-sharding">Enabling index sharding</a>.</p>
</div>
<div id="example-index-sharding" class="exampleblock">
<div class="title">Example 148. Enabling index sharding</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre>hibernate.search.[default|&lt;indexName&gt;].sharding_strategy.nbr_of_shards = 5</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The default sharding strategy which gets enabled by setting this property, splits the data according
to the hash value of the document id (generated by the FieldBridge). This ensures a fairly balanced
sharding. You can replace the default strategy by implementing a custom IndexShardingStrategy. To
use your custom strategy you have to set the
hibernate.search.[default|&lt;indexName&gt;].sharding_strategy property to the fully qualified class
name of your custom IndexShardingStrategy.</p>
</div>
<div id="example-index-sharding-strategy" class="exampleblock">
<div class="title">Example 149. Registering a custom IndexShardingStrategy</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre>hibernate.search.[default|&lt;indexName&gt;].sharding_strategy = my.custom.RandomShardingStrategy</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="advanced-features-dynamic-sharding"><a class="anchor" href="#advanced-features-dynamic-sharding"></a>10.5.2. Dynamic sharding</h4>
<div class="paragraph">
<p>Dynamic sharding allows you to manage the shards yourself and even create new shards on the fly. To
do so you need to implement the interface ShardIdentifierProvider and set the
hibernate.search.[default|&lt;indexName&gt;].sharding_strategy property to the fully qualified name
of this class. Note that instead of implementing the interface directly, you should rather derive
your implementation from org.hibernate.search.store.ShardIdentifierProviderTemplate which provides a
basic implementation. Let&#8217;s look at <a href="#example-custom-shard-identifier-provider">Custom ShardIdentifierProvider</a> for an example.</p>
</div>
<div id="example-custom-shard-identifier-provider" class="exampleblock">
<div class="title">Example 150. Custom ShardIdentifierProvider</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public static class AnimalShardIdentifierProvider extends ShardIdentifierProviderTemplate {

 @Override
 public String getShardIdentifier(Class&lt;?&gt; entityType, Serializable id,
         String idAsString, Document document) {
    if (entityType.equals(Animal.class)) {
       String typeValue = document.getField("type").stringValue();
       addShard(typeValue);
       return typeValue;
    }
    throw new RuntimeException("Animal expected but found " + entityType);
 }

 @Override
 protected Set&lt;String&gt; loadInitialShardNames(Properties properties, BuildContext buildContext) {
    ServiceManager serviceManager = buildContext.getServiceManager();
    SessionFactory sessionFactory = serviceManager.requestService(
        HibernateSessionFactoryService.class).getSessionFactory();
    Session session = sessionFactory.openSession();
    try {
       Criteria initialShardsCriteria = session.createCriteria(Animal.class);
       initialShardsCriteria.setProjection(Projections.distinct(Property.forName("type")));
       List&lt;String&gt; initialTypes = initialShardsCriteria.list();
       return new HashSet&lt;String&gt;(initialTypes);
    }
    finally {
       session.close();
    }
 }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The are several things happening in <code>AnimalShardIdentifierProvider</code>. First off its purpose is to
create one shard per animal type (e.g. mammal, insect, etc.). It does so by inspecting the class
type and the Lucene document passed to the <code>getShardIdentifier()</code> method. It extracts the type field
from the document and uses it as shard name. <code>getShardIdentifier()</code> is called for every addition to
the index and a new shard will be created with every new animal type encountered. The base class
<code>ShardIdentifierProviderTemplate</code> maintains a set with all known shards to which any identifier must
be added by calling <code>addShard()</code>.</p>
</div>
<div class="paragraph">
<p>It is important to understand that Hibernate Search cannot know which shards already exist when the
application starts. When using <code>ShardIdentifierProviderTemplate</code> as base class of a
<code>ShardIdentifierProvider</code> implementation, the initial set of shard identifiers must be returned by the
<code>loadInitialShardNames()</code> method. How this is done will depend on the use case. However, a common case
in combination with Hibernate ORM is that the initial shard set is defined by the distinct
values of a given database column. <a href="#example-custom-shard-identifier-provider">Custom ShardIdentifierProvider</a> shows how to handle
such a case. <code>AnimalShardIdentifierProvider</code> makes in its <code>loadInitialShardNames()</code> implementation use
of a service called <code>HibernateSessionFactoryService</code> (see also <a href="#section-services">Using external services</a>) which is
available within an ORM environment. It allows to request a Hibernate <code>SessionFactory</code> instance which
can be used to run a Criteria query in order to determine the initial set of shard identifiers.</p>
</div>
<div class="paragraph">
<p>Last but not least, the <code>ShardIdentifierProvider</code> also allows for optimizing searches by selecting
which shard to run a query against. By activating a filter (see <a href="#query-filter-shard">Using filters in a sharded environment</a>), a sharding
strategy can select a subset of the shards used to answer a query (<code>getShardIdentifiersForQuery()</code>,
not shown in the example) and thus speed up the query execution.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>This ShardIdentifierProvider is considered experimental. We might need to apply some changes to the
defined method signatures to accommodate for unforeseen use cases. Please provide feedback if you
have ideas, or just to let us know how you&#8217;re using this API.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section-sharing-indexes"><a class="anchor" href="#section-sharing-indexes"></a>10.6. Sharing indexes</h3>
<div class="paragraph">
<p>It is technically possible to store the information of more than one entity into a single Lucene
index. There are two ways to accomplish this:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Configuring the underlying directory providers to point to the same physical index directory.
In practice, you set the property <code>hibernate.search.[fully qualified entity name].indexName</code> to the
same value. As an example, let&#8217;s use the same index (directory) for the <code>Furniture</code> and <code>Animal</code>
entities. We just set <code>indexName</code> for both entities to "Animal". Both entities will then be stored
in the Animal directory:</p>
</li>
</ul>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>hibernate.search.org.hibernate.search.test.shards.Furniture.indexName = Animal
hibernate.search.org.hibernate.search.test.shards.Animal.indexName = Animal</pre>
</div>
</div>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Setting the @Indexed annotation&#8217;s index attribute of the entities you want to merge to the
same value. If we again wanted all Furniture instances to be indexed in the Animal index along with
all instances of Animal we would specify @Indexed(index="Animal") on both Animal and Furniture classes.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>This is only presented here so that you know the option is available. There is really not much
benefit in sharing indexes.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="section-services"><a class="anchor" href="#section-services"></a>10.7. Using external services</h3>
<div class="paragraph">
<p>A <code>Service</code> in Hibernate Search is a class implementing the interface
<code>org.hibernate.search.engine.service.spi.Service</code> and providing a default no-arg constructor.
Theoretically that&#8217;s all that is needed to request a given service type from the Hibernate Search
<code>ServiceManager</code>. In practice you want probably want to add some service life cycle methods
(implement <code>Startable</code> and <code>Stoppable</code>) as well as actual methods providing some functionality.</p>
</div>
<div class="paragraph">
<p>Hibernate Search uses the service approach to decouple different components of
the system. Let&#8217;s have a closer look at services and how they are used.</p>
</div>
<div class="sect3">
<h4 id="_using_a_service"><a class="anchor" href="#_using_a_service"></a>10.7.1. Using a Service</h4>
<div class="paragraph">
<p>Many of of the pluggable contracts of Hibernate Search can use services. Services are accessible via
the <code>BuildContext</code> interface as in the following example.</p>
</div>
<div class="exampleblock">
<div class="title">Example 151. Example of a custom DirectoryProvider using a ClassLoaderService</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">public CustomDirectoryProvider implements DirectoryProvider&lt;RAMDirectory&gt; {
    private ServiceManager serviceManager;
    private ClassLoaderService classLoaderService;

    public void initialize(
        String directoryProviderName,
        Properties properties,
        BuildContext context) {
        //get a reference to the ServiceManager
        this.serviceManager = context.getServiceManager();
    }

    public void start() {
        //get the current ClassLoaderService
        classLoaderService = serviceManager.requestService(ClassLoaderService.class);
    }

    public RAMDirectory getDirectory() {
        //use the ClassLoaderService
    }

    public stop() {
        //make sure to release all services
        serviceManager.releaseService(ClassLoaderService.class);
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>When you request a service, an instance of the requested service type is returned to you.
Make sure release the service via <code>ServiceManager.releaseService</code> once you don&#8217;t need it
anymore. Note that the service can be released in the <code>DirectoryProvider.stop</code> method if
the <code>DirectoryProvider</code> uses the service during its lifetime or could be released right away
if the service is only needed during initialization time.</p>
</div>
</div>
<div class="sect3">
<h4 id="_implementing_a_service"><a class="anchor" href="#_implementing_a_service"></a>10.7.2. Implementing a Service</h4>
<div class="paragraph">
<p>To implement a service, you need to create an interface which identifies it and extends
<code>org.hibernate.search.engine.service.spi.Service</code>. You can then add additional methods to your service
interface as needed.</p>
</div>
<div class="paragraph">
<p>Naturally you will also need to provide an implementation of your service interface. This
implementation must have a public no-arg constructor. Optionally your service can also
implement the life cycle methods <code>org.hibernate.search.engine.service.spi.Startable</code>
and/or <code>org.hibernate.search.engine.service.spi.Stoppable</code>. These methods will be called by the
<code>ServiceManager</code> when the service is created respectively the last reference to a requested service
is released.</p>
</div>
<div class="paragraph">
<p>Services are retrieved from the <code>ServiceManager.requestService</code> using the <code>Class</code> object of the
interface you define as a key.</p>
</div>
<div class="sect4">
<h5 id="_managed_services"><a class="anchor" href="#_managed_services"></a>Managed services</h5>
<div class="paragraph">
<p>To transparently discover services Hibernate Search uses the Java ServiceLoader mechanism. This means
you need to add a service file to your jar under <code>/META-INF/services/</code> named after the fully qualified
classname of your service interface. The content of the file contains the fully qualified
classname of your service implementation.</p>
</div>
<div class="exampleblock">
<div class="title">Example 152. Service file for the Infinispan CacheManagerService service</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre>/META-INF/services/org.infinispan.hibernate.search.spi.CacheManagerService</pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 153. Content of META-INF/services/org.infinispan.hibernate.search.spi.CacheManagerService</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre>org.infinispan.hibernate.search.impl.DefaultCacheManagerService</pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Hibernate Search only supports a single service implementation of a given service. There is no
mechanism to select between multiple versions of a service. It is an
error to have multiple jars defining each a different implementation for the same service.
If you want to override the implementation of a already existing service at runtime you will need to
look at <a href="#section-provided-services">Provided services</a>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="section-provided-services"><a class="anchor" href="#section-provided-services"></a>Provided services</h5>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Provided services are usually used by frameworks integrating with Hibernate
Search and not by library users themselves.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>As an alternative to manages services, a service can be provided by the environment bootstrapping
Hibernate Search. For example, Infinispan which uses Hibernate Search as its internal search engine,
passes the <code>CacheContainer</code> to Hibernate Search.
In this case, the <code>CacheContainer</code> instance is not managed by Hibernate Search and the start/stop
methods defined by optional <code>Stoppable</code> and <code>Startable</code> interfaces will be ignored.</p>
</div>
<div class="paragraph">
<p>A Service implementation which is only used as a Provided Service doesn&#8217;t need to have a public
constructor taking no arguments.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Provided services have priority over managed services. If a provided service is registered with the
same <code>ServiceManager</code> instance as a managed service, the provided service will be used.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The provided services are passed to Hibernate Search via the <code>SearchConfiguration</code> interface: as
implementor of method <code>getProvidedServices</code> you can return a <code>Map</code> of all services you need to
provide.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When implementing a custom <code>org.hibernate.search.cfg.spi.SearchConfiguration</code> we recommend you
extend the base class <code>org.hibernate.search.cfg.spi.SearchConfigurationBase</code>: that will improve
compatibility by not breaking your code when we need to add new methods to this interface.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_customizing_lucene_s_scoring_formula"><a class="anchor" href="#_customizing_lucene_s_scoring_formula"></a>10.8. Customizing Lucene&#8217;s scoring formula</h3>
<div class="paragraph">
<p>Lucene allows the user to customize its scoring formula by extending
org.apache.lucene.search.similarities.Similarity. The abstract methods defined in this class match
the factors of the following formula calculating the score of query q for document d:</p>
</div>
<div class="paragraph">
<p><strong>score(q,d) = coord(q,d)  queryNorm(q)   ~t in q~ ( tf(t in d)  idf(t) <sup>2</sup>  t.getBoost()  norm(t,d) )</strong></p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Factor</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">tf(t ind)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Term frequency factor for the term (t) in the document
              (d).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">idf(t)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Inverse document frequency of the term.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">coord(q,d)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Score factor based on how many of the query terms are
              found in the specified document.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">queryNorm(q)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Normalizing factor used to make scores between queries
              comparable.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">t.getBoost()</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Field boost.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">norm(t,d)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Encapsulates a few (indexing time) boost and length
              factors.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>It is beyond the scope of this manual to explain this formula in more detail. Please refer to
Similarity&#8217;s Javadocs for more information.</p>
</div>
<div class="paragraph">
<p>Hibernate Search provides two ways to modify Lucene&#8217;s similarity calculation.</p>
</div>
<div class="paragraph">
<p>First you can set the default similarity by specifying the fully specified classname of your
Similarity implementation using the property hibernate.search.similarity. The default value is
org.apache.lucene.search.similarities.ClassicSimilarity.</p>
</div>
<div class="paragraph">
<p>Secondly, you can override the similarity used for a specific index by setting the <code>similarity</code>
property for this index (see <a href="#search-configuration-directory">Directory configuration</a> for more information about index
configuration):</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>hibernate.search.[default|&lt;indexname&gt;].similarity = my.custom.Similarity</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>As an example, let&#8217;s assume it is not important how often a term appears in a document. Documents
with a single occurrence of the term should be scored the same as documents with multiple
occurrences. In this case your custom implementation of the method <code>tf(float freq)</code> should return 1.0.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When two entities share the same index they must declare the same Similarity implementation.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="section-multi-tenancy"><a class="anchor" href="#section-multi-tenancy"></a>10.9. Multi-tenancy</h3>
<div class="sect3">
<h4 id="_what_is_multi_tenancy"><a class="anchor" href="#_what_is_multi_tenancy"></a>10.9.1. What is multi-tenancy?</h4>
<div class="paragraph">
<p>The term multi-tenancy in general is applied to software development to indicate an architecture in
which a single running instance of an application simultaneously serves multiple clients (tenants).
Isolating information (data, customizations, etc) pertaining to the various tenants is a particular
challenge in these systems.
This includes the data owned by each tenant stored in the database.
You will find more details on how to enable multi-tenancy with Hibernate in the
<a href="http://docs.jboss.org/hibernate/orm/4.3/devguide/en-US/html/ch16.html">Hibernate ORM developer&#8217;s guide</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_using_a_tenant_aware_code_fulltextsession_code"><a class="anchor" href="#_using_a_tenant_aware_code_fulltextsession_code"></a>10.9.2. Using a tenant-aware <code>FullTextSession</code></h4>
<div class="paragraph">
<p>Hibernate Search supports multi-tenancy on top of Hibernate ORM, it stores the tenant identifier in
the document and automatically filters the query results.</p>
</div>
<div class="paragraph">
<p>The <code>FullTextSession</code> will be bound to the specific tenant ("client-A" in the example)
and the mass indexer will only index the entities associated to that tenant identifier.</p>
</div>
<div class="exampleblock">
<div class="title">Example 154. Bind the session to a tenant</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">Session session = getSessionFactory()
                      .withOptions()
                          .tenantIdentifier( "client-A" )
                  .openSession();

FullTextSession session = Search.getFullTextSession( session );</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The use of a tenant identifier will have the following effects:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Every document saved or updated in the index will have an additional field <code>__HSearch_TenantId</code>
containing the tenant identifier.</p>
</li>
<li>
<p>Every search will be filtered using the tenant identifier.</p>
</li>
<li>
<p>The MassIndexer (see <a href="#search-batchindex-massindexer">Using a MassIndexer</a>) will only affect the currently selected tenant.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Note that not using a tenant will return all the matching results for all the tenants in the index.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="elasticsearch-integration"><a class="anchor" href="#elasticsearch-integration"></a>11. Integration with Elasticsearch</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_status"><a class="anchor" href="#_status"></a>11.1. Status</h3>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph">
<p>This feature is a work in progress.
Make sure to read the <a href="#elasticsearch-limitations">Limitations</a> section!</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The integration with Elasticsearch is in development and should be considered experimental.
We do think we have the basics covered and we are looking for feedback.</p>
</div>
<div class="paragraph">
<p>Patches can be sent as pull requests to the <a href="https://github.com/hibernate/hibernate-search">Github repository</a>,
but also general feedback, suggestions and questions are very welcome.
To get in touch or find other interesting links for contributors, see the <a href="http://hibernate.org/community/">Community page</a>
of the Hibernate website.</p>
</div>
</div>
<div class="sect2">
<h3 id="_goal_of_the_elasticsearch_integration"><a class="anchor" href="#_goal_of_the_elasticsearch_integration"></a>11.2. Goal of the Elasticsearch integration</h3>
<div class="paragraph">
<p>The goal of integrating with Elasticsearch is to allow Hibernate Search users to benefit
from the full-text capabilities integrated with Hibernate ORM
but replacing the local Lucene based index with a remote Elasticsearch service.</p>
</div>
<div class="paragraph">
<p>There could be various reasons to prefer this over an "embedded Lucene" approach:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>wish to separate the service running your application from the Search service (Microservices)</p>
</li>
<li>
<p>benefit from Elasticsearch&#8217;s out of the box horizontal scalability and high availability features</p>
</li>
<li>
<p>integrate with an existing Elasticsearch cluster</p>
</li>
<li>
<p>explore the data updated by an Hibernate powered application using the Elasticsearch dashboard integrations such as Kibana</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There are a couple of drawbacks compared to the embedded Lucene approach though:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>incur a performance penalty of remote RPCs both for index updates and to run queries</p>
</li>
<li>
<p>need to manage an additional service</p>
</li>
<li>
<p>possibly need to buy and manage additional servers</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Which solution is best will depend on the specific needs of your system and your organization.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Why not use Elasticsearch directly?</div>
<div class="paragraph">
<p>The #1 reason is that Hibernate Search integrates perfectly with Hibernate ORM.
All changes done to your objects will trigger the necessary index changes transparently.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>it will honor the transaction boundary - i.e. not do the indexing work if the transaction ends up in rollback</p>
</li>
<li>
<p>changes to cascaded objects are handled</p>
</li>
<li>
<p>changes to nested object embedded in a root indexed entity are handled</p>
</li>
<li>
<p>changes will be sent in bulk - i.e. optimized systematically for you</p>
</li>
<li>
<p>it generates JSON encoded requests from your entities, parses reponses</p>
</li>
<li>
<p>manages the connection pools</p>
</li>
<li>
<p>etc.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There is no more paradigm shift in your code.
You are working on Hibernate ORM managed objects,
doing your queries on object properties with a nice Java DSL.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_getting_started_and_configuration"><a class="anchor" href="#_getting_started_and_configuration"></a>11.3. Getting started and configuration</h3>
<div class="paragraph">
<p>To experiment with the Elasticsearch integration you will have to download Elasticsearch and run it:
Hibernate Search connects to an Elasticsearch node but does not provide one.</p>
</div>
<div class="paragraph">
<p>One option is to use the <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docker.html">Elasticsearch Docker image</a>.</p>
</div>
<div class="sect3">
<h4 id="_elasticsearch_version"><a class="anchor" href="#_elasticsearch_version"></a>11.3.1. Elasticsearch version</h4>
<div class="paragraph">
<p>Hibernate Search expects an Elasticsearch cluster running version 2.x or 5.x.
The version running on your cluster will be automatically detected on startup,
and Hibernate Search will adapt based on the detected version.</p>
</div>
<div class="paragraph">
<p>The targeted version is mostly transparent to Hibernate Search users,
but there are a few differences in how Hibernate Search behaves depending
on the Elasticsearch version that may affect you.
The following table details those differences.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"></th>
<th class="tableblock halign-left valign-top">2.x</th>
<th class="tableblock halign-left valign-top">5.0/5.1</th>
<th class="tableblock halign-left valign-top">5.2+</th>
</tr>
</thead>
<tbody>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Configuration required for purges</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#elasticsearch-integration-server-configuration">Enable the delete-by-query plugin</a></p></td>
<td class="tableblock halign-left valign-top" colspan="2"><p class="tableblock">None</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Datatype used for String fields in Elasticsearch</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>string</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>text</code> (if analyzed) or <code>keyword</code> (if not).
 The <code>string</code> datatype <a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.0/string.html">has been deprecated in Elasticsearch 5.0</a>.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>text</code> (if analyzed with an <a href="#analyzer">analyzer</a>) or <code>keyword</code> (if not analyzed or analyzed with a <a href="#section-normalizers">normalizer</a>).</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><a href="#field-annotation-norms">Norms</a></p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">Not implemented</p></td>
<td class="tableblock halign-left valign-top" colspan="2"><p class="tableblock">Implemented</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Implementation of <a href="#field-annotation-indexNullAs"><code>@Field.indexNullAs</code></a> for analyzed text fields</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://www.elastic.co/guide/en/elasticsearch/reference/2.4/null-value.html"><code>null_value</code></a> is added to the mapping,
  <code>null</code> values are indexed as such.</p></td>
<td class="tableblock halign-left valign-top" colspan="2"><p class="tableblock"><a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.0/null-value.html"><code>null_value</code></a> is not available for <code>text</code> fields,
  null values are replaced with the <code>indexNullAs</code> value explicitly when indexing.
 <br>
  This does not apply to <code>keyword</code> fields.</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">Configuration required for spatial projections without a spatial sort</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#elasticsearch-integration-server-configuration">Enable and configure the groovy plugin</a></p></td>
<td class="tableblock halign-left valign-top" colspan="2"><p class="tableblock">None</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The testsuite of Hibernate Search runs against Elasticsearch 5.6.0 by default.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_upgrading_elasticsearch"><a class="anchor" href="#_upgrading_elasticsearch"></a>Upgrading Elasticsearch</h5>
<div class="paragraph">
<p>When upgrading your Elasticsearch cluster, some
<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/setup-upgrade.html">administrative tasks</a>
are still required on your cluster: Hibernate Search will not take care of those.</p>
</div>
<div class="paragraph">
<p>On top of that, there are some fundamental differences between some versions of Elasticsearch,
and for that reason, some upgrades will require you to delete your indexes manually and <a href="#search-batchindex">reindex your data</a>.</p>
</div>
<div class="paragraph">
<p>The upgrades that require such changes are the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>upgrading from 2.x to 5.x, because Hibernate Search does not support the <code>string</code> datatype on Elasticsearch 5.x;</p>
</li>
<li>
<p>upgrading from 5.0/5.1 to 5.2+ if you used <a href="#section-normalizer">normalizers</a>,
because Hibernate Search normalizers are mapped to native Elasticsearch normalizers starting from Elasticsearch 5.2,
thereby changing the datatype of fields using normalizers from <code>text</code> to <code>keyword</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="elasticsearch-integration-dependencies"><a class="anchor" href="#elasticsearch-integration-dependencies"></a>11.3.2. Dependencies in your Java application</h4>
<div class="paragraph">
<p>In addition to the usual dependencies like Hibernate ORM and Hibernate Search,
you will need the new <code>hibernate-search-elasticsearch</code> jar.</p>
</div>
<div class="exampleblock">
<div class="title">Example 155. Maven dependencies for Hibernate Search with Elasticsearch</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-XML" data-lang="XML">&lt;dependency&gt;
   &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
   &lt;artifactId&gt;hibernate-search-elasticsearch&lt;/artifactId&gt;
   &lt;version&gt;5.8.0.Final&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>If you use Amazon&#8217;s proprietary IAM authentication through request signing to access Elasticsearch,
you will need an additional dependency to handle authentication:
<code>hibernate-search-elasticsearch-aws</code>.</p>
</div>
<div class="exampleblock">
<div class="title">Example 156. Maven dependencies for Hibernate Search with AWS-hosted Elasticsearch</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-XML" data-lang="XML">&lt;dependency&gt;
   &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
   &lt;artifactId&gt;hibernate-search-elasticsearch-aws&lt;/artifactId&gt;
   &lt;version&gt;5.8.0.Final&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="elasticsearch-integration-server-configuration"><a class="anchor" href="#elasticsearch-integration-server-configuration"></a>11.3.3. Elasticsearch configuration</h4>
<div class="paragraph">
<p>Hibernate Search can work with an Elasticsearch server without altering its configuration.</p>
</div>
<div class="paragraph">
<p>However some features offered by Hibernate Search require specific configuration:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>on Elasticsearch 2.x only (not necessary on 5.x): if you want to be able to use the Hibernate Search <a href="#search-batchindex-massindexer">MassIndexer</a>
with <code>purgeAllOnStart</code> enabled - it is enabled by default -, or to use <code>FullTextSession.purge()</code> or <code>FullTextSession.purgeAll()</code>,
install the <a href="https://www.elastic.co/guide/en/elasticsearch/plugins/2.2/plugins-delete-by-query.html"><code>delete-by-query</code> plugin</a></p>
</li>
<li>
<p>on Elasticsearch 2.x only (not necessary on 5.x): if you want to retrieve the distance in a geolocation query, enable the <code>lang-groovy</code> plugin,
see <a href="#elasticsearch-query-spatial">Elasticsearch Spatial queries</a></p>
</li>
<li>
<p>if you want to use paging (as opposed to <a href="#elasticsearch-scrolling">scrolling</a>) on result sets larger than 10000 elements
(for instance access the 10001st result),
you may increase the value of the <code>index.max_result_window</code> property (default is 10000).</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="elasticsearch-integration-configuration"><a class="anchor" href="#elasticsearch-integration-configuration"></a>11.3.4. Hibernate Search configuration</h4>
<div class="paragraph">
<p>Configuration is minimal.
Add the configuration properties to your <code>persistence.xml</code> or where you put the rest of your Hibernate Search configuration.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Select Elasticsearch as the backend</dt>
<dd>
<p><code>hibernate.search.default.indexmanager elasticsearch</code></p>
</dd>
<dt class="hdlist1">Hostname and port for Elasticsearch</dt>
<dd>
<p><code>hibernate.search.default.elasticsearch.host http://127.0.0.1:9200</code> (default)</p>
<div class="paragraph">
<p>You may also select multiple hosts (separated by whitespace characters), so that they are assigned requests in turns (load balancing):</p>
</div>
<div class="paragraph">
<p><code>hibernate.search.default.elasticsearch.host http://es1.mycompany.com:9200 http://es2.mycompany.com:9200</code></p>
</div>
<div class="paragraph">
<p>In the example above, the first request will go to <code>es1</code>, the second to <code>es2</code>, the third to <code>es1</code>, and so on.</p>
</div>
<div class="paragraph">
<p>Also note having multiple hosts will enable failover:
if one node happens to fail to serve a request (timeout, server error, invalid HTTP response, &#8230;&#8203;),
the same request will be sent to the next one; if the second request is served without error,
the failure will be blamed on the node and no error will be reported to the application.</p>
</div>
<div class="paragraph">
<p>The failover feature will also be enabled when you only have one configured host
but other hosts have been added thanks to automatic discovery (see below).</p>
</div>
</dd>
<dt class="hdlist1">Username for Elasticsearch connection</dt>
<dd>
<p><code>hibernate.search.default.elasticsearch.username ironman</code> (default is empty, meaning anonymous access)</p>
</dd>
<dt class="hdlist1">Password for Elasticsearch connection</dt>
<dd>
<p><code>hibernate.search.default.elasticsearch.password j@rV1s</code> (default is empty)</p>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If you use HTTP instead of HTTPS in any of the Elasticsearch host URLs (see above),
your password will be transmitted in clear text over the network.</p>
</div>
</td>
</tr>
</table>
</div>
</dd>
<dt class="hdlist1"><a id="elasticsearch-schema-management-strategy"></a>Select the index creation strategy</dt>
<dd>
<p><code>hibernate.search.default.elasticsearch.index_schema_management_strategy CREATE</code> (default)</p>
<div class="paragraph">
<p>Let&#8217;s see the options for the <code>index_schema_management_strategy</code> property:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Value</th>
<th class="tableblock halign-left valign-top">Definition</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>none</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The index, its mappings and the analyzer definitions will not be created, deleted nor altered.
Hibernate Search will <strong>not even check</strong> that the index already exists.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>validate</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The index, its existing mappings and analyzer definitions will be checked to be compatible with the metamodel of your application.
The index, its mappings and analyzer definitions will not be created, deleted nor altered.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>update</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The index, its mappings and analyzer definitions will be created, existing mappings will be updated if there are no conflicts.
Caution: if analyzer definitions have to be updated, the index will be closed automatically during the update.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>create</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>The default</strong>: an existing index will not be altered, a missing index will be created along with their mappings and analyzer definitions.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>drop-and-create</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Indexes will be deleted if existing and then created along with their mappings and analyzer definitions to match the requirements of your appllication.
This will delete all content from the indexes! Useful during development.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>drop-and-create-and-drop</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Similar to <code>drop-and-create</code> but will also delete the index at shutdown. Commonly used for tests.</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Since Elasticsearch on Amazon Web Services (AWS)
<a href="https://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/aes-supported-es-operations.html">does not support the <code>_close</code>/<code>_open</code> operations</a>,
the <code>update</code> strategy will fail when trying to update analyzer definitions
on an AWS Elasticsearch cluster.</p>
</div>
<div class="paragraph">
<p>The only workaround is to avoid the <code>update</code> strategy on AWS.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="title">Strategies in production environments</div>
<div class="paragraph">
<p>It is strongly recommended to use either <code>none</code> or <code>validate</code> in a production environment.</p>
</div>
<div class="paragraph">
<p>The alternatives <code>drop-and-create</code> and <code>drop-and-create-and-drop</code> are obviously unsuitable in this context
unless you want to reindex everything upon every startup,
and <code>update</code> may leave your mapping half-updated in case of conflict.</p>
</div>
<div class="paragraph">
<p>To be precise, if your mapping changed in an incompatible way, such as a field having its type changed,
updating the mapping may be impossible without manual intervention.
In this case, the <code>update</code> strategy will prevent Hibernate Search from starting,
but it may already have successfully updated the mappings for another index, making a rollback difficult.</p>
</div>
<div class="paragraph">
<p>When updating analyzer definitions Hibernate Search will temporarily stop the affected indexes during the update.
This means the <code>update</code> strategy should be used with caution when multiple clients use Elasticsearch indexes managed by Hibernate Search:
those clients should be synchronized in such a way that while Hibernate Search is starting, no other client needs to access the index.</p>
</div>
<div class="paragraph">
<p>For these reasons, migrating your mapping on a live cluster should be properly planned within the deployment process.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Mapping validation is as permissive as possible. Fields or mappings that are unknown to Hibernate Search will be ignored, and settings that are more powerful than required (e.g. a field annotated with <code>@Field(index = Index.NO)</code> in Search but marked as <code>"index": analyzed</code> in Elasticsearch) will be deemed valid.</p>
</div>
<div class="paragraph">
<p>One exception: date formats must match exactly the formats specified by Hibernate Search, due to implementation constraints.</p>
</div>
</td>
</tr>
</table>
</div>
</dd>
<dt class="hdlist1">Maximum time to wait for the successful execution of a request to the Elasticsearch server before failing (in ms)</dt>
<dd>
<p><code>hibernate.search.default.elasticsearch.request_timeout 60000</code> (default)</p>
<div class="paragraph">
<p>The execution time of a request includes the time needed to establish a connection,
to send the request, and to receive the whole response,
optionally retrying in case of node failures.</p>
</div>
</dd>
<dt class="hdlist1">Maximum time to wait for a connection to the Elasticsearch server before failing (in ms)</dt>
<dd>
<p><code>hibernate.search.default.elasticsearch.connection_timeout 3000</code> (default)</p>
</dd>
<dt class="hdlist1">Maximum time to wait for a response from the Elasticsearch server before failing (in ms)</dt>
<dd>
<p><code>hibernate.search.default.elasticsearch.read_timeout 60000</code> (default)</p>
</dd>
<dt class="hdlist1">Maximum number of simultaneous connections to the Elasticsearch cluster</dt>
<dd>
<p><code>hibernate.search.default.elasticsearch.max_total_connection 20</code> (default)</p>
</dd>
<dt class="hdlist1">Maximum number of simultaneous connections to a single Elasticsearch server</dt>
<dd>
<p><code>hibernate.search.default.elasticsearch.max_total_connection_per_route 2</code> (default)</p>
</dd>
<dt class="hdlist1">Whether to enable automatic discovery of servers in the Elasticsearch cluster (<code>true</code> or <code>false</code>)</dt>
<dd>
<p><code>hibernate.search.default.elasticsearch.discovery.enabled false</code> (default)</p>
<div class="paragraph">
<p>When using automatic discovery, the Elasticsearch client will periodically probe for new nodes in the cluster,
and will add those to the server list (see <code>host</code> above).
Similarly, the client will periodically check whether registered servers still respond,
and will remove them from the server list if they don&#8217;t.</p>
</div>
</dd>
<dt class="hdlist1">Time interval between two executions of the automatic discovery (in seconds)</dt>
<dd>
<p><code>hibernate.search.default.elasticsearch.discovery.refresh_interval 10</code> (default)</p>
<div class="paragraph">
<p>This setting will only be taken into account if automatic discovery is enabled (see above).</p>
</div>
</dd>
<dt class="hdlist1">Scheme to use when connecting to automatically discovered nodes (<code>http</code> or <code>https</code>)</dt>
<dd>
<p><code>hibernate.search.default.elasticsearch.discovery.default_scheme http</code> (default)</p>
<div class="paragraph">
<p>This setting will only be taken into account if automatic discovery is enabled (see above).</p>
</div>
</dd>
<dt class="hdlist1">Maximum time to wait for the indexes to become available before failing (in ms)</dt>
<dd>
<p><code>hibernate.search.default.elasticsearch.index_management_wait_timeout 10000</code> (default)</p>
<div class="paragraph">
<p>This setting is ignored when the <code>NONE</code> strategy is selected, since the index will not be checked on startup (see above).</p>
</div>
<div class="paragraph">
<p>This value must be lower than the read timeout (see above).</p>
</div>
</dd>
<dt class="hdlist1">Status an index must at least have in order for Hibernate Search to work with it (one of "green", "yellow" or "red")</dt>
<dd>
<p><code>hibernate.search.default.elasticsearch.required_index_status green</code> (default)</p>
<div class="paragraph">
<p>Only operate if the index is at this level or safer.
In development, set this value to <code>yellow</code> if the number of nodes started is below the number of expected replicas.</p>
</div>
</dd>
<dt class="hdlist1">Whether to perform an explicit refresh after a set of operations has been executed against a specific index (<code>true</code> or <code>false</code>)</dt>
<dd>
<p><code>hibernate.search.default.elasticsearch.refresh_after_write false</code> (default)</p>
<div class="paragraph">
<p>This is useful in unit tests to ensure that a write is visible by a query immediately without delay.
This keeps unit tests simpler.
You should not rely on the synchronous behaviour for your production code except in rare cases as Elasticsearch is optimised for asynchronous writes:
leave at <code>false</code> for optimal performance.</p>
</div>
</dd>
<dt class="hdlist1">When <a href="#elasticsearch-scrolling">scrolling</a>, the minimum number of previous results kept in memory at any time</dt>
<dd>
<p><code>hibernate.search.elasticsearch.scroll_backtracking_window_size 10000</code> (default)</p>
</dd>
<dt class="hdlist1">When <a href="#elasticsearch-scrolling">scrolling</a>, the number of results fetched by each Elasticsearch call</dt>
<dd>
<p><code>hibernate.search.elasticsearch.scroll_fetch_size 1000</code> (default)</p>
</dd>
<dt class="hdlist1">When <a href="#elasticsearch-scrolling">scrolling</a>, the maximum duration <code>ScrollableResults</code> will be usable if no other results are fetched from Elasticsearch, in seconds</dt>
<dd>
<p><code>hibernate.search.elasticsearch.scroll_timeout 60</code> (default)</p>
</dd>
<dt class="hdlist1">The behavior with respect to dynamically added fields in the Elasticsearch mapping</dt>
<dd>
<p><code>hibernate.search.default.elasticsearch.dynamic_mapping strict</code> (default)</p>
<div class="paragraph">
<p>Possible values are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>true</code>: Add unknown fields to the schema dynamically</p>
</li>
<li>
<p><code>false</code>: Ignore unknown fields</p>
</li>
<li>
<p><code>strict</code>: Throw an exception on unknown fields</p>
<div class="paragraph">
<p>This setting may be overridden in custom field bridges on a per-field basis:
see <a href="#elasticsearch-custom-field-bridge-dynamic-mapping">Dynamic mapping</a>.</p>
</div>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><a id="elasticsearch-log-json-pretty-printing"></a> Whether JSON included in logs should be pretty-printed (indented, with line breaks) (<code>true</code> or <code>false</code>)</dt>
<dd>
<p><code>hibernate.search.elasticsearch.log.json_pretty_printing false</code> (default)</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Properties prefixed with <code>hibernate.search.default</code> can be given globally as shown above and/or be given for specific indexes:</p>
</div>
<div class="paragraph">
<p><code>hibernate.search.someindex.elasticsearch.index_schema_management_strategy update</code></p>
</div>
<div class="paragraph">
<p>This excludes properties related to the internal Elasticsearch client, which at the moment is common to every index manager (but this will change in a future version).
Excluded properties are <code>host</code>, <code>username</code>, <code>password</code>, <code>read_timeout</code>, <code>connection_timeout</code>, <code>max_total_connection</code>, <code>max_total_connection_per_route</code>, <code>http_client_configurer</code>,
<code>discovery.enabled</code>, <code>discovery.refresh_interval</code> and <code>discovery.scheme</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="elasticsearch-integration-configuration-aws"><a class="anchor" href="#elasticsearch-integration-configuration-aws"></a>Authentication on Amazon Web Services</h5>
<div class="paragraph">
<p>Amazon&#8217;s proprietary IAM authentication through request signing <a href="#elasticsearch-integration-dependencies">requires additional dependencies</a>.
With these dependencies, you will be able to use the following configuration options.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Enable or disable AWS request signing</dt>
<dd>
<p><code>hibernate.search.default.elasticsearch.aws.signing.enabled false</code> (default)</p>
<div class="paragraph">
<p>The value must be either <code>true</code> or <code>false</code>.</p>
</div>
</dd>
<dt class="hdlist1">AWS access key</dt>
<dd>
<p><code>hibernate.search.default.elasticsearch.aws.access_key AKIDEXAMPLE</code></p>
<div class="paragraph">
<p>This property has no default and must be provided for the AWS authentication to work.</p>
</div>
</dd>
<dt class="hdlist1">AWS secret key</dt>
<dd>
<p><code>hibernate.search.default.elasticsearch.aws.secret_key wJalrXUtnFEMI/K7MDENG+bPxRfiCYEXAMPLEKEY</code></p>
<div class="paragraph">
<p>This property has no default and must be provided for the AWS authentication to work.</p>
</div>
</dd>
<dt class="hdlist1">AWS region</dt>
<dd>
<p><code>hibernate.search.default.elasticsearch.aws.region us-east-1</code></p>
<div class="paragraph">
<p>This property has no default and must be provided for the AWS authentication to work.</p>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Should you need help with finding the correct values to use,
please refer to the AWS documentation on <a href="http://docs.aws.amazon.com/general/latest/gr/aws-security-credentials.html">security credentials</a>
and <a href="http://docs.aws.amazon.com/general/latest/gr/rande.html">regions</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Setting these AWS-specific configuration properties is not enough to enable the Elasticsearch integration:
you should also have a look at the <a href="#elasticsearch-integration-configuration">main configuration properties</a>,
most notably <code>hibernate.search.default.indexmanager</code>
and <code>hibernate.search.default.elasticsearch.host</code>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_mapping_and_indexing"><a class="anchor" href="#_mapping_and_indexing"></a>11.4. Mapping and indexing</h3>
<div class="paragraph">
<p>Like in Lucene embedded mode, indexes are transparently updated when you create or update
entities mapped to Hibernate Search.
Simply use familiar annotations from <a href="#search-mapping">Mapping entities to the index structure</a>.</p>
</div>
<div class="paragraph">
<p>The name of the index will be the lowercased name provided to <code>@Indexed</code> (non qualified class name by default).
Hibernate Search will map the fully qualified class name to the Elasticsearch type.</p>
</div>
<div class="sect3">
<h4 id="_annotation_specificities"><a class="anchor" href="#_annotation_specificities"></a>11.4.1. Annotation specificities</h4>
<div class="sect4">
<h5 id="_field_indexnullas"><a class="anchor" href="#_field_indexnullas"></a>Field.indexNullAs</h5>
<div class="paragraph">
<p>The <code>org.hibernate.search.annotations.Field</code> annotation allows you to provide a replacement value for null properties through the <code>indexNullAs</code> attribute (see <a href="#field-annotation">@Field</a>), but this value must be provided as a string.</p>
</div>
<div class="paragraph">
<p>In order for your value to be understood by Hibernate Search (and Elasticsearch), the provided string must follow one of those formats:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>For string values, no particular format is required.</p>
</li>
<li>
<p>For numeric values, use formats accepted by <code>Double.parseDouble</code>, <code>Integer.parseInteger</code>, etc., depending on the actual type of your field.</p>
</li>
<li>
<p>For booleans, use either <code>true</code> or <code>false</code>.</p>
</li>
<li>
<p>For dates (<code>java.util.Calendar</code>, <code>java.util.Date</code>, <code>java.time.*</code>), use the ISO-8601 format.</p>
<div class="paragraph">
<p>The full format is <code>yyyy-MM-dd&#8217;T&#8217;HH:mm:ss.nZ[ZZZ]</code> (for instance <code>2016-11-26T16:41:00.006+01:00[CET]</code>).
Please keep in mind that part of this format must be left out depending on the type of your field, though.
For a <code>java.time.LocalDateTime</code> field, for instance,
the provided string must not include the zone offset (<code>+01:00</code>) or the zone ID (<code>[UTC]</code>), because those don&#8217;t make sense.</p>
</div>
<div class="paragraph">
<p>Even when they make sense for the type of your field, the time and time zone may be omitted
 (if omitted, the time zone will be interpreted as the default JVM time zone).</p>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_index_time_boosting"><a class="anchor" href="#_index_time_boosting"></a>Index-time boosting</h5>
<div class="paragraph">
<p>The <code>org.hibernate.search.annotations.DynamicBoost</code> annotation is not (and cannot be)
supported with Elasticsearch, because the platform lacks per-document, index-time boosting capabilities.</p>
</div>
<div class="paragraph">
<p>The <code>@Boost</code> annotation will work, but since it&#8217;s deprecated
we suggest to use query-time boosting instead: see <a href="#search-query">Querying</a>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="elasticsearch-mapping-analyzer"><a class="anchor" href="#elasticsearch-mapping-analyzer"></a>11.4.2. Analyzers</h4>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Analyzers are treated differently than in Lucene embedded mode.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_built_in_or_server_defined_analyzers"><a class="anchor" href="#_built_in_or_server_defined_analyzers"></a>Built-in or server-defined analyzers</h5>
<div class="paragraph">
<p>Using the <code>definition</code> attribute in the <code>@Analyzer</code> annotation, you can refer to the name of the
built-in Elasticsearch analyzer, or custom analyzers already registered on your Elasticsearch instances.</p>
</div>
<div class="paragraph">
<p>More information on analyzers, in particular those already built in Elasticsearch, can be found
in <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-analyzers.html">the Elasticsearch documentation</a>.</p>
</div>
<div class="listingblock">
<div class="title">Example of custom analyzers defined in the elasticsearch.yml</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-yml" data-lang="yml"># Custom analyzer
index.analysis:
  analyzer.custom-analyzer:
    type: custom
    tokenizer: standard
    filter: [custom-filter, lowercase]
  filter.custom-filter:
    type : stop
    stopwords : [test1, close]</code></pre>
</div>
</div>
<div class="paragraph">
<p>From there, you can use the custom analyzers by name in your entity mappings.</p>
</div>
<div class="listingblock">
<div class="title">Example of mapping that refers to custom and built-in analyzers on Elasticsearch</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity
@Indexed(index = "tweet")
public class Tweet {

    @Id
    @GeneratedValue
    private Integer id;

    @Field
    @Analyzer(definition = "english") // Elasticsearch built-in analyzer
    private String englishTweet;

    @Field
    @Analyzer(definition = "whitespace") // Elasticsearch built-in analyzer
    private String whitespaceTweet;

    @Field(name = "tweetNotAnalyzed", analyzer = Analyze.NO, store = Store.YES)
    // Custom analyzer:
    @Field(
        name = "tweetWithCustom",
        analyzer = @Analyzer(definition = "custom-analyzer")
    )
    private String multipleTweets;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You may also reference a built-in Lucene analyzer implementation using the <code>@Analyzer.impl</code> attribute:
Hibernate Search will translate the implementation to an equivalent Elasticsearch built-in type, if possible.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Using the <code>@Analyzer.impl</code> attribute is not recommended with Elasticsearch because it will
never allow you to take full advantage of Elasticsearch analysis capabilities.
You cannot, for instance, use custom analyzer implementations: only built-in Lucene implementations are supported.</p>
</div>
<div class="paragraph">
<p>This feature is designed to help migrating an application that already used Hibernate Search,
moving from an embedded Lucene instance to an Elasticsearch cluster.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">Example of mapping that refers to a built-in analyzer on Elasticsearch using a Lucene implementation class</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity
@Indexed(index = "tweet")
public class Tweet {

    @Id
    @GeneratedValue
    private Integer id;

    @Field
    @Analyzer(impl = EnglishAnalyzer.class) // Elasticsearch built-in "english" analyzer
    private String englishTweet;

    @Field
    @Analyzer(impl = WhitespaceAnalyzer.class) // Elasticsearch built-in "whitespace" analyzer
    private String whitespaceTweet;

}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_custom_analyzers_using_the_code_analyzerdef_code_annotation"><a class="anchor" href="#_custom_analyzers_using_the_code_analyzerdef_code_annotation"></a>Custom analyzers using the <code>@AnalyzerDef</code> annotation</h5>
<div class="paragraph">
<p>You can also define analyzers within your Hibernate Search mapping using the <code>@AnalyzerDef</code> annotation,
like you would <a href="#section-named-analyzers">do with an embedded Lucene instance</a>.
When Hibernate Search creates the Elasticsearch indexes, the relevant definitions will then be automatically added as a
<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-custom-analyzer.html">custom analyzer</a>
in  the index settings.</p>
</div>
<div class="paragraph">
<p>Two different approaches allow you to define your analyzers with Elasticsearch.</p>
</div>
<div class="paragraph">
<p>The first, recommended approach is to use the factories provided by the <code>hibernate-search-elasticsearch</code> module:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>org.hibernate.search.elasticsearch.analyzer.ElasticsearchCharFilterFactory</code></p>
</li>
<li>
<p><code>org.hibernate.search.elasticsearch.analyzer.ElasticsearchTokenFilterFactory</code></p>
</li>
<li>
<p><code>org.hibernate.search.elasticsearch.analyzer.ElasticsearchTokenizerFactory</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Those classes can be passed to the <code>factory</code> attribute of
the <code>@CharFilterDef</code>, <code>@TokenFilterDef</code> and <code>@TokenizerDef</code> annotations.</p>
</div>
<div class="paragraph">
<p>The <code>params</code> attribute may be used to define the <code>type</code> parameter and any other parameter
accepted by Elasticsearch for this type.</p>
</div>
<div class="paragraph">
<p>The parameter values will be interpreted as JSON. The parser is not strict, though:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>quotes around strings may be left out in some cases, as when a string only contains letters.</p>
</li>
<li>
<p>when quotes are required (e.g. your string may be interpreted as a number, and you don&#8217;t want that),
you may use single quotes instead of double quotes (which are painful to write in Java).</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>You may use the <code>name</code> attribute of the <code>@CharFilterDef</code>, <code>@TokenFilterDef</code> and <code>@TokenizerDef</code> annotations
to define the exact name to give to that definition in the Elasticsearch settings.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">Example of mapping that defines analyzers on Elasticsearch using the <code>Elasticsearch*Factory</code> types</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity
@Indexed(index = "tweet")
@AnalyzerDef(
    name = "tweet_analyzer",
    charFilters = {
        @CharFilterDef(
            name = "custom_html_strip",
            factory = ElasticsearchCharFilterFactory.class,
            params = {
                @Parameter(name = "type", value = "'html_strip'"),
                // One can use Json arrays
                @Parameter(name = "escaped_tags", value = "['br', 'p']")
            }
        ),
        @CharFilterDef(
            name = "p_br_as_space",
            factory = ElasticsearchCharFilterFactory.class,
            params = {
                @Parameter(name = "type", value = "'pattern_replace'"),
                @Parameter(name = "pattern", value = "'&lt;p/?&gt;|&lt;br/?&gt;'"),
                @Parameter(name = "replacement", value = "' '"),
                @Parameter(name = "tags", value = "'CASE_INSENSITIVE'")
            }
        )
    },
    tokenizer = @TokenizerDef(
        factory = ElasticsearchTokenizerFactory.class,
        params = {
            @Parameter(name = "type", value = "'whitespace'"),
        }
    )
)
public class Tweet {

    @Id
    @GeneratedValue
    private Integer id;

    @Field
    @Analyzer(definition = "tweet_analyzer")
    private String content;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The second approach is to configure everything as if you were using Lucene:
use the Lucene factories, their parameter names, and format the parameter values as required in Lucene.
Hibernate Search will automatically convert these definitions to the Elasticsearch equivalent.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Referencing Lucene factories is not recommended with Elasticsearch because it will
never allow you to take full advantage of Elasticsearch analysis capabilities.</p>
</div>
<div class="paragraph">
<p>Here are the known limitations of the automatic translation:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a few factories have unsupported parameters, because those have no equivalent in Elasticsearch.
An exception will be raised on startup if a parameter is not supported.</p>
</li>
<li>
<p>the <code>hyphenator</code> parameter for <code>HyphenatedWordsFilterFactory</code> must refer to
a file on the Elasticsearch servers, on the contrary to other factories
where the files are accessed by Hibernate Search directly.
This is due to an Elasticsearch limitation
(there is no way to forward the content of a local hyphenation pattern file).</p>
</li>
<li>
<p>some built-in Lucene factories are not (and cannot) be translated, because of incompatible
parameters between the Lucene factory and the Elasticsearch equivalent.
This is in particular the case for <code>HunspellStemFilterFactory</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Therefore, Lucene factories should only be referenced within analyzer definitions
when migrating an application that already used Hibernate Search,
moving from an embedded Lucene instance to an Elasticsearch cluster.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">Example of mapping that defines analyzers on Elasticsearch using Lucene factories</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity
@Indexed(index = "tweet")
@AnalyzerDef(
    name = "tweet_analyzer",
    charFilters = {
        @CharFilterDef(
            name = "custom_html_strip",
            factory = HTMLStripCharFilterFactory.class,
            params = {
                @Parameter(name = "escapedTags", value = "br,p")
            }
        ),
        @CharFilterDef(
            name = "p_br_as_space",
            factory = PatternReplaceCharFilterFactory.class,
            params = {
                @Parameter(name = "pattern", value = "&lt;p/?&gt;|&lt;br/?&gt;"),
                @Parameter(name = "replacement", value = " ")
            }
        )
    },
    tokenizer = @TokenizerDef(
        factory = WhitespaceTokenizerFactory.class
    )
)
public class Tweet {

    @Id
    @GeneratedValue
    private Integer id;

    @Field
    @Analyzer(definition = "tweet_analyzer")
    private String content;
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_custom_analyzers_using_a_definition_provider"><a class="anchor" href="#_custom_analyzers_using_a_definition_provider"></a>Custom analyzers using a definition provider</h5>
<div class="paragraph">
<p>As <a href="#section-programmatic-analyzer-definition">with Lucene</a>, you can define analyzers programmatically.</p>
</div>
<div class="paragraph">
<p>In the case of Elasticsearch, this requires to set the
<code>hibernate.search.elasticsearch.analysis_definition_provider</code> configuration property.</p>
</div>
<div class="paragraph">
<p>The property can be set to the fully-qualified name of a class with a public, no-arg constructor in your application.
This class must either implement <code>org.hibernate.search.elasticsearch.analyzer.definition.ElasticsearchAnalysisDefinitionProvider</code> directly
or expose a <code>@Factory</code>-annotated method that returns such implementation.</p>
</div>
<div class="listingblock">
<div class="title">Example of mapping that defines analyzers on Elasticsearch using the <code>Elasticsearch*Factory</code> types</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">public static class CustomAnalyzerProvider implements ElasticsearchAnalysisDefinitionProvider {
    @Override
    public void register(ElasticsearchAnalysisDefinitionRegistryBuilder builder) {
        builder.analyzer( "tweet_analyzer" )
                .withTokenizer( "whitespace" )
                .withCharFilters( "custom_html_strip" )
                .withCharFilters( "p_br_as_space" );

        builder.charFilter( "custom_html_strip" )
                .type( "html_strip" )
                .param( "escaped_tags", "br", "p" );

        builder.charFilter( "p_br_as_space" )
                .type( "pattern_replace" )
                .param( "pattern", "&lt;p/?&gt;|&lt;br/?&gt;" )
                .param( "replacement", " " )
                .param( "tags", "CASE_INSENSITIVE" );
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_normalizers"><a class="anchor" href="#_normalizers"></a>Normalizers</h5>
<div class="paragraph">
<p>Depending on the Elasticsearch version you&#8217;re using,
<a href="#section-normalizers">normalizers</a> will be handled differently:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>On version 5.2 and above, Elasticsearch supports normalizers natively and
thus Hibernate Search normalizers will be translated directly to Elasticsearch normalizers.</p>
</li>
<li>
<p>On version 5.1 and below, Elasticsearch does not support normalizers natively,
thus Hibernate Search normalizers will be translated to Elasticsearch analyzers
with a keyword tokenizer.</p>
</li>
</ul>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>On Elasticsearch 5.1 and below,
the fact that normalizers are translated to Elasticsearch analyzers
means in particular that no normalizer definition should have the
same name as an analyzer definition.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>All the features mentioned above for analyzers are also available when using normalizers:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>They can be defined using Lucene factories with <code>@NormalizerDef</code>,
which will be translated to the equivalent types in Elasticsearch.</p>
</li>
<li>
<p>They can be defined using the special factories <code>ElasticsearchCharFilterFactory</code>
and <code>ElasticsearchTokenFilterFactory</code> with <code>@NormalizerDef</code>.</p>
</li>
<li>
<p>They can be defined using an <code>ElasticsearchAnalysisDefinitionProvider</code>
(use <code>builder.normalizer(name)</code>).</p>
</li>
<li>
<p>The definitions can be referenced using
<code>@Field(normalizer = @Normalizer(definition = "myDefinition"))</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_field_bridges"><a class="anchor" href="#_field_bridges"></a>11.4.3. Field bridges</h4>
<div class="sect4">
<h5 id="_built_in_field_bridges"><a class="anchor" href="#_built_in_field_bridges"></a>Built-in field bridges</h5>
<div class="paragraph">
<p>The default field bridges are the same as those mentioned in the <a href="#section-built-in-bridges">main documentation</a>,
with the following exceptions.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>You can refer to the Elasticsearch documentation for a description of
<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-date-format.html">date formats</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>boolean</code>, <code>Boolean</code></dt>
<dd>
<p>are converted to native JSON booleans.</p>
</dd>
<dt class="hdlist1"><code>Date</code>, <code>Calendar</code></dt>
<dd>
<p>are converted to the Elasticsearch <code>date</code> type
with the default format (<code>strict_date_optional_time||epoch_millis</code>).</p>
</dd>
<dt class="hdlist1"><code>Instant</code></dt>
<dd>
<p>are converted to the Elasticsearch <code>date</code> type
with the default format (<code>strict_date_optional_time||epoch_millis</code>).</p>
</dd>
<dt class="hdlist1"><code>LocalDate</code></dt>
<dd>
<p>are converted to the Elasticsearch <code>date</code> type
with format <code>strict_date||yyyyyyyyy-MM-dd</code>.</p>
</dd>
<dt class="hdlist1"><code>LocalDateTime</code></dt>
<dd>
<p>are converted to the Elasticsearch <code>date</code> type
with format <code>strict_date_hour_minute_second_fraction||yyyyyyyyy-MM-dd&#8217;T&#8217;HH:mm:ss.SSSSSSSSS</code>.</p>
</dd>
<dt class="hdlist1"><code>LocalTime</code></dt>
<dd>
<p>are converted to the Elasticsearch <code>date</code> type
with format <code>strict_hour_minute_second_fraction</code>.</p>
</dd>
<dt class="hdlist1"><code>OffsetDateTime</code></dt>
<dd>
<p>are converted to the Elasticsearch <code>date</code> type
with format <code>strict_date_time||yyyyyyyyy-MM-dd&#8217;T&#8217;HH:mm:ss.SSSSSSSSSZ</code>.</p>
</dd>
<dt class="hdlist1"><code>OffsetTime</code></dt>
<dd>
<p>are converted to the Elasticsearch <code>date</code> type
with format <code>strict_time</code>.</p>
</dd>
<dt class="hdlist1"><code>ZonedDateTime</code></dt>
<dd>
<p>are converted to the Elasticsearch <code>date</code> type
with format <code>yyyy-MM-dd&#8217;T&#8217;HH:mm:ss.SSSZZ'['ZZZ']'||yyyyyyyyy-MM-dd&#8217;T&#8217;HH:mm:ss.SSSSSSSSSZZ'['ZZZ']'</code>.</p>
</dd>
<dt class="hdlist1"><code>Year</code></dt>
<dd>
<p>are converted to the Elasticsearch <code>date</code> type
with format <code>strict_year||yyyyyyyyy</code>.</p>
</dd>
<dt class="hdlist1"><code>YearMonth</code></dt>
<dd>
<p>are converted to the Elasticsearch <code>date</code> type
with format <code>strict_year_month||yyyyyyyyy-MM</code>.</p>
</dd>
<dt class="hdlist1"><code>MonthDay</code></dt>
<dd>
<p>are converted to the Elasticsearch <code>date</code> type
with format <code>--MM-dd</code>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_custom_field_bridges"><a class="anchor" href="#_custom_field_bridges"></a>Custom field bridges</h5>
<div class="paragraph">
<p>You can write custom field bridges and class bridges.
For class bridges and field bridges creating multiple fields,
make sure to make your bridge implementation also implement the <code>MetadataProvidingFieldBridge</code> contract.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">public static class FirstAndMiddleNamesFieldBridge implements MetadataProvidingFieldBridge {

    @Override
    public void set(String name, Object value, Document document, LuceneOptions luceneOptions) {
        Explorer explorer = (Explorer) value;

        String firstName = explorer.getFirstName();
        luceneOptions.addFieldToDocument( name + "_firstName", firstName, document );
        document.add( new SortedDocValuesField( name + "_firstName", new BytesRef( firstName ) ) );

        String middleName = explorer.getMiddleName();
        luceneOptions.addFieldToDocument( name + "_middleName", middleName, document );
        document.add( new SortedDocValuesField( name + "_middleName", new BytesRef( middleName ) ) );
    }

    @Override
    public void configureFieldMetadata(String name, FieldMetadataBuilder builder) {
        builder
            .field( name + "_firstName", FieldType.STRING )
                .sortable( true )
            .field( name + "_middleName", FieldType.STRING )
                .sortable( true );
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>This interface and <code>FieldBridge</code> in general are likely going to evolve in the next major version of Hibernate Search
to remove its adherence to Lucene specific classes like <code>Document</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect5">
<h6 id="_sub_fields"><a class="anchor" href="#_sub_fields"></a>Sub-fields</h6>
<div class="paragraph">
<p>When your <code>MetadataProvidingFieldBridge</code> registers a field whose name is the name of an existing field,
with a dot and another string appended, like <code>name + ".mySubField"</code>,
Hibernate Search will translate it as an object with a property <code>mySubField</code>
in the JSON document sent to Elasticsearch.</p>
</div>
<div class="paragraph">
<p>As a result, sub-fields can only have a parent field with the <code>OBJECT</code> type:
obviously, Elasticsearch would reject a String or an Integer with <code>mySubField</code> property.
So every time a field named <code>foo.bar</code> is registered,
its parent field <code>foo</code> must be registered with the <code>OBJECT</code> type, as in the following example.
Not doing so will result in errors when Hibernate Search generates the Elasticsearch schema.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Override
public void configureFieldMetadata(String name, FieldMetadataBuilder builder) {
    builder
        .field( name, FieldType.OBJECT )
        .field( name + ".firstName", FieldType.STRING )
            .sortable( true )
        .field( name + ".middleName", FieldType.STRING )
            .sortable( true );
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="elasticsearch-custom-field-bridge-dynamic-mapping"><a class="anchor" href="#elasticsearch-custom-field-bridge-dynamic-mapping"></a>Dynamic mapping</h6>
<div class="paragraph">
<p>By default Hibernate Search (or, more accurately, the Elasticsearch schema generated by Hibernate Search)
will not allow custom bridges to create fields that weren&#8217;t
previously registered through the <code>configureFieldMetadata</code> method.</p>
</div>
<div class="paragraph">
<p>If you don&#8217;t know in advance the name of the fields created by your custom bridge,
you can enable "dynamic mapping" globally or per-index through <a href="#elasticsearch-integration-configuration">a configuration option</a>,
or you can do it on a per-field basis using the <code>FieldMetadataCreationContext.mappedOn</code> method
and the <code>org.hibernate.search.elasticsearch.bridge.spi.Elasticsearch</code> extension:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Override
public void configureFieldMetadata(String name, FieldMetadataBuilder builder) {
    builder
        .field( name, FieldType.OBJECT )
            .mappedOn( Elasticsearch.class )
                .dynamic( DynamicType.TRUE ); // Will allow to index fields named &lt;name&gt;.foo, &lt;name&gt;.bar, etc.
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Dynamic mapping involves Elasticsearch guessing the type and attributes of fields automatically,
and has its own limitations.
See <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/dynamic-mapping.html">the Elasticsearch documentation</a>
for more information.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_tika_bridges"><a class="anchor" href="#_tika_bridges"></a>11.4.4. Tika bridges</h4>
<div class="paragraph">
<p>If your metadata processors create fields with a different name from the one passed as a parameter, make sure to make your processor also implement the <code>MetadataProvidingTikaMetadataProcessor</code> contract.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_queries"><a class="anchor" href="#_queries"></a>11.5. Queries</h3>
<div class="paragraph">
<p>You can write queries like you usually do in Hibernate Search: native Lucene queries and DSL queries (see <a href="#search-query">Querying</a>).
We do automatically translate the most common types of Apache Lucene queries
and all queries generated by the Hibernate Search DSL except more like this (see below).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Unsupported Query DSL features</div>
<div class="paragraph">
<p>Queries written via the DSL work.
Open a JIRA otherwise.</p>
</div>
<div class="paragraph">
<p>The notable exception is more like this queries.
Hibernate Search has a more advanced algorithm than Lucene (or Elasticsearch/Solr)
which is not easily portable with what Elasticsearch exposes.</p>
</div>
<div class="paragraph">
<p>If you need this feature, contact us.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>On top of translating Lucene queries,
you can directly create Elasticsearch queries by using either its String format or a JSON format:</p>
</div>
<div class="exampleblock">
<div class="title">Example 157. Creating an Elasticsearch native query from a string</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">FullTextEntityManager fullTextEm = Search.getFullTextEntityManager(entityManager);
QueryDescriptor query = ElasticsearchQueries.fromQueryString("title:tales");
List&lt;?&gt; result = fullTextEm.createFullTextQuery(query, ComicBook.class).getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 158. Creating an Elasticsearch native query from JSON</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">FullTextEntityManager fullTextEm = Search.getFullTextEntityManager(entityManager);
QueryDescriptor query = ElasticsearchQueries.fromJson(
      "{ 'query': { 'match' : { 'lastName' : 'Brand' } } }");
List&lt;?&gt; result = fullTextEm.createFullTextQuery(query, GolfPlayer.class).getResultList();</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Date/time in native Elasticsearch queries</div>
<div class="paragraph">
<p>By default Elasticsearch interprets the date/time strings lacking the time zone as if they were represented using the UTC time zone. If overlooked, this can cause your native Elasticsearch queries to be completely off.</p>
</div>
<div class="paragraph">
<p>The simplest way to avoid issues is to always explicitly provide time zone IDs or offsets when building native Elasticsearch queries. This may be achieved either by directly adding the time zone ID or offset in date strings, or by using the <code>time_zone</code> parameter (range queries only). See the Elasticsearch documentation for more information.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Simple query string queries and analyzers</div>
<div class="paragraph">
<p>The simple query string DSL is supported by the Elasticsearch integration.</p>
</div>
<div class="paragraph">
<p>In the general case, your query will automatically use the analyzers defined in the schema but be aware that, in the advanced case when you want to override the analyzer used, Elasticsearch only supports overriding the analyzer globally.</p>
</div>
<div class="paragraph">
<p>Thus, when overriding the analyzer, it must be consistent across all the queried fields.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="elasticsearch-query-spatial"><a class="anchor" href="#elasticsearch-query-spatial"></a>11.5.1. Spatial queries</h4>
<div class="paragraph">
<p>The Elasticsearch integration supports spatial queries by using either the DSL or native Elasticsearch queries.</p>
</div>
<div class="paragraph">
<p>For regular usage, there are no particular requirements for spatial support.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>On Elasticsearch 2.x only (not necessary on 5.x),
if you want to calculate the distance from your entities to a point <strong>without sorting</strong> by the distance to this point,
you need to enable the Groovy plugin by adding the following snippet to your Elasticsearch configuration:</p>
</div>
<div class="listingblock">
<div class="title">Enabling Groovy support in your elasticsearch.yml</div>
<div class="content">
<pre>script.engine.groovy.inline.search: true</pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="elasticsearch-scrolling"><a class="anchor" href="#elasticsearch-scrolling"></a>11.5.2. Paging and scrolling</h4>
<div class="paragraph">
<p>You may handle large result sets in two different ways, with different limitations.</p>
</div>
<div class="paragraph">
<p>For (relatively) smaller result sets, you may use the traditional offset/limit querying provided by the <code>FullTextQuery</code> interfaces: <code>setFirstResult(int)</code> and <code>setMaxResults(int)</code>.
Limitations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>This will only get you as far as the 10000 first documents, i.e. when requesting a window that includes documents beyond the 10000th result, Elasticsearch will return an error. If you want to raise this limit, see the <code>index.max_result_window</code> property in <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index-modules.html#dynamic-index-settings">Elasticsearch&#8217;s settings</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If your result set is bigger, you may take advantage of scrolling by using the <code>scroll</code> method on <code>org.hibernate.search.FullTextQuery</code>.
Limitations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>This method is not available in <code>org.hibernate.search.jpa.FullTextQuery</code>.</p>
</li>
<li>
<p>The Elasticsearch implementation has poor performance when an offset has been defined (i.e. <code>setFirstResult(int)</code> has been called on the query before calling <code>scroll()</code>).
This is because Elasticsearch does not provide such feature, thus Hibernate Search has to scroll through every previous result under the hood.</p>
</li>
<li>
<p>The Elasticsearch implementation allows only limited backtracking. Calling <code>scrollableResults.setRowNumber(4)</code> when currently positioned at index <code>1006</code>,
for example, may result in a <code>SearchException</code> being thrown, because only 1000 previous elements had been kept in memory.
You may work this around by tweaking the property: <code>hibernate.search.elasticsearch.scroll_backtracking_window_size</code> (see <a href="#elasticsearch-integration-configuration">Elasticsearch integration configuration</a>).</p>
</li>
<li>
<p>The <code>ScrollableResults</code> will become stale and unusable after a given period of time spent without fetching results from Elasticsearch.
You may work this around by tweaking two properties: <code>hibernate.search.elasticsearch.scroll_timeout</code> and <code>hibernate.search.elasticsearch.scroll_fetch_size</code> (see <a href="#elasticsearch-integration-configuration">Elasticsearch integration configuration</a>).
Typically, you will solve timeout issues by reducing the fetch size and/or increasing the timeout limit, but this will also increase the performance hit on Elasticsearch.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="elasticsearch-query-sorting"><a class="anchor" href="#elasticsearch-query-sorting"></a>11.5.3. Sorting</h4>
<div class="paragraph">
<p>Sorting is performed the same way as <a href="#query-sorting">with the Lucene backend</a>.</p>
</div>
<div class="paragraph">
<p>If you happen to need an advanced Elasticsearch sorting feature that is not natively supported in <code>SortField</code> or in Hibernate Search sort DSL, you may still create a sort from JSON, and even mix it with DSL-defined sorts:</p>
</div>
<div class="exampleblock">
<div class="title">Example 159. Mixing DSL-defined sorts with native Elasticsearch JSON sorts</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-JAVA" data-lang="JAVA">FullTextEntityManager fullTextEm = Search.getFullTextEntityManager(entityManager);
org.hibernate.search.query.dsl.QueryBuilder queryBuilder =
        fullTextEm.getSearchFactory()
        .buildQueryBuilder().forEntity(Book.class).get();
Query luceneQuery = /* ... use the query builder as explained in tje Querying section ... */;
FullTextQuery query = fullTextEm.createFullTextQuery( luceneQuery, Book.class );
Sort sort = queryBuilder.sort()
        .byNative("authors.name", "{'order':'asc', 'mode': 'min'}")
        .andByField("title")
        .createSort();
query.setSort(sort);
List results = query.getResultList();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_projections"><a class="anchor" href="#_projections"></a>11.5.4. Projections</h4>
<div class="paragraph">
<p>All fields are stored by Elasticsearch in the JSON document it indexes,
there is no specific need to mark fields as stored when you want to project them.
The downside is that to project a field, Elasticsearch needs to read the whole JSON document.
If you want to avoid that, use the <code>Store.YES</code> marker.</p>
</div>
<div class="paragraph">
<p>You can also retrieve the full JSON document by using <code>org.hibernate.search.elasticsearch.ElasticsearchProjectionConstants.SOURCE</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">FullTextEntityManager fullTextEm = Search.getFullTextEntityManager(entityManager);
FullTextQuery query = fullTextEm.createFullTextQuery(
                    qb.keyword()
                    .onField( "tags" )
                    .matching( "round-based" )
                    .createQuery(),
                    VideoGame.class
            )
            .setProjection( ElasticsearchProjectionConstants.SCORE, ElasticsearchProjectionConstants.SOURCE );

Object[] projection = (Object[]) query.getSingleResult();</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you&#8217;re looking for information about execution time, you may also use <code>org.hibernate.search.elasticsearch.ElasticsearchProjectionConstants.TOOK</code> and <code>org.hibernate.search.elasticsearch.ElasticsearchProjectionConstants.TIMED_OUT</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">FullTextEntityManager fullTextEm = Search.getFullTextEntityManager(entityManager);
FullTextQuery query = fullTextEm.createFullTextQuery(
                    qb.keyword()
                    .onField( "tags" )
                    .matching( "round-based" )
                    .createQuery(),
                    VideoGame.class
            )
            .setProjection(
                    ElasticsearchProjectionConstants.SOURCE,
                    ElasticsearchProjectionConstants.TOOK,
                    ElasticsearchProjectionConstants.TIMED_OUT
            );

Object[] projection = (Object[]) query.getSingleResult();
Integer took = (Integer) projection[1]; // Execution time (milliseconds)
Boolean timedOut = (Boolean) projection[2]; // Whether the query timed out</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_filters"><a class="anchor" href="#_filters"></a>11.5.5. Filters</h4>
<div class="paragraph">
<p>The Elasticsearch integration supports the definition of full text filters.</p>
</div>
<div class="paragraph">
<p>Your filters need to implement the <code>ElasticsearchFilter</code> interface.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">public class DriversMatchingNameElasticsearchFilter implements ElasticsearchFilter {

    private String name;

    public DriversMatchingNameElasticsearchFilter() {
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String getJsonFilter() {
        return "{ 'term': { 'name': '" + name + "' } }";
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can then declare the filter in your entity.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity
@Indexed
@FullTextFilterDef(name = "namedDriver",
  impl = DriversMatchingNameElasticsearchFilter.class)
public class Driver {
    @Id
    @DocumentId
    private int id;

    @Field(analyze = Analyze.YES)
    private String name;

    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>From then you can use it as usual.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">FullTextQuery ftQuery = /* ... */;
ftQuery.enableFullTextFilter( "namedDriver" ).setParameter( "name", "liz" );</code></pre>
</div>
</div>
<div class="paragraph">
<p>For static filters, you can simply extend the <code>SimpleElasticsearchFilter</code> and provide an Elasticsearch filter in JSON form.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_index_optimization"><a class="anchor" href="#_index_optimization"></a>11.6. Index optimization</h3>
<div class="paragraph">
<p>The optimization features documented in <a href="#search-optimize">Index Optimization</a> are only partially implemented. That kind of optimization is rarely needed with recent versions of Lucene (on which Elasticsearch is based), but some of it is still provided for the very specific case of indexes meant to stay read-only for a long period of time:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The automatic optimization is not implemented and most probably never will be.</p>
</li>
<li>
<p>The manual optimization (<code>searchFactory.optimize()</code>) is implemented.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="elasticsearch-logging"><a class="anchor" href="#elasticsearch-logging"></a>11.6.1. Logging executed requests</h4>
<div class="paragraph">
<p>Search queries are logged to the <code>org.hibernate.search.fulltext_query</code> category at <code>DEBUG</code> level,
as when using an embedded Lucene instance (the query format is Elasticsearch&#8217;s, though).</p>
</div>
<div class="paragraph">
<p>In addition, you can enable the logging of every single request sent to the Elasticsearch cluster
by enabling <code>DEBUG</code> logging for the log category <code>org.hibernate.search.elasticsearch.request</code>.
The logs will include, in particular, the HTTP method, path, query parameters, execution time and response status.
At <code>DEBUG</code> level, the request body and response body will be omitted;
use the <code>TRACE</code> level to also print out the request body and response body.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>By default, JSON in logs will be printed inline, without indent.
If you wish the JSON to be pretty-printed, use the
<a href="#elasticsearch-log-json-pretty-printing"><code>hibernate.search.elasticsearch.log.json_pretty_printing</code> configuration property</a>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="elasticsearch-limitations"><a class="anchor" href="#elasticsearch-limitations"></a>11.7. Limitations</h3>
<div class="paragraph">
<p>Not everything is implemented yet.</p>
</div>
<div class="paragraph">
<p>At the time of writing this, the following features are known to not work yet; feel free to check the JIRA links to get updates:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Query timeouts: <a href="https://hibernate.atlassian.net/browse/HSEARCH-2399">HSEARCH-2399</a></p>
</li>
<li>
<p>MoreLikeThis queries: <a href="https://hibernate.atlassian.net/browse/HSEARCH-2395">HSEARCH-2395</a></p>
</li>
<li>
<p><code>@IndexedEmbedded.indexNullAs</code>: <a href="https://hibernate.atlassian.net/browse/HSEARCH-2389">HSEARCH-2389</a></p>
</li>
<li>
<p><a href="#search-monitoring">Statistics</a>: <a href="https://hibernate.atlassian.net/browse/HSEARCH-2421">HSEARCH-2421</a></p>
</li>
<li>
<p><code>@AnalyzerDiscriminator</code>: <a href="https://hibernate.atlassian.net/browse/HSEARCH-2428">HSEARCH-2428</a></p>
</li>
<li>
<p>Dynamic sharding: <a href="https://hibernate.atlassian.net/browse/HSEARCH-2725">HSEARCH-2725</a></p>
</li>
<li>
<p>Mixing Lucene based indexes and Elasticsearch based indexes (partial support is implemented though)</p>
</li>
<li>
<p>Hibernate Search does not make use of nested objects nor parent child relationship mapping <a href="https://hibernate.atlassian.net/browse/HSEARCH-2263">HSEARCH-2263</a>.
This is largely mitigated by the fact that Hibernate Search does the denormalization itself and maintain data consistency when nested objects are updated.</p>
</li>
<li>
<p>There is room for improvements in the performances of the MassIndexer implementation</p>
</li>
<li>
<p>Our new Elasticsearch integration module does not work in OSGi environments. If you need this, please vote for: <a href="https://hibernate.atlassian.net/browse/HSEARCH-2524">HSEARCH-2524</a>.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_specific_versions_of_elasticsearch_to_avoid"><a class="anchor" href="#_specific_versions_of_elasticsearch_to_avoid"></a>11.8. Specific versions of Elasticsearch to avoid</h3>
<div class="paragraph">
<p>We might occasionally hit issues in specific versions of Elasticsearch.
This is not the right place to track Elasticsearch defects but we&#8217;ll do our best to track specific issues which affect compatibility with Hibernate Search.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Mapping <code>java.time.ZonedDateTime</code> won&#8217;t work with Elasticsearch 2.4.1 because of <a href="https://github.com/elastic/elasticsearch/issues/20911">a JodaTime bug affecting Elasticsearch</a>: <a href="https://hibernate.atlassian.net/browse/HSEARCH-2414">HSEARCH-2414</a>.</p>
<div class="paragraph">
<p><strong>Solution:</strong> Upgrade to Elasticsearch 2.4.2 or later.</p>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_acknowledgment"><a class="anchor" href="#_acknowledgment"></a>11.9. Acknowledgment</h3>
<div class="paragraph">
<p>More information about Elasticsearch can be found on the <a href="https://www.elastic.co/products/elasticsearch">Elasticsearch website</a>
and its <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html">reference documentation</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_further_reading"><a class="anchor" href="#_further_reading"></a>12. Further reading</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Last but not least, a few pointers to further information. We highly recommend you to get a copy of
<a href="http://www.manning.com/bernard/">Hibernate Search in Action</a>. This excellent book covers
Hibernate Search in much more depth than this online documentation can and has a great range of
additional examples. If you want to increase your knowledge of Lucene we recommend
<a href="http://www.manning.com/hatcher3/">Lucene in Action (Second Edition)</a>.</p>
</div>
<div class="paragraph">
<p>Because Hibernate Search&#8217;s functionality is tightly coupled to Hibernate ORM it is a good idea to understand
Hibernate. Start with the <a href="http://hibernate.org/orm/documentation/">online documentation</a> or get hold
of a copy of <a href="http://www.manning.com/bauer3/">Java Persistence with Hibernate, Second Edition</a>.</p>
</div>
<div class="paragraph">
<p>If you have any further questions regarding Hibernate Search or want to share some of your use cases
have a look at the <a href="https://community.jboss.org/en/hibernate/search">Hibernate Search Wiki</a>
and the <a href="https://forum.hibernate.org/viewforum.php?f=9">Hibernate Search Forum</a>. We are
looking forward hearing from you.</p>
</div>
<div class="paragraph">
<p>In case you would like to report a bug use the
<a href="https://hibernate.atlassian.net/browse/HSEARCH">Hibernate Search JIRA</a> instance. Feedback is
always welcome!</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="credits"><a class="anchor" href="#credits"></a>13. Credits</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The full list of contributors to Hibernate Search can be found in the <code>copyright.txt</code> file in the Hibernate Search sources,
available in particular in our <a href="https://github.com/hibernate/hibernate-search/blob/master/copyright.txt">git repository</a>.</p>
</div>
<div class="paragraph">
<p>The following contributors have been involved in this documentation:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Emmanuel Bernard</p>
</li>
<li>
<p>Hardy Ferentschik</p>
</li>
<li>
<p>Gustavo Fernandes</p>
</li>
<li>
<p>Sanne Grinovero</p>
</li>
<li>
<p>Nabeel Ali Memon</p>
</li>
<li>
<p>Gunnar Morling</p>
</li>
<li>
<p>Yoann Rodire</p>
</li>
<li>
<p>Guillaume Smet</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2017-09-13 22:27:47 UTC
</div>
</div>
<!-- Google Analytics -->
<script type="text/javascript">
	dataLayer = [{'channel' : 'Hibernate', 'additional_tracking_code' : 'UA-45270411-3'}];
	(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
		new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
		j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
	})(window,document,'script','dataLayer','GTM-NJWS5L');
</script>
<noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-NJWS5L" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- /Google Analytics -->

<!-- HibernateDoc.OutdatedContent -->
<script src="//code.jquery.com/jquery-3.1.0.min.js" integrity="sha256-cCueBR6CsyA4/9szpPfrX3s49M9vUU5BgtiJj06wt/s=" crossorigin="anonymous"></script>
<script src="/hibernate/_outdated-content/outdated-content.js" type="text/javascript"></script>
<script type="text/javascript">var jQuery_3_1 = $.noConflict(true); jQuery_3_1(document).ready(function() { HibernateDoc.OutdatedContent.install('search'); });</script>
<!-- /HibernateDoc.OutdatedContent -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.js"></script>
<script>prettyPrint()</script>
</body>
</html>